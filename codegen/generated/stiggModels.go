// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package stiggOperations

import (
	"fmt"
	"io"
	"strconv"
)

type Credentials interface {
	IsCredentials()
}

type ResetPeriodConfiguration interface {
	IsResetPeriodConfiguration()
}

type Account struct {
	ID                        string         `json:"id"`
	DisplayName               string         `json:"displayName"`
	Timezone                  *string        `json:"timezone"`
	SubscriptionBillingAnchor *BillingAnchor `json:"subscriptionBillingAnchor"`
}

type AccountNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type AddCompatibleAddonsToPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type AdditionalMetaDataChange struct {
	Before     map[string]interface{} `json:"before"`
	After      map[string]interface{} `json:"after"`
	ChangeType *ChangeType            `json:"changeType"`
}

type Addon struct {
	ID                 string                 `json:"id"`
	CreatedAt          *string                `json:"createdAt"`
	UpdatedAt          *string                `json:"updatedAt"`
	RefID              string                 `json:"refId"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	DisplayName        string                 `json:"displayName"`
	Status             PackageStatus          `json:"status"`
	PricingType        *PricingType           `json:"pricingType"`
	Description        *string                `json:"description"`
	EnvironmentID      *string                `json:"environmentId"`
	Type               *string                `json:"type"`
	ProductID          *string                `json:"productId"`
	IsLatest           *bool                  `json:"isLatest"`
	Entitlements       []*PackageEntitlement  `json:"entitlements"`
	DraftSummary       *PackageDraftSummary   `json:"draftSummary"`
	DraftDetails       *PackageDraftDetails   `json:"draftDetails"`
	VersionNumber      int64                  `json:"versionNumber"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	SyncStates         []*SyncState           `json:"syncStates"`
	Product            *Product               `json:"product"`
	Environment        *Environment           `json:"environment"`
	Prices             []*Price               `json:"prices"`
}

type AddonAggregateGroupBy struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	RefID         *string        `json:"refId"`
	BillingID     *string        `json:"billingId"`
	DisplayName   *string        `json:"displayName"`
	Status        *PackageStatus `json:"status"`
	PricingType   *PricingType   `json:"pricingType"`
	Description   *string        `json:"description"`
	EnvironmentID *string        `json:"environmentId"`
	ProductID     *string        `json:"productId"`
	IsLatest      *bool          `json:"isLatest"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type AddonConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*AddonEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type AddonCountAggregate struct {
	ID            *int64 `json:"id"`
	CreatedAt     *int64 `json:"createdAt"`
	UpdatedAt     *int64 `json:"updatedAt"`
	RefID         *int64 `json:"refId"`
	BillingID     *int64 `json:"billingId"`
	DisplayName   *int64 `json:"displayName"`
	Status        *int64 `json:"status"`
	PricingType   *int64 `json:"pricingType"`
	Description   *int64 `json:"description"`
	EnvironmentID *int64 `json:"environmentId"`
	ProductID     *int64 `json:"productId"`
	IsLatest      *int64 `json:"isLatest"`
	VersionNumber *int64 `json:"versionNumber"`
}

type AddonCreateInput struct {
	DisplayName        string                 `json:"displayName"`
	Description        *string                `json:"description,omitempty"`
	RefID              *string                `json:"refId,omitempty"`
	Status             *PackageStatus         `json:"status,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	ProductID          string                 `json:"productId"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
}

type AddonDeleteResponse struct {
	ID                 *string                `json:"id"`
	CreatedAt          *string                `json:"createdAt"`
	UpdatedAt          *string                `json:"updatedAt"`
	RefID              *string                `json:"refId"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	DisplayName        *string                `json:"displayName"`
	Status             *PackageStatus         `json:"status"`
	PricingType        *PricingType           `json:"pricingType"`
	Description        *string                `json:"description"`
	EnvironmentID      *string                `json:"environmentId"`
	Type               *string                `json:"type"`
	ProductID          *string                `json:"productId"`
	IsLatest           *bool                  `json:"isLatest"`
	Entitlements       []*PackageEntitlement  `json:"entitlements"`
	DraftSummary       *PackageDraftSummary   `json:"draftSummary"`
	DraftDetails       *PackageDraftDetails   `json:"draftDetails"`
	VersionNumber      *int64                 `json:"versionNumber"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	SyncStates         []*SyncState           `json:"syncStates"`
}

type AddonEdge struct {
	// The node containing the Addon
	Node Addon `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type AddonFilter struct {
	And           []*AddonFilter                 `json:"and,omitempty"`
	Or            []*AddonFilter                 `json:"or,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type AddonMaxAggregate struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	RefID         *string        `json:"refId"`
	BillingID     *string        `json:"billingId"`
	DisplayName   *string        `json:"displayName"`
	Status        *PackageStatus `json:"status"`
	PricingType   *PricingType   `json:"pricingType"`
	Description   *string        `json:"description"`
	EnvironmentID *string        `json:"environmentId"`
	ProductID     *string        `json:"productId"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonMinAggregate struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	RefID         *string        `json:"refId"`
	BillingID     *string        `json:"billingId"`
	DisplayName   *string        `json:"displayName"`
	Status        *PackageStatus `json:"status"`
	PricingType   *PricingType   `json:"pricingType"`
	Description   *string        `json:"description"`
	EnvironmentID *string        `json:"environmentId"`
	ProductID     *string        `json:"productId"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonSort struct {
	Field     AddonSortFields `json:"field"`
	Direction SortDirection   `json:"direction"`
	Nulls     *SortNulls      `json:"nulls,omitempty"`
}

type AddonSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type AddonUpdateInput struct {
	ID                 string                 `json:"id"`
	DisplayName        string                 `json:"displayName"`
	Description        *string                `json:"description,omitempty"`
	Status             *PackageStatus         `json:"status,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
}

type Address struct {
	Country      *string `json:"country,omitempty"`
	State        *string `json:"state,omitempty"`
	AddressLine1 *string `json:"addressLine1,omitempty"`
	AddressLine2 *string `json:"addressLine2,omitempty"`
	City         *string `json:"city,omitempty"`
	PostalCode   *string `json:"postalCode,omitempty"`
	PhoneNumber  *string `json:"phoneNumber,omitempty"`
}

type APIKey struct {
	ID      string     `json:"id"`
	KeyType APIKeyType `json:"keyType"`
	Token   string     `json:"token"`
}

type APIKeyFilter struct {
	And []*APIKeyFilter        `json:"and,omitempty"`
	Or  []*APIKeyFilter        `json:"or,omitempty"`
	ID  *StringFieldComparison `json:"id,omitempty"`
}

type APIKeySort struct {
	Field     APIKeySortFields `json:"field"`
	Direction SortDirection    `json:"direction"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

type ArchiveCouponInput struct {
	RefID         string  `json:"refId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type ArchivePlanInput struct {
	ID            string  `json:"id"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type AsyncTaskResult struct {
	TaskID string `json:"taskId"`
}

type AttachCustomerPaymentMethodInput struct {
	RefID            *string          `json:"refId,omitempty"`
	CustomerID       *string          `json:"customerId,omitempty"`
	EnvironmentID    *string          `json:"environmentId,omitempty"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
	PaymentMethodID  string           `json:"paymentMethodId"`
}

type BaseError struct {
	Code string `json:"code"`
}

type BasePlanChange struct {
	Before     *Addon      `json:"before"`
	After      *Addon      `json:"after"`
	ChangeType *ChangeType `json:"changeType"`
}

type BillingModelFilterComparison struct {
	Is       *bool          `json:"is,omitempty"`
	IsNot    *bool          `json:"isNot,omitempty"`
	Eq       *BillingModel  `json:"eq,omitempty"`
	Neq      *BillingModel  `json:"neq,omitempty"`
	Gt       *BillingModel  `json:"gt,omitempty"`
	Gte      *BillingModel  `json:"gte,omitempty"`
	Lt       *BillingModel  `json:"lt,omitempty"`
	Lte      *BillingModel  `json:"lte,omitempty"`
	Like     *BillingModel  `json:"like,omitempty"`
	NotLike  *BillingModel  `json:"notLike,omitempty"`
	ILike    *BillingModel  `json:"iLike,omitempty"`
	NotILike *BillingModel  `json:"notILike,omitempty"`
	In       []BillingModel `json:"in,omitempty"`
	NotIn    []BillingModel `json:"notIn,omitempty"`
}

type BillingPeriodFilterComparison struct {
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Eq       *BillingPeriod  `json:"eq,omitempty"`
	Neq      *BillingPeriod  `json:"neq,omitempty"`
	Gt       *BillingPeriod  `json:"gt,omitempty"`
	Gte      *BillingPeriod  `json:"gte,omitempty"`
	Lt       *BillingPeriod  `json:"lt,omitempty"`
	Lte      *BillingPeriod  `json:"lte,omitempty"`
	Like     *BillingPeriod  `json:"like,omitempty"`
	NotLike  *BillingPeriod  `json:"notLike,omitempty"`
	ILike    *BillingPeriod  `json:"iLike,omitempty"`
	NotILike *BillingPeriod  `json:"notILike,omitempty"`
	In       []BillingPeriod `json:"in,omitempty"`
	NotIn    []BillingPeriod `json:"notIn,omitempty"`
}

type BooleanFieldComparison struct {
	Is    *bool `json:"is,omitempty"`
	IsNot *bool `json:"isNot,omitempty"`
}

type CannotDeleteCustomerError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CannotDeleteFeatureError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type Checkout struct {
	ID                string `json:"id"`
	CheckoutBillingID string `json:"checkoutBillingId"`
	CheckoutURL       string `json:"checkoutUrl"`
}

type CheckoutOptions struct {
	SuccessURL            string `json:"successUrl"`
	CancelURL             string `json:"cancelUrl"`
	AllowPromoCodes       *bool  `json:"allowPromoCodes,omitempty"`
	CollectBillingAddress *bool  `json:"collectBillingAddress,omitempty"`
}

type Coupon struct {
	ID                 string                 `json:"id"`
	Name               string                 `json:"name"`
	RefID              string                 `json:"refId"`
	Description        *string                `json:"description"`
	CreatedAt          string                 `json:"createdAt"`
	UpdatedAt          string                 `json:"updatedAt"`
	EnvironmentID      string                 `json:"environmentId"`
	Type               CouponType             `json:"type"`
	Status             CouponStatus           `json:"status"`
	DiscountValue      float64                `json:"discountValue"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	SyncStates         []*SyncState           `json:"syncStates"`
	Environment        *Environment           `json:"environment"`
	Customers          []*Customer            `json:"customers"`
}

type CouponAggregateGroupBy struct {
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Description   *string       `json:"description"`
	CreatedAt     *string       `json:"createdAt"`
	UpdatedAt     *string       `json:"updatedAt"`
	EnvironmentID *string       `json:"environmentId"`
	Type          *CouponType   `json:"type"`
	Status        *CouponStatus `json:"status"`
	BillingID     *string       `json:"billingId"`
}

type CouponAvgAggregate struct {
	ID *float64 `json:"id"`
}

type CouponConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*CouponEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CouponCountAggregate struct {
	ID            *int64 `json:"id"`
	Name          *int64 `json:"name"`
	RefID         *int64 `json:"refId"`
	Description   *int64 `json:"description"`
	CreatedAt     *int64 `json:"createdAt"`
	UpdatedAt     *int64 `json:"updatedAt"`
	EnvironmentID *int64 `json:"environmentId"`
	Type          *int64 `json:"type"`
	Status        *int64 `json:"status"`
	BillingID     *int64 `json:"billingId"`
}

type CouponEdge struct {
	// The node containing the Coupon
	Node Coupon `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type CouponFilter struct {
	And           []*CouponFilter               `json:"and,omitempty"`
	Or            []*CouponFilter               `json:"or,omitempty"`
	ID            *StringFieldComparison        `json:"id,omitempty"`
	Name          *StringFieldComparison        `json:"name,omitempty"`
	RefID         *StringFieldComparison        `json:"refId,omitempty"`
	Description   *StringFieldComparison        `json:"description,omitempty"`
	CreatedAt     *DateFieldComparison          `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison          `json:"updatedAt,omitempty"`
	EnvironmentID *StringFieldComparison        `json:"environmentId,omitempty"`
	Type          *CouponTypeFilterComparison   `json:"type,omitempty"`
	Status        *CouponStatusFilterComparison `json:"status,omitempty"`
	BillingID     *StringFieldComparison        `json:"billingId,omitempty"`
	Customers     *CouponFilterCustomerFilter   `json:"customers,omitempty"`
}

type CouponFilterCustomerFilter struct {
	And                  []*CouponFilterCustomerFilter `json:"and,omitempty"`
	Or                   []*CouponFilterCustomerFilter `json:"or,omitempty"`
	ID                   *StringFieldComparison        `json:"id,omitempty"`
	Name                 *StringFieldComparison        `json:"name,omitempty"`
	Email                *StringFieldComparison        `json:"email,omitempty"`
	RefID                *StringFieldComparison        `json:"refId,omitempty"`
	CustomerID           *StringFieldComparison        `json:"customerId,omitempty"`
	CreatedAt            *DateFieldComparison          `json:"createdAt,omitempty"`
	UpdatedAt            *DateFieldComparison          `json:"updatedAt,omitempty"`
	EnvironmentID        *StringFieldComparison        `json:"environmentId,omitempty"`
	BillingID            *StringFieldComparison        `json:"billingId,omitempty"`
	CrmID                *StringFieldComparison        `json:"crmId,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison        `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison        `json:"crmHubspotCompanyUrl,omitempty"`
}

type CouponMaxAggregate struct {
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Description   *string       `json:"description"`
	CreatedAt     *string       `json:"createdAt"`
	UpdatedAt     *string       `json:"updatedAt"`
	EnvironmentID *string       `json:"environmentId"`
	Type          *CouponType   `json:"type"`
	Status        *CouponStatus `json:"status"`
	BillingID     *string       `json:"billingId"`
}

type CouponMinAggregate struct {
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Description   *string       `json:"description"`
	CreatedAt     *string       `json:"createdAt"`
	UpdatedAt     *string       `json:"updatedAt"`
	EnvironmentID *string       `json:"environmentId"`
	Type          *CouponType   `json:"type"`
	Status        *CouponStatus `json:"status"`
	BillingID     *string       `json:"billingId"`
}

type CouponSort struct {
	Field     CouponSortFields `json:"field"`
	Direction SortDirection    `json:"direction"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

type CouponStatusFilterComparison struct {
	Is       *bool          `json:"is,omitempty"`
	IsNot    *bool          `json:"isNot,omitempty"`
	Eq       *CouponStatus  `json:"eq,omitempty"`
	Neq      *CouponStatus  `json:"neq,omitempty"`
	Gt       *CouponStatus  `json:"gt,omitempty"`
	Gte      *CouponStatus  `json:"gte,omitempty"`
	Lt       *CouponStatus  `json:"lt,omitempty"`
	Lte      *CouponStatus  `json:"lte,omitempty"`
	Like     *CouponStatus  `json:"like,omitempty"`
	NotLike  *CouponStatus  `json:"notLike,omitempty"`
	ILike    *CouponStatus  `json:"iLike,omitempty"`
	NotILike *CouponStatus  `json:"notILike,omitempty"`
	In       []CouponStatus `json:"in,omitempty"`
	NotIn    []CouponStatus `json:"notIn,omitempty"`
}

type CouponSumAggregate struct {
	ID *float64 `json:"id"`
}

type CouponTypeFilterComparison struct {
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Eq       *CouponType  `json:"eq,omitempty"`
	Neq      *CouponType  `json:"neq,omitempty"`
	Gt       *CouponType  `json:"gt,omitempty"`
	Gte      *CouponType  `json:"gte,omitempty"`
	Lt       *CouponType  `json:"lt,omitempty"`
	Lte      *CouponType  `json:"lte,omitempty"`
	Like     *CouponType  `json:"like,omitempty"`
	NotLike  *CouponType  `json:"notLike,omitempty"`
	ILike    *CouponType  `json:"iLike,omitempty"`
	NotILike *CouponType  `json:"notILike,omitempty"`
	In       []CouponType `json:"in,omitempty"`
	NotIn    []CouponType `json:"notIn,omitempty"`
}

type CreateCouponInput struct {
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	RefID              string                 `json:"refId"`
	Description        *string                `json:"description,omitempty"`
	Name               string                 `json:"name"`
	Type               CouponType             `json:"type"`
	DiscountValue      float64                `json:"discountValue"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
}

type CreateEnvironment struct {
	ID              *string                     `json:"id,omitempty"`
	CreatedAt       *string                     `json:"createdAt,omitempty"`
	DisplayName     *string                     `json:"displayName,omitempty"`
	Description     *string                     `json:"description,omitempty"`
	Slug            *string                     `json:"slug,omitempty"`
	ProvisionStatus *EnvironmentProvisionStatus `json:"provisionStatus,omitempty"`
}

type CreateEnvironmentOptions struct {
	CreateDefaultProduct *bool `json:"createDefaultProduct,omitempty"`
}

type CreateExperimentInput struct {
	EnvironmentID     *string               `json:"environmentId,omitempty"`
	Description       *string               `json:"description,omitempty"`
	Name              string                `json:"name"`
	ProductID         string                `json:"productId"`
	VariantPercentage float64               `json:"variantPercentage"`
	ControlGroupName  string                `json:"controlGroupName"`
	VariantGroupName  string                `json:"variantGroupName"`
	ProductSettings   *ProductSettingsInput `json:"productSettings,omitempty"`
}

type CreateHook struct {
	ID            *string        `json:"id,omitempty"`
	Description   *string        `json:"description,omitempty"`
	SecretKey     *string        `json:"secretKey,omitempty"`
	Endpoint      *string        `json:"endpoint,omitempty"`
	Status        *HookStatus    `json:"status,omitempty"`
	CreatedAt     *string        `json:"createdAt,omitempty"`
	EnvironmentID *string        `json:"environmentId,omitempty"`
	EventLogTypes []EventLogType `json:"eventLogTypes,omitempty"`
}

type CreateIntegrationInput struct {
	EnvironmentID      string                   `json:"environmentId"`
	VendorIdentifier   VendorIdentifier         `json:"vendorIdentifier"`
	ZuoraCredentials   *ZuoraCredentialsInput   `json:"zuoraCredentials,omitempty"`
	StripeCredentials  *StripeCredentialsInput  `json:"stripeCredentials,omitempty"`
	HubspotCredentials *HubspotCredentialsInput `json:"hubspotCredentials,omitempty"`
}

type CreateManyPackageEntitlementsInput struct {
	// Array of records to create
	PackageEntitlements []*PackageEntitlementInput `json:"packageEntitlements"`
}

type CreateManyPromotionalEntitlementsInput struct {
	// Array of records to create
	PromotionalEntitlements []*PromotionalEntitlementInput `json:"promotionalEntitlements"`
}

type CreateOneEnvironmentInput struct {
	Environment CreateEnvironment         `json:"environment"`
	Options     *CreateEnvironmentOptions `json:"options,omitempty"`
}

type CreateOneFeatureInput struct {
	// The record to create
	Feature FeatureInput `json:"feature"`
}

type CreateOneHookInput struct {
	// The record to create
	Hook CreateHook `json:"hook"`
}

type CreateOneIntegrationInput struct {
	// The record to create
	Integration CreateIntegrationInput `json:"integration"`
}

type CreateOneProductInput struct {
	// The record to create
	Product ProductCreateInput `json:"product"`
}

type CursorPaging struct {
	// Paginate before opaque cursor
	Before *string `json:"before,omitempty"`
	// Paginate after opaque cursor
	After *string `json:"after,omitempty"`
	// Paginate first
	First *int64 `json:"first,omitempty"`
	// Paginate last
	Last *int64 `json:"last,omitempty"`
}

type Customer struct {
	ID                              string                    `json:"id"`
	Name                            *string                   `json:"name"`
	Email                           *string                   `json:"email"`
	RefID                           string                    `json:"refId"`
	CustomerID                      string                    `json:"customerId"`
	CreatedAt                       *string                   `json:"createdAt"`
	UpdatedAt                       string                    `json:"updatedAt"`
	EnvironmentID                   string                    `json:"environmentId"`
	BillingID                       *string                   `json:"billingId"`
	BillingLinkURL                  *string                   `json:"billingLinkUrl"`
	CrmID                           *string                   `json:"crmId"`
	CrmHubspotCompanyID             *string                   `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL            *string                   `json:"crmHubspotCompanyUrl"`
	HasPaymentMethod                bool                      `json:"hasPaymentMethod"`
	AdditionalMetaData              map[string]interface{}    `json:"additionalMetaData"`
	SyncStates                      []*SyncState              `json:"syncStates"`
	DefaultPaymentMethodID          *string                   `json:"defaultPaymentMethodId"`
	DefaultPaymentMethodType        *PaymentMethodType        `json:"defaultPaymentMethodType"`
	DefaultPaymentMethodLast4Digits *string                   `json:"defaultPaymentMethodLast4Digits"`
	DefaultPaymentExpirationMonth   *int64                    `json:"defaultPaymentExpirationMonth"`
	DefaultPaymentExpirationYear    *int64                    `json:"defaultPaymentExpirationYear"`
	TrialedPlans                    []*TrialedPlan            `json:"trialedPlans"`
	ExperimentInfo                  *ExperimentInfo           `json:"experimentInfo"`
	ExcludeFromExperiment           *bool                     `json:"excludeFromExperiment"`
	Environment                     *Environment              `json:"environment"`
	Coupon                          *Coupon                   `json:"coupon"`
	Experiment                      *Experiment               `json:"experiment"`
	Subscriptions                   []*CustomerSubscription   `json:"subscriptions"`
	PromotionalEntitlements         []*PromotionalEntitlement `json:"promotionalEntitlements"`
}

type CustomerAggregateGroupBy struct {
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	Email                *string `json:"email"`
	RefID                *string `json:"refId"`
	CustomerID           *string `json:"customerId"`
	CreatedAt            *string `json:"createdAt"`
	UpdatedAt            *string `json:"updatedAt"`
	EnvironmentID        *string `json:"environmentId"`
	BillingID            *string `json:"billingId"`
	CrmID                *string `json:"crmId"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
}

type CustomerBillingInfo struct {
	BillingAddress      *Address               `json:"billingAddress,omitempty"`
	ShippingAddress     *Address               `json:"shippingAddress,omitempty"`
	Currency            *Currency              `json:"currency,omitempty"`
	TaxIds              []*TaxExempt           `json:"taxIds,omitempty"`
	InvoiceCustomFields map[string]interface{} `json:"invoiceCustomFields,omitempty"`
	PaymentMethodID     *string                `json:"paymentMethodId,omitempty"`
	Timezone            *string                `json:"timezone,omitempty"`
	Language            *string                `json:"language,omitempty"`
}

type CustomerConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*CustomerEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerCountAggregate struct {
	ID                   *int64 `json:"id"`
	Name                 *int64 `json:"name"`
	Email                *int64 `json:"email"`
	RefID                *int64 `json:"refId"`
	CustomerID           *int64 `json:"customerId"`
	CreatedAt            *int64 `json:"createdAt"`
	UpdatedAt            *int64 `json:"updatedAt"`
	EnvironmentID        *int64 `json:"environmentId"`
	BillingID            *int64 `json:"billingId"`
	CrmID                *int64 `json:"crmId"`
	CrmHubspotCompanyID  *int64 `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *int64 `json:"crmHubspotCompanyUrl"`
}

type CustomerEdge struct {
	// The node containing the Customer
	Node Customer `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type CustomerFilter struct {
	And                     []*CustomerFilter                           `json:"and,omitempty"`
	Or                      []*CustomerFilter                           `json:"or,omitempty"`
	ID                      *StringFieldComparison                      `json:"id,omitempty"`
	Name                    *StringFieldComparison                      `json:"name,omitempty"`
	Email                   *StringFieldComparison                      `json:"email,omitempty"`
	RefID                   *StringFieldComparison                      `json:"refId,omitempty"`
	CustomerID              *StringFieldComparison                      `json:"customerId,omitempty"`
	CreatedAt               *DateFieldComparison                        `json:"createdAt,omitempty"`
	UpdatedAt               *DateFieldComparison                        `json:"updatedAt,omitempty"`
	EnvironmentID           *StringFieldComparison                      `json:"environmentId,omitempty"`
	BillingID               *StringFieldComparison                      `json:"billingId,omitempty"`
	CrmID                   *StringFieldComparison                      `json:"crmId,omitempty"`
	CrmHubspotCompanyID     *StringFieldComparison                      `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL    *StringFieldComparison                      `json:"crmHubspotCompanyUrl,omitempty"`
	PromotionalEntitlements *CustomerFilterPromotionalEntitlementFilter `json:"promotionalEntitlements,omitempty"`
	Subscriptions           *CustomerFilterCustomerSubscriptionFilter   `json:"subscriptions,omitempty"`
}

type CustomerFilterCustomerSubscriptionFilter struct {
	And              []*CustomerFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	Or               []*CustomerFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	EnvironmentID    *StringFieldComparison                      `json:"environmentId,omitempty"`
	ID               *StringFieldComparison                      `json:"id,omitempty"`
	CreatedAt        *DateFieldComparison                        `json:"createdAt,omitempty"`
	StartDate        *DateFieldComparison                        `json:"startDate,omitempty"`
	EndDate          *DateFieldComparison                        `json:"endDate,omitempty"`
	CancellationDate *DateFieldComparison                        `json:"cancellationDate,omitempty"`
	TrialEndDate     *DateFieldComparison                        `json:"trialEndDate,omitempty"`
	EffectiveEndDate *DateFieldComparison                        `json:"effectiveEndDate,omitempty"`
	BillingID        *StringFieldComparison                      `json:"billingId,omitempty"`
	CrmID            *StringFieldComparison                      `json:"crmId,omitempty"`
	CrmLinkURL       *StringFieldComparison                      `json:"crmLinkUrl,omitempty"`
	Status           *SubscriptionStatusFilterComparison         `json:"status,omitempty"`
	CancelReason     *SubscriptionCancelReasonFilterComparison   `json:"cancelReason,omitempty"`
	RefID            *StringFieldComparison                      `json:"refId,omitempty"`
	SubscriptionID   *StringFieldComparison                      `json:"subscriptionId,omitempty"`
	PricingType      *PricingTypeFilterComparison                `json:"pricingType,omitempty"`
}

type CustomerFilterPromotionalEntitlementFilter struct {
	And           []*CustomerFilterPromotionalEntitlementFilter `json:"and,omitempty"`
	Or            []*CustomerFilterPromotionalEntitlementFilter `json:"or,omitempty"`
	ID            *StringFieldComparison                        `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
	Status        *PromotionalEntitlementStatusFilterComparison `json:"status,omitempty"`
	EnvironmentID *StringFieldComparison                        `json:"environmentId,omitempty"`
}

type CustomerInput struct {
	Name               *string                `json:"name,omitempty"`
	Email              *string                `json:"email,omitempty"`
	RefID              *string                `json:"refId,omitempty"`
	CustomerID         *string                `json:"customerId,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	CrmID              *string                `json:"crmId,omitempty"`
	CouponRefID        *string                `json:"couponRefId,omitempty"`
	BillingInformation *CustomerBillingInfo   `json:"billingInformation,omitempty"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	ShouldSyncFree     *bool                  `json:"shouldSyncFree,omitempty"`
	CreatedAt          *string                `json:"createdAt,omitempty"`
}

type CustomerMaxAggregate struct {
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	Email                *string `json:"email"`
	RefID                *string `json:"refId"`
	CustomerID           *string `json:"customerId"`
	CreatedAt            *string `json:"createdAt"`
	UpdatedAt            *string `json:"updatedAt"`
	EnvironmentID        *string `json:"environmentId"`
	BillingID            *string `json:"billingId"`
	CrmID                *string `json:"crmId"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
}

type CustomerMinAggregate struct {
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	Email                *string `json:"email"`
	RefID                *string `json:"refId"`
	CustomerID           *string `json:"customerId"`
	CreatedAt            *string `json:"createdAt"`
	UpdatedAt            *string `json:"updatedAt"`
	EnvironmentID        *string `json:"environmentId"`
	BillingID            *string `json:"billingId"`
	CrmID                *string `json:"crmId"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
}

type CustomerNoBillingID struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CustomerNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CustomerPortal struct {
	Subscriptions           []*CustomerPortalSubscription           `json:"subscriptions"`
	Entitlements            []*Entitlement                          `json:"entitlements"`
	PromotionalEntitlements []*CustomerPortalPromotionalEntitlement `json:"promotionalEntitlements"`
	BillingInformation      CustomerPortalBillingInformation        `json:"billingInformation"`
	ShowWatermark           bool                                    `json:"showWatermark"`
	CanUpgradeSubscription  bool                                    `json:"canUpgradeSubscription"`
	BillingPortalURL        *string                                 `json:"billingPortalUrl"`
	Configuration           *CustomerPortalConfiguration            `json:"configuration"`
}

type CustomerPortalAddon struct {
	AddonID     string  `json:"addonId"`
	DisplayName string  `json:"displayName"`
	Description *string `json:"description"`
	Quantity    int64   `json:"quantity"`
}

type CustomerPortalBillingInformation struct {
	Name                            *string            `json:"name"`
	Email                           *string            `json:"email"`
	DefaultPaymentMethodID          *string            `json:"defaultPaymentMethodId"`
	DefaultPaymentMethodType        *PaymentMethodType `json:"defaultPaymentMethodType"`
	DefaultPaymentMethodLast4Digits *string            `json:"defaultPaymentMethodLast4Digits"`
	DefaultPaymentExpirationMonth   *int64             `json:"defaultPaymentExpirationMonth"`
	DefaultPaymentExpirationYear    *int64             `json:"defaultPaymentExpirationYear"`
}

type CustomerPortalColorsPalette struct {
	Primary                *string `json:"primary"`
	TextColor              *string `json:"textColor"`
	BackgroundColor        *string `json:"backgroundColor"`
	PaywallBackgroundColor *string `json:"paywallBackgroundColor"`
	BorderColor            *string `json:"borderColor"`
	CurrentPlanBackground  *string `json:"currentPlanBackground"`
	IconsColor             *string `json:"iconsColor"`
}

type CustomerPortalColorsPaletteInput struct {
	Primary                *string `json:"primary,omitempty"`
	TextColor              *string `json:"textColor,omitempty"`
	BackgroundColor        *string `json:"backgroundColor,omitempty"`
	BorderColor            *string `json:"borderColor,omitempty"`
	CurrentPlanBackground  *string `json:"currentPlanBackground,omitempty"`
	IconsColor             *string `json:"iconsColor,omitempty"`
	PaywallBackgroundColor *string `json:"paywallBackgroundColor,omitempty"`
}

type CustomerPortalConfiguration struct {
	Palette    *CustomerPortalColorsPalette `json:"palette"`
	Typography *TypographyConfiguration     `json:"typography"`
}

type CustomerPortalConfigurationInput struct {
	Palette    *CustomerPortalColorsPaletteInput `json:"palette,omitempty"`
	Typography *TypographyConfigurationInput     `json:"typography,omitempty"`
}

type CustomerPortalInput struct {
	CustomerID string `json:"customerId"`
}

type CustomerPortalPricingFeature struct {
	DisplayName        string      `json:"displayName"`
	FeatureUnits       *string     `json:"featureUnits"`
	FeatureUnitsPlural *string     `json:"featureUnitsPlural"`
	Description        *string     `json:"description"`
	FeatureType        FeatureType `json:"featureType"`
	MeterType          *MeterType  `json:"meterType"`
}

type CustomerPortalPromotionalEntitlement struct {
	DisplayName       string                       `json:"displayName"`
	Description       *string                      `json:"description"`
	UsageLimit        *float64                     `json:"usageLimit"`
	HasUnlimitedUsage *bool                        `json:"hasUnlimitedUsage"`
	StartDate         string                       `json:"startDate"`
	EndDate           *string                      `json:"endDate"`
	Period            PromotionalEntitlementPeriod `json:"period"`
}

type CustomerPortalSubscription struct {
	SubscriptionID     string                            `json:"subscriptionId"`
	PlanName           string                            `json:"planName"`
	Pricing            CustomerPortalSubscriptionPricing `json:"pricing"`
	Status             SubscriptionStatus                `json:"status"`
	TotalPrice         *CustomerSubscriptionTotalPrice   `json:"totalPrice"`
	BillingPeriodRange *DateRange                        `json:"billingPeriodRange"`
	TrialRemainingDays *int64                            `json:"trialRemainingDays"`
	Addons             []*CustomerPortalAddon            `json:"addons"`
}

type CustomerPortalSubscriptionPricing struct {
	PricingType             PricingType                   `json:"pricingType"`
	UnitQuantity            *int64                        `json:"unitQuantity"`
	BillingPeriod           *BillingPeriod                `json:"billingPeriod"`
	BillingModel            *BillingModel                 `json:"billingModel"`
	Price                   *Money                        `json:"price"`
	Feature                 *CustomerPortalPricingFeature `json:"feature"`
	UsageBasedEstimatedBill *float64                      `json:"usageBasedEstimatedBill"`
}

type CustomerSort struct {
	Field     CustomerSortFields `json:"field"`
	Direction SortDirection      `json:"direction"`
	Nulls     *SortNulls         `json:"nulls,omitempty"`
}

type CustomerSubscription struct {
	EnvironmentID             string                          `json:"environmentId"`
	ID                        string                          `json:"id"`
	CreatedAt                 *string                         `json:"createdAt"`
	StartDate                 string                          `json:"startDate"`
	EndDate                   *string                         `json:"endDate"`
	CancellationDate          *string                         `json:"cancellationDate"`
	TrialEndDate              *string                         `json:"trialEndDate"`
	EffectiveEndDate          *string                         `json:"effectiveEndDate"`
	BillingID                 *string                         `json:"billingId"`
	BillingLinkURL            *string                         `json:"billingLinkUrl"`
	CrmID                     *string                         `json:"crmId"`
	CrmLinkURL                *string                         `json:"crmLinkUrl"`
	Status                    SubscriptionStatus              `json:"status"`
	CancelReason              *SubscriptionCancelReason       `json:"cancelReason"`
	RefID                     string                          `json:"refId"`
	SubscriptionID            string                          `json:"subscriptionId"`
	WasInTrial                *bool                           `json:"wasInTrial"`
	IsCustomPriceSubscription *bool                           `json:"isCustomPriceSubscription"`
	Addons                    []*SubscriptionAddon            `json:"addons"`
	CurrentBillingPeriodEnd   *string                         `json:"currentBillingPeriodEnd"`
	PricingType               PricingType                     `json:"pricingType"`
	AdditionalMetaData        map[string]interface{}          `json:"additionalMetaData"`
	SyncStates                []*SyncState                    `json:"syncStates"`
	TotalPrice                *CustomerSubscriptionTotalPrice `json:"totalPrice"`
	ExperimentInfo            *ExperimentInfo                 `json:"experimentInfo"`
	Coupon                    *SubscriptionCoupon             `json:"coupon"`
	Customer                  Customer                        `json:"customer"`
	Plan                      Plan                            `json:"plan"`
	Environment               Environment                     `json:"environment"`
	Experiment                *Experiment                     `json:"experiment"`
	Prices                    []*SubscriptionPrice            `json:"prices"`
}

type CustomerSubscriptionAggregateGroupBy struct {
	EnvironmentID    *string                   `json:"environmentId"`
	ID               *string                   `json:"id"`
	CreatedAt        *string                   `json:"createdAt"`
	StartDate        *string                   `json:"startDate"`
	EndDate          *string                   `json:"endDate"`
	CancellationDate *string                   `json:"cancellationDate"`
	TrialEndDate     *string                   `json:"trialEndDate"`
	EffectiveEndDate *string                   `json:"effectiveEndDate"`
	BillingID        *string                   `json:"billingId"`
	CrmID            *string                   `json:"crmId"`
	CrmLinkURL       *string                   `json:"crmLinkUrl"`
	Status           *SubscriptionStatus       `json:"status"`
	CancelReason     *SubscriptionCancelReason `json:"cancelReason"`
	RefID            *string                   `json:"refId"`
	SubscriptionID   *string                   `json:"subscriptionId"`
	PricingType      *PricingType              `json:"pricingType"`
}

type CustomerSubscriptionConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*CustomerSubscriptionEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerSubscriptionCountAggregate struct {
	EnvironmentID    *int64 `json:"environmentId"`
	ID               *int64 `json:"id"`
	CreatedAt        *int64 `json:"createdAt"`
	StartDate        *int64 `json:"startDate"`
	EndDate          *int64 `json:"endDate"`
	CancellationDate *int64 `json:"cancellationDate"`
	TrialEndDate     *int64 `json:"trialEndDate"`
	EffectiveEndDate *int64 `json:"effectiveEndDate"`
	BillingID        *int64 `json:"billingId"`
	CrmID            *int64 `json:"crmId"`
	CrmLinkURL       *int64 `json:"crmLinkUrl"`
	Status           *int64 `json:"status"`
	CancelReason     *int64 `json:"cancelReason"`
	RefID            *int64 `json:"refId"`
	SubscriptionID   *int64 `json:"subscriptionId"`
	PricingType      *int64 `json:"pricingType"`
}

type CustomerSubscriptionEdge struct {
	// The node containing the CustomerSubscription
	Node CustomerSubscription `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type CustomerSubscriptionFilter struct {
	And              []*CustomerSubscriptionFilter                      `json:"and,omitempty"`
	Or               []*CustomerSubscriptionFilter                      `json:"or,omitempty"`
	EnvironmentID    *StringFieldComparison                             `json:"environmentId,omitempty"`
	ID               *StringFieldComparison                             `json:"id,omitempty"`
	CreatedAt        *DateFieldComparison                               `json:"createdAt,omitempty"`
	StartDate        *DateFieldComparison                               `json:"startDate,omitempty"`
	EndDate          *DateFieldComparison                               `json:"endDate,omitempty"`
	CancellationDate *DateFieldComparison                               `json:"cancellationDate,omitempty"`
	TrialEndDate     *DateFieldComparison                               `json:"trialEndDate,omitempty"`
	EffectiveEndDate *DateFieldComparison                               `json:"effectiveEndDate,omitempty"`
	BillingID        *StringFieldComparison                             `json:"billingId,omitempty"`
	CrmID            *StringFieldComparison                             `json:"crmId,omitempty"`
	CrmLinkURL       *StringFieldComparison                             `json:"crmLinkUrl,omitempty"`
	Status           *SubscriptionStatusFilterComparison                `json:"status,omitempty"`
	CancelReason     *SubscriptionCancelReasonFilterComparison          `json:"cancelReason,omitempty"`
	RefID            *StringFieldComparison                             `json:"refId,omitempty"`
	SubscriptionID   *StringFieldComparison                             `json:"subscriptionId,omitempty"`
	PricingType      *PricingTypeFilterComparison                       `json:"pricingType,omitempty"`
	Customer         *CustomerSubscriptionFilterCustomerFilter          `json:"customer,omitempty"`
	Prices           *CustomerSubscriptionFilterSubscriptionPriceFilter `json:"prices,omitempty"`
	Addons           *CustomerSubscriptionFilterSubscriptionAddonFilter `json:"addons,omitempty"`
}

type CustomerSubscriptionFilterCustomerFilter struct {
	And                  []*CustomerSubscriptionFilterCustomerFilter `json:"and,omitempty"`
	Or                   []*CustomerSubscriptionFilterCustomerFilter `json:"or,omitempty"`
	ID                   *StringFieldComparison                      `json:"id,omitempty"`
	Name                 *StringFieldComparison                      `json:"name,omitempty"`
	Email                *StringFieldComparison                      `json:"email,omitempty"`
	RefID                *StringFieldComparison                      `json:"refId,omitempty"`
	CustomerID           *StringFieldComparison                      `json:"customerId,omitempty"`
	CreatedAt            *DateFieldComparison                        `json:"createdAt,omitempty"`
	UpdatedAt            *DateFieldComparison                        `json:"updatedAt,omitempty"`
	EnvironmentID        *StringFieldComparison                      `json:"environmentId,omitempty"`
	BillingID            *StringFieldComparison                      `json:"billingId,omitempty"`
	CrmID                *StringFieldComparison                      `json:"crmId,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                      `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                      `json:"crmHubspotCompanyUrl,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionAddonFilter struct {
	And       []*CustomerSubscriptionFilterSubscriptionAddonFilter `json:"and,omitempty"`
	Or        []*CustomerSubscriptionFilterSubscriptionAddonFilter `json:"or,omitempty"`
	ID        *StringFieldComparison                               `json:"id,omitempty"`
	Quantity  *NumberFieldComparison                               `json:"quantity,omitempty"`
	UpdatedAt *DateFieldComparison                                 `json:"updatedAt,omitempty"`
	CreatedAt *DateFieldComparison                                 `json:"createdAt,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionPriceFilter struct {
	And        []*CustomerSubscriptionFilterSubscriptionPriceFilter `json:"and,omitempty"`
	Or         []*CustomerSubscriptionFilterSubscriptionPriceFilter `json:"or,omitempty"`
	ID         *StringFieldComparison                               `json:"id,omitempty"`
	CreatedAt  *DateFieldComparison                                 `json:"createdAt,omitempty"`
	UpdatedAt  *DateFieldComparison                                 `json:"updatedAt,omitempty"`
	UsageLimit *NumberFieldComparison                               `json:"usageLimit,omitempty"`
}

type CustomerSubscriptionMaxAggregate struct {
	EnvironmentID    *string                   `json:"environmentId"`
	ID               *string                   `json:"id"`
	CreatedAt        *string                   `json:"createdAt"`
	StartDate        *string                   `json:"startDate"`
	EndDate          *string                   `json:"endDate"`
	CancellationDate *string                   `json:"cancellationDate"`
	TrialEndDate     *string                   `json:"trialEndDate"`
	EffectiveEndDate *string                   `json:"effectiveEndDate"`
	BillingID        *string                   `json:"billingId"`
	CrmID            *string                   `json:"crmId"`
	CrmLinkURL       *string                   `json:"crmLinkUrl"`
	Status           *SubscriptionStatus       `json:"status"`
	CancelReason     *SubscriptionCancelReason `json:"cancelReason"`
	RefID            *string                   `json:"refId"`
	SubscriptionID   *string                   `json:"subscriptionId"`
	PricingType      *PricingType              `json:"pricingType"`
}

type CustomerSubscriptionMinAggregate struct {
	EnvironmentID    *string                   `json:"environmentId"`
	ID               *string                   `json:"id"`
	CreatedAt        *string                   `json:"createdAt"`
	StartDate        *string                   `json:"startDate"`
	EndDate          *string                   `json:"endDate"`
	CancellationDate *string                   `json:"cancellationDate"`
	TrialEndDate     *string                   `json:"trialEndDate"`
	EffectiveEndDate *string                   `json:"effectiveEndDate"`
	BillingID        *string                   `json:"billingId"`
	CrmID            *string                   `json:"crmId"`
	CrmLinkURL       *string                   `json:"crmLinkUrl"`
	Status           *SubscriptionStatus       `json:"status"`
	CancelReason     *SubscriptionCancelReason `json:"cancelReason"`
	RefID            *string                   `json:"refId"`
	SubscriptionID   *string                   `json:"subscriptionId"`
	PricingType      *PricingType              `json:"pricingType"`
}

type CustomerSubscriptionSort struct {
	Field     CustomerSubscriptionSortFields `json:"field"`
	Direction SortDirection                  `json:"direction"`
	Nulls     *SortNulls                     `json:"nulls,omitempty"`
}

type CustomerSubscriptionTotalPrice struct {
	SubTotal    Money `json:"subTotal"`
	Total       Money `json:"total"`
	AddonsTotal Money `json:"addonsTotal"`
}

type DateFieldComparison struct {
	Is         *bool                       `json:"is,omitempty"`
	IsNot      *bool                       `json:"isNot,omitempty"`
	Eq         *string                     `json:"eq,omitempty"`
	Neq        *string                     `json:"neq,omitempty"`
	Gt         *string                     `json:"gt,omitempty"`
	Gte        *string                     `json:"gte,omitempty"`
	Lt         *string                     `json:"lt,omitempty"`
	Lte        *string                     `json:"lte,omitempty"`
	In         []string                    `json:"in,omitempty"`
	NotIn      []string                    `json:"notIn,omitempty"`
	Between    *DateFieldComparisonBetween `json:"between,omitempty"`
	NotBetween *DateFieldComparisonBetween `json:"notBetween,omitempty"`
}

type DateFieldComparisonBetween struct {
	Lower string `json:"lower"`
	Upper string `json:"upper"`
}

type DateRange struct {
	Start *string `json:"start"`
	End   *string `json:"end"`
}

type DefaultTrialConfig struct {
	Units    TrialPeriodUnits `json:"units"`
	Duration float64          `json:"duration"`
}

type DefaultTrialConfigChange struct {
	Before     *DefaultTrialConfig `json:"before"`
	After      *DefaultTrialConfig `json:"after"`
	ChangeType *ChangeType         `json:"changeType"`
}

type DefaultTrialConfigInputDto struct {
	Units    *TrialPeriodUnits `json:"units,omitempty"`
	Duration *float64          `json:"duration,omitempty"`
}

type DeleteCustomerInput struct {
	ID            string  `json:"id"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type DeleteFeatureInput struct {
	ID            string  `json:"id"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type DeleteOneAddonInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneEnvironmentInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneHookInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneIntegrationInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePackageEntitlementInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePriceInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneProductInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePromotionalEntitlementInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DiscardPackageDraftInput struct {
	RefID         string `json:"refId"`
	EnvironmentID string `json:"environmentId"`
}

type DuplicatedEntityNotAllowedError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	Identifier        string `json:"identifier"`
	EntityName        string `json:"entityName"`
}

type EditAllowedOnDraftPackageOnlyError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type Entitlement struct {
	IsGranted                bool                     `json:"isGranted"`
	CustomerID               *string                  `json:"customerId"`
	AccessDeniedReason       *AccessDeniedReason      `json:"accessDeniedReason"`
	CurrentUsage             *float64                 `json:"currentUsage"`
	RequestedUsage           *float64                 `json:"requestedUsage"`
	UsageLimit               *float64                 `json:"usageLimit"`
	HasUnlimitedUsage        bool                     `json:"hasUnlimitedUsage"`
	NextResetDate            *string                  `json:"nextResetDate"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	Feature                  *EntitlementFeature      `json:"feature"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
}

type EntitlementCheckRequested struct {
	CustomerID             string                 `json:"customerId"`
	FeatureID              string                 `json:"featureId"`
	EnvironmentID          *string                `json:"environmentId,omitempty"`
	RequestedUsage         *float64               `json:"requestedUsage,omitempty"`
	EntitlementCheckResult EntitlementCheckResult `json:"entitlementCheckResult"`
}

type EntitlementCheckResult struct {
	HasAccess                       bool                           `json:"hasAccess"`
	AccessDeniedReason              *AccessDeniedReason            `json:"accessDeniedReason,omitempty"`
	CurrentUsage                    *float64                       `json:"currentUsage,omitempty"`
	RequestedUsage                  *float64                       `json:"requestedUsage,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	NextResetDate                   *string                        `json:"nextResetDate,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
}

type EntitlementFeature struct {
	ID                 string        `json:"id"`
	DisplayName        string        `json:"displayName"`
	RefID              string        `json:"refId"`
	FeatureUnits       *string       `json:"featureUnits"`
	FeatureUnitsPlural *string       `json:"featureUnitsPlural"`
	Description        *string       `json:"description"`
	FeatureType        FeatureType   `json:"featureType"`
	MeterType          *MeterType    `json:"meterType"`
	FeatureStatus      FeatureStatus `json:"featureStatus"`
}

type EntitlementOptions struct {
	ShouldTrack    *bool    `json:"shouldTrack,omitempty"`
	RequestedUsage *float64 `json:"requestedUsage,omitempty"`
}

type EntitlementSummary struct {
	FeaturePackageEntitlement     *PackageEntitlement     `json:"featurePackageEntitlement"`
	FeaturePromotionalEntitlement *PromotionalEntitlement `json:"featurePromotionalEntitlement"`
	PriceEntitlement              *PriceEntitlement       `json:"priceEntitlement"`
	AddonQuantity                 *float64                `json:"addonQuantity"`
	Plan                          *Plan                   `json:"plan"`
	Subscription                  *CustomerSubscription   `json:"subscription"`
	IsEffectiveEntitlement        bool                    `json:"isEffectiveEntitlement"`
}

type EntitlementWithSummary struct {
	IsGranted                bool                     `json:"isGranted"`
	CustomerID               *string                  `json:"customerId"`
	AccessDeniedReason       *AccessDeniedReason      `json:"accessDeniedReason"`
	CurrentUsage             *float64                 `json:"currentUsage"`
	RequestedUsage           *float64                 `json:"requestedUsage"`
	UsageLimit               *float64                 `json:"usageLimit"`
	HasUnlimitedUsage        bool                     `json:"hasUnlimitedUsage"`
	NextResetDate            *string                  `json:"nextResetDate"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	Feature                  *EntitlementFeature      `json:"feature"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
	Summaries                []*EntitlementSummary    `json:"summaries"`
}

type EntitlementsUpdated struct {
	Entitlements  []*Entitlement `json:"entitlements"`
	CustomerID    string         `json:"customerId"`
	AccountID     string         `json:"accountId"`
	EnvironmentID string         `json:"environmentId"`
}

type Environment struct {
	ID              string                      `json:"id"`
	CreatedAt       *string                     `json:"createdAt"`
	DisplayName     string                      `json:"displayName"`
	Description     *string                     `json:"description"`
	Slug            string                      `json:"slug"`
	ProvisionStatus *EnvironmentProvisionStatus `json:"provisionStatus"`
	Account         *Account                    `json:"account"`
	APIKeys         []*APIKey                   `json:"apiKeys"`
}

type EnvironmentAggregateGroupBy struct {
	ID          *string `json:"id"`
	CreatedAt   *string `json:"createdAt"`
	DisplayName *string `json:"displayName"`
	Slug        *string `json:"slug"`
}

type EnvironmentConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*EnvironmentEdge `json:"edges"`
}

type EnvironmentCountAggregate struct {
	ID          *int64 `json:"id"`
	CreatedAt   *int64 `json:"createdAt"`
	DisplayName *int64 `json:"displayName"`
	Slug        *int64 `json:"slug"`
}

type EnvironmentDeleteResponse struct {
	ID              *string                     `json:"id"`
	CreatedAt       *string                     `json:"createdAt"`
	DisplayName     *string                     `json:"displayName"`
	Description     *string                     `json:"description"`
	Slug            *string                     `json:"slug"`
	ProvisionStatus *EnvironmentProvisionStatus `json:"provisionStatus"`
}

type EnvironmentEdge struct {
	// The node containing the Environment
	Node Environment `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type EnvironmentFilter struct {
	And         []*EnvironmentFilter   `json:"and,omitempty"`
	Or          []*EnvironmentFilter   `json:"or,omitempty"`
	ID          *StringFieldComparison `json:"id,omitempty"`
	CreatedAt   *DateFieldComparison   `json:"createdAt,omitempty"`
	DisplayName *StringFieldComparison `json:"displayName,omitempty"`
	Slug        *StringFieldComparison `json:"slug,omitempty"`
}

type EnvironmentMaxAggregate struct {
	ID          *string `json:"id"`
	CreatedAt   *string `json:"createdAt"`
	DisplayName *string `json:"displayName"`
	Slug        *string `json:"slug"`
}

type EnvironmentMinAggregate struct {
	ID          *string `json:"id"`
	CreatedAt   *string `json:"createdAt"`
	DisplayName *string `json:"displayName"`
	Slug        *string `json:"slug"`
}

type EnvironmentMissingError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type EnvironmentSort struct {
	Field     EnvironmentSortFields `json:"field"`
	Direction SortDirection         `json:"direction"`
	Nulls     *SortNulls            `json:"nulls,omitempty"`
}

type EstimateSubscriptionInput struct {
	EnvironmentID      *string                   `json:"environmentId,omitempty"`
	CustomerID         string                    `json:"customerId"`
	PlanID             string                    `json:"planId"`
	BillingPeriod      *BillingPeriod            `json:"billingPeriod,omitempty"`
	PriceUnitAmount    *float64                  `json:"priceUnitAmount,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	StartDate          *string                   `json:"startDate,omitempty"`
	BillingInformation *SubscriptionBillingInfo  `json:"billingInformation,omitempty"`
}

type EstimateSubscriptionUpdateInput struct {
	EnvironmentID  *string                   `json:"environmentId,omitempty"`
	SubscriptionID string                    `json:"subscriptionId"`
	UnitQuantity   *float64                  `json:"unitQuantity,omitempty"`
	Addons         []*SubscriptionAddonInput `json:"addons,omitempty"`
}

type EventLog struct {
	ID               string       `json:"id"`
	Description      *string      `json:"description"`
	WebhookEndpoints []string     `json:"webhookEndpoints"`
	EnvironmentID    string       `json:"environmentId"`
	EventLogType     EventLogType `json:"eventLogType"`
	Environment      *Environment `json:"environment"`
}

type EventLogAggregateGroupBy struct {
	ID            *string `json:"id"`
	EnvironmentID *string `json:"environmentId"`
}

type EventLogCountAggregate struct {
	ID            *int64 `json:"id"`
	EnvironmentID *int64 `json:"environmentId"`
}

type EventLogEdge struct {
	// The node containing the EventLog
	Node EventLog `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type EventLogMaxAggregate struct {
	ID            *string `json:"id"`
	EnvironmentID *string `json:"environmentId"`
}

type EventLogMinAggregate struct {
	ID            *string `json:"id"`
	EnvironmentID *string `json:"environmentId"`
}

type Experiment struct {
	ID                     string           `json:"id"`
	Name                   string           `json:"name"`
	RefID                  string           `json:"refId"`
	Description            *string          `json:"description"`
	CreatedAt              string           `json:"createdAt"`
	UpdatedAt              string           `json:"updatedAt"`
	StartedAt              *string          `json:"startedAt"`
	StoppedAt              *string          `json:"stoppedAt"`
	EnvironmentID          string           `json:"environmentId"`
	ProductID              string           `json:"productId"`
	Status                 ExperimentStatus `json:"status"`
	VariantPercentage      float64          `json:"variantPercentage"`
	ControlGroupName       string           `json:"controlGroupName"`
	VariantGroupName       string           `json:"variantGroupName"`
	ProductSettings        ProductSettings  `json:"productSettings"`
	InitialProductSettings *ProductSettings `json:"initialProductSettings"`
	Customers              *Customer        `json:"customers"`
	Product                *Product         `json:"product"`
	Environment            *Environment     `json:"environment"`
}

type ExperimentAggregateGroupBy struct {
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	RefID         *string           `json:"refId"`
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ProductID     *string           `json:"productId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentAvgAggregate struct {
	ID *float64 `json:"id"`
}

type ExperimentConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*ExperimentEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type ExperimentCountAggregate struct {
	ID            *int64 `json:"id"`
	Name          *int64 `json:"name"`
	RefID         *int64 `json:"refId"`
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ProductID     *int64 `json:"productId"`
	Status        *int64 `json:"status"`
}

type ExperimentEdge struct {
	// The node containing the Experiment
	Node Experiment `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type ExperimentFilter struct {
	And           []*ExperimentFilter               `json:"and,omitempty"`
	Or            []*ExperimentFilter               `json:"or,omitempty"`
	ID            *StringFieldComparison            `json:"id,omitempty"`
	Name          *StringFieldComparison            `json:"name,omitempty"`
	RefID         *StringFieldComparison            `json:"refId,omitempty"`
	CreatedAt     *DateFieldComparison              `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison            `json:"environmentId,omitempty"`
	ProductID     *StringFieldComparison            `json:"productId,omitempty"`
	Status        *ExperimentStatusFilterComparison `json:"status,omitempty"`
	Customers     *ExperimentFilterCustomerFilter   `json:"customers,omitempty"`
}

type ExperimentFilterCustomerFilter struct {
	And                  []*ExperimentFilterCustomerFilter `json:"and,omitempty"`
	Or                   []*ExperimentFilterCustomerFilter `json:"or,omitempty"`
	ID                   *StringFieldComparison            `json:"id,omitempty"`
	Name                 *StringFieldComparison            `json:"name,omitempty"`
	Email                *StringFieldComparison            `json:"email,omitempty"`
	RefID                *StringFieldComparison            `json:"refId,omitempty"`
	CustomerID           *StringFieldComparison            `json:"customerId,omitempty"`
	CreatedAt            *DateFieldComparison              `json:"createdAt,omitempty"`
	UpdatedAt            *DateFieldComparison              `json:"updatedAt,omitempty"`
	EnvironmentID        *StringFieldComparison            `json:"environmentId,omitempty"`
	BillingID            *StringFieldComparison            `json:"billingId,omitempty"`
	CrmID                *StringFieldComparison            `json:"crmId,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison            `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison            `json:"crmHubspotCompanyUrl,omitempty"`
}

type ExperimentMaxAggregate struct {
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	RefID         *string           `json:"refId"`
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ProductID     *string           `json:"productId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentMinAggregate struct {
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	RefID         *string           `json:"refId"`
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ProductID     *string           `json:"productId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentSort struct {
	Field     ExperimentSortFields `json:"field"`
	Direction SortDirection        `json:"direction"`
	Nulls     *SortNulls           `json:"nulls,omitempty"`
}

type ExperimentStats struct {
	ControlSubscriptions     float64 `json:"controlSubscriptions"`
	ControlPaidSubscriptions float64 `json:"controlPaidSubscriptions"`
	VariantSubscriptions     float64 `json:"variantSubscriptions"`
	VariantPaidSubscriptions float64 `json:"variantPaidSubscriptions"`
}

type ExperimentStatsQuery struct {
	ExperimentRefID string  `json:"experimentRefId"`
	EnvironmentID   *string `json:"environmentId,omitempty"`
}

type ExperimentStatusFilterComparison struct {
	Is       *bool              `json:"is,omitempty"`
	IsNot    *bool              `json:"isNot,omitempty"`
	Eq       *ExperimentStatus  `json:"eq,omitempty"`
	Neq      *ExperimentStatus  `json:"neq,omitempty"`
	Gt       *ExperimentStatus  `json:"gt,omitempty"`
	Gte      *ExperimentStatus  `json:"gte,omitempty"`
	Lt       *ExperimentStatus  `json:"lt,omitempty"`
	Lte      *ExperimentStatus  `json:"lte,omitempty"`
	Like     *ExperimentStatus  `json:"like,omitempty"`
	NotLike  *ExperimentStatus  `json:"notLike,omitempty"`
	ILike    *ExperimentStatus  `json:"iLike,omitempty"`
	NotILike *ExperimentStatus  `json:"notILike,omitempty"`
	In       []ExperimentStatus `json:"in,omitempty"`
	NotIn    []ExperimentStatus `json:"notIn,omitempty"`
}

type ExperimentSumAggregate struct {
	ID *float64 `json:"id"`
}

type FailedToImportCustomerError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	BillingID         string `json:"billingId"`
}

type Feature struct {
	ID                 string        `json:"id"`
	DisplayName        string        `json:"displayName"`
	RefID              string        `json:"refId"`
	CreatedAt          *string       `json:"createdAt"`
	UpdatedAt          string        `json:"updatedAt"`
	FeatureUnits       *string       `json:"featureUnits"`
	FeatureUnitsPlural *string       `json:"featureUnitsPlural"`
	Description        *string       `json:"description"`
	FeatureType        FeatureType   `json:"featureType"`
	MeterType          *MeterType    `json:"meterType"`
	FeatureStatus      FeatureStatus `json:"featureStatus"`
	EnvironmentID      string        `json:"environmentId"`
	Account            *Account      `json:"account"`
	Environment        *Environment  `json:"environment"`
}

type FeatureAggregateGroupBy struct {
	ID            *string        `json:"id"`
	DisplayName   *string        `json:"displayName"`
	RefID         *string        `json:"refId"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	Description   *string        `json:"description"`
	FeatureType   *FeatureType   `json:"featureType"`
	MeterType     *MeterType     `json:"meterType"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	EnvironmentID *string        `json:"environmentId"`
}

type FeatureConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*FeatureEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type FeatureCountAggregate struct {
	ID            *int64 `json:"id"`
	DisplayName   *int64 `json:"displayName"`
	RefID         *int64 `json:"refId"`
	CreatedAt     *int64 `json:"createdAt"`
	UpdatedAt     *int64 `json:"updatedAt"`
	Description   *int64 `json:"description"`
	FeatureType   *int64 `json:"featureType"`
	MeterType     *int64 `json:"meterType"`
	FeatureStatus *int64 `json:"featureStatus"`
	EnvironmentID *int64 `json:"environmentId"`
}

type FeatureEdge struct {
	// The node containing the Feature
	Node Feature `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type FeatureFilter struct {
	And           []*FeatureFilter               `json:"and,omitempty"`
	Or            []*FeatureFilter               `json:"or,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	FeatureType   *FeatureTypeFilterComparison   `json:"featureType,omitempty"`
	MeterType     *MeterTypeFilterComparison     `json:"meterType,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison `json:"featureStatus,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
}

type FeatureInput struct {
	DisplayName        string         `json:"displayName"`
	RefID              string         `json:"refId"`
	FeatureUnits       *string        `json:"featureUnits,omitempty"`
	FeatureUnitsPlural *string        `json:"featureUnitsPlural,omitempty"`
	Description        *string        `json:"description,omitempty"`
	FeatureType        FeatureType    `json:"featureType"`
	MeterType          *MeterType     `json:"meterType,omitempty"`
	FeatureStatus      *FeatureStatus `json:"featureStatus,omitempty"`
	EnvironmentID      string         `json:"environmentId"`
}

type FeatureMaxAggregate struct {
	ID            *string        `json:"id"`
	DisplayName   *string        `json:"displayName"`
	RefID         *string        `json:"refId"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	Description   *string        `json:"description"`
	FeatureType   *FeatureType   `json:"featureType"`
	MeterType     *MeterType     `json:"meterType"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	EnvironmentID *string        `json:"environmentId"`
}

type FeatureMinAggregate struct {
	ID            *string        `json:"id"`
	DisplayName   *string        `json:"displayName"`
	RefID         *string        `json:"refId"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	Description   *string        `json:"description"`
	FeatureType   *FeatureType   `json:"featureType"`
	MeterType     *MeterType     `json:"meterType"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	EnvironmentID *string        `json:"environmentId"`
}

type FeatureNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type FeatureSort struct {
	Field     FeatureSortFields `json:"field"`
	Direction SortDirection     `json:"direction"`
	Nulls     *SortNulls        `json:"nulls,omitempty"`
}

type FeatureStatusFilterComparison struct {
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Eq       *FeatureStatus  `json:"eq,omitempty"`
	Neq      *FeatureStatus  `json:"neq,omitempty"`
	Gt       *FeatureStatus  `json:"gt,omitempty"`
	Gte      *FeatureStatus  `json:"gte,omitempty"`
	Lt       *FeatureStatus  `json:"lt,omitempty"`
	Lte      *FeatureStatus  `json:"lte,omitempty"`
	Like     *FeatureStatus  `json:"like,omitempty"`
	NotLike  *FeatureStatus  `json:"notLike,omitempty"`
	ILike    *FeatureStatus  `json:"iLike,omitempty"`
	NotILike *FeatureStatus  `json:"notILike,omitempty"`
	In       []FeatureStatus `json:"in,omitempty"`
	NotIn    []FeatureStatus `json:"notIn,omitempty"`
}

type FeatureTypeFilterComparison struct {
	Is       *bool         `json:"is,omitempty"`
	IsNot    *bool         `json:"isNot,omitempty"`
	Eq       *FeatureType  `json:"eq,omitempty"`
	Neq      *FeatureType  `json:"neq,omitempty"`
	Gt       *FeatureType  `json:"gt,omitempty"`
	Gte      *FeatureType  `json:"gte,omitempty"`
	Lt       *FeatureType  `json:"lt,omitempty"`
	Lte      *FeatureType  `json:"lte,omitempty"`
	Like     *FeatureType  `json:"like,omitempty"`
	NotLike  *FeatureType  `json:"notLike,omitempty"`
	ILike    *FeatureType  `json:"iLike,omitempty"`
	NotILike *FeatureType  `json:"notILike,omitempty"`
	In       []FeatureType `json:"in,omitempty"`
	NotIn    []FeatureType `json:"notIn,omitempty"`
}

type FetchEntitlementQuery struct {
	CustomerID    string              `json:"customerId"`
	FeatureID     string              `json:"featureId"`
	Options       *EntitlementOptions `json:"options,omitempty"`
	EnvironmentID *string             `json:"environmentId,omitempty"`
}

type FetchEntitlementsQuery struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type FontVariant struct {
	FontSize   *float64    `json:"fontSize"`
	FontWeight *FontWeight `json:"fontWeight"`
}

type FontVariantInput struct {
	FontSize   *float64    `json:"fontSize,omitempty"`
	FontWeight *FontWeight `json:"fontWeight,omitempty"`
}

type GetCustomerByRefIDInput struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type GetPackageByRefIDInput struct {
	RefID         string   `json:"refId"`
	VersionNumber *float64 `json:"versionNumber,omitempty"`
	EnvironmentID string   `json:"environmentId"`
}

type GetPaywallInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	ProductID     *string `json:"productId,omitempty"`
}

type GetWidgetConfigurationInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type Hook struct {
	ID            string         `json:"id"`
	Description   *string        `json:"description"`
	SecretKey     *string        `json:"secretKey"`
	Endpoint      string         `json:"endpoint"`
	Status        HookStatus     `json:"status"`
	CreatedAt     *string        `json:"createdAt"`
	EnvironmentID string         `json:"environmentId"`
	EventLogTypes []EventLogType `json:"eventLogTypes"`
	Account       *Account       `json:"account"`
	Environment   *Environment   `json:"environment"`
}

type HookAggregateGroupBy struct {
	ID            *string     `json:"id"`
	Endpoint      *string     `json:"endpoint"`
	Status        *HookStatus `json:"status"`
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
}

type HookConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*HookEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type HookCountAggregate struct {
	ID            *int64 `json:"id"`
	Endpoint      *int64 `json:"endpoint"`
	Status        *int64 `json:"status"`
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
}

type HookDeleteResponse struct {
	ID            *string        `json:"id"`
	Description   *string        `json:"description"`
	SecretKey     *string        `json:"secretKey"`
	Endpoint      *string        `json:"endpoint"`
	Status        *HookStatus    `json:"status"`
	CreatedAt     *string        `json:"createdAt"`
	EnvironmentID *string        `json:"environmentId"`
	EventLogTypes []EventLogType `json:"eventLogTypes"`
}

type HookEdge struct {
	// The node containing the Hook
	Node Hook `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type HookFilter struct {
	And           []*HookFilter               `json:"and,omitempty"`
	Or            []*HookFilter               `json:"or,omitempty"`
	ID            *StringFieldComparison      `json:"id,omitempty"`
	Endpoint      *StringFieldComparison      `json:"endpoint,omitempty"`
	Status        *HookStatusFilterComparison `json:"status,omitempty"`
	CreatedAt     *DateFieldComparison        `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison      `json:"environmentId,omitempty"`
}

type HookMaxAggregate struct {
	ID            *string     `json:"id"`
	Endpoint      *string     `json:"endpoint"`
	Status        *HookStatus `json:"status"`
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
}

type HookMinAggregate struct {
	ID            *string     `json:"id"`
	Endpoint      *string     `json:"endpoint"`
	Status        *HookStatus `json:"status"`
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
}

type HookSort struct {
	Field     HookSortFields `json:"field"`
	Direction SortDirection  `json:"direction"`
	Nulls     *SortNulls     `json:"nulls,omitempty"`
}

type HookStatusFilterComparison struct {
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Eq       *HookStatus  `json:"eq,omitempty"`
	Neq      *HookStatus  `json:"neq,omitempty"`
	Gt       *HookStatus  `json:"gt,omitempty"`
	Gte      *HookStatus  `json:"gte,omitempty"`
	Lt       *HookStatus  `json:"lt,omitempty"`
	Lte      *HookStatus  `json:"lte,omitempty"`
	Like     *HookStatus  `json:"like,omitempty"`
	NotLike  *HookStatus  `json:"notLike,omitempty"`
	ILike    *HookStatus  `json:"iLike,omitempty"`
	NotILike *HookStatus  `json:"notILike,omitempty"`
	In       []HookStatus `json:"in,omitempty"`
	NotIn    []HookStatus `json:"notIn,omitempty"`
}

type HubspotCredentials struct {
	HubDomain string `json:"hubDomain"`
}

func (HubspotCredentials) IsCredentials() {}

type HubspotCredentialsInput struct {
	AuthorizationCode string  `json:"authorizationCode"`
	RefreshToken      *string `json:"refreshToken,omitempty"`
}

type IdentityForbiddenError struct {
	Code                 string `json:"code"`
	IsValidationError    bool   `json:"isValidationError"`
	RequiredIdentityType string `json:"requiredIdentityType"`
	AccessedField        string `json:"accessedField"`
}

type ImportAlreadyInProgressError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type ImportCustomerInput struct {
	Name          *string `json:"name,omitempty"`
	Email         *string `json:"email,omitempty"`
	RefID         *string `json:"refId,omitempty"`
	CustomerID    *string `json:"customerId,omitempty"`
	EnvironmentID *string `json:"environmentId,omitempty"`
	BillingID     string  `json:"billingId"`
}

type ImportIntegrationCatalogInput struct {
	EnvironmentID           string              `json:"environmentId"`
	VendorIdentifier        VendorIdentifier    `json:"vendorIdentifier"`
	ProductID               string              `json:"productId"`
	SelectedAddonBillingIds []string            `json:"selectedAddonBillingIds"`
	EntitySelectionMode     EntitySelectionMode `json:"entitySelectionMode"`
	PlansSelectionWhitelist []string            `json:"plansSelectionWhitelist,omitempty"`
	PlansSelectionBlacklist []string            `json:"plansSelectionBlacklist,omitempty"`
	BillingModel            *BillingModel       `json:"billingModel,omitempty"`
	FeatureUnitName         *string             `json:"featureUnitName,omitempty"`
	FeatureUnitPluralName   *string             `json:"featureUnitPluralName,omitempty"`
}

type ImportIntegrationCustomersInput struct {
	EnvironmentID               string              `json:"environmentId"`
	VendorIdentifier            VendorIdentifier    `json:"vendorIdentifier"`
	ProductID                   string              `json:"productId"`
	EntitySelectionMode         EntitySelectionMode `json:"entitySelectionMode"`
	CustomersSelectionWhitelist []string            `json:"customersSelectionWhitelist,omitempty"`
	CustomersSelectionBlacklist []string            `json:"customersSelectionBlacklist,omitempty"`
}

type ImportIntegrationTask struct {
	ID                 string                `json:"id"`
	EnvironmentID      string                `json:"environmentId"`
	CreatedAt          *string               `json:"createdAt"`
	TaskType           TaskType              `json:"taskType"`
	Status             TaskStatus            `json:"status"`
	StartDate          string                `json:"startDate"`
	EndDate            *string               `json:"endDate"`
	Progress           int64                 `json:"progress"`
	ProductsCount      int64                 `json:"productsCount"`
	CustomersCount     int64                 `json:"customersCount"`
	TotalSubtasksCount int64                 `json:"totalSubtasksCount"`
	ImportErrors       []*ImportSubTaskError `json:"importErrors"`
}

type ImportIntegrationTaskAggregateGroupBy struct {
	ID            *string     `json:"id"`
	EnvironmentID *string     `json:"environmentId"`
	CreatedAt     *string     `json:"createdAt"`
	TaskType      *TaskType   `json:"taskType"`
	Status        *TaskStatus `json:"status"`
}

type ImportIntegrationTaskConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*ImportIntegrationTaskEdge `json:"edges"`
}

type ImportIntegrationTaskCountAggregate struct {
	ID            *int64 `json:"id"`
	EnvironmentID *int64 `json:"environmentId"`
	CreatedAt     *int64 `json:"createdAt"`
	TaskType      *int64 `json:"taskType"`
	Status        *int64 `json:"status"`
}

type ImportIntegrationTaskEdge struct {
	// The node containing the ImportIntegrationTask
	Node ImportIntegrationTask `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type ImportIntegrationTaskFilter struct {
	And           []*ImportIntegrationTaskFilter `json:"and,omitempty"`
	Or            []*ImportIntegrationTaskFilter `json:"or,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	TaskType      *TaskTypeFilterComparison      `json:"taskType,omitempty"`
	Status        *TaskStatusFilterComparison    `json:"status,omitempty"`
}

type ImportIntegrationTaskMaxAggregate struct {
	ID            *string     `json:"id"`
	EnvironmentID *string     `json:"environmentId"`
	CreatedAt     *string     `json:"createdAt"`
	TaskType      *TaskType   `json:"taskType"`
	Status        *TaskStatus `json:"status"`
}

type ImportIntegrationTaskMinAggregate struct {
	ID            *string     `json:"id"`
	EnvironmentID *string     `json:"environmentId"`
	CreatedAt     *string     `json:"createdAt"`
	TaskType      *TaskType   `json:"taskType"`
	Status        *TaskStatus `json:"status"`
}

type ImportIntegrationTaskSort struct {
	Field     ImportIntegrationTaskSortFields `json:"field"`
	Direction SortDirection                   `json:"direction"`
	Nulls     *SortNulls                      `json:"nulls,omitempty"`
}

type ImportSubTaskError struct {
	ID    string `json:"id"`
	Error string `json:"error"`
}

type InitAddStripeCustomerPaymentMethod struct {
	PaymentIntentClientSecret string `json:"paymentIntentClientSecret"`
}

type InitAddStripeCustomerPaymentMethodInput struct {
	CustomerRefID string  `json:"customerRefId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type InitStripePaymentMethodError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InitiateCheckoutInput struct {
	CustomerID            string                    `json:"customerId"`
	PlanID                string                    `json:"planId"`
	Addons                []*SubscriptionAddonInput `json:"addons,omitempty"`
	BillingPeriod         BillingPeriod             `json:"billingPeriod"`
	UnitQuantity          *int64                    `json:"unitQuantity,omitempty"`
	SuccessURL            string                    `json:"successUrl"`
	CancelURL             string                    `json:"cancelUrl"`
	AllowPromoCodes       *bool                     `json:"allowPromoCodes,omitempty"`
	CollectBillingAddress *bool                     `json:"collectBillingAddress,omitempty"`
}

type IntFieldComparison struct {
	Is         *bool                      `json:"is,omitempty"`
	IsNot      *bool                      `json:"isNot,omitempty"`
	Eq         *int64                     `json:"eq,omitempty"`
	Neq        *int64                     `json:"neq,omitempty"`
	Gt         *int64                     `json:"gt,omitempty"`
	Gte        *int64                     `json:"gte,omitempty"`
	Lt         *int64                     `json:"lt,omitempty"`
	Lte        *int64                     `json:"lte,omitempty"`
	In         []int64                    `json:"in,omitempty"`
	NotIn      []int64                    `json:"notIn,omitempty"`
	Between    *IntFieldComparisonBetween `json:"between,omitempty"`
	NotBetween *IntFieldComparisonBetween `json:"notBetween,omitempty"`
}

type IntFieldComparisonBetween struct {
	Lower int64 `json:"lower"`
	Upper int64 `json:"upper"`
}

type Integration struct {
	ID               string           `json:"id"`
	CreatedAt        *string          `json:"createdAt"`
	EnvironmentID    string           `json:"environmentId"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
	Credentials      Credentials      `json:"credentials"`
	Account          *Account         `json:"account"`
	Environment      *Environment     `json:"environment"`
}

type IntegrationAggregateGroupBy struct {
	ID               *string           `json:"id"`
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*IntegrationEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type IntegrationCountAggregate struct {
	ID               *int64 `json:"id"`
	CreatedAt        *int64 `json:"createdAt"`
	EnvironmentID    *int64 `json:"environmentId"`
	VendorIdentifier *int64 `json:"vendorIdentifier"`
}

type IntegrationDeleteResponse struct {
	ID               *string           `json:"id"`
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
	Credentials      Credentials       `json:"credentials"`
}

type IntegrationEdge struct {
	// The node containing the Integration
	Node Integration `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type IntegrationFilter struct {
	And              []*IntegrationFilter              `json:"and,omitempty"`
	Or               []*IntegrationFilter              `json:"or,omitempty"`
	ID               *StringFieldComparison            `json:"id,omitempty"`
	CreatedAt        *DateFieldComparison              `json:"createdAt,omitempty"`
	EnvironmentID    *StringFieldComparison            `json:"environmentId,omitempty"`
	VendorIdentifier *VendorIdentifierFilterComparison `json:"vendorIdentifier,omitempty"`
}

type IntegrationMaxAggregate struct {
	ID               *string           `json:"id"`
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationMinAggregate struct {
	ID               *string           `json:"id"`
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationSort struct {
	Field     IntegrationSortFields `json:"field"`
	Direction SortDirection         `json:"direction"`
	Nulls     *SortNulls            `json:"nulls,omitempty"`
}

type InvalidArgumentError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidCancellationDate struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type InvalidEntitlementResetPeriodError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidMemberDeleteError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidSubscriptionStatus struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidUsageValueForIncrementalFeatureError struct {
	Code              string  `json:"code"`
	IsValidationError bool    `json:"isValidationError"`
	UsageValue        float64 `json:"usageValue"`
}

type Member struct {
	ID                     string       `json:"id"`
	CreatedAt              *string      `json:"createdAt"`
	MemberStatus           MemberStatus `json:"memberStatus"`
	Email                  string       `json:"email"`
	ServiceAPIKey          *string      `json:"serviceApiKey"`
	CubejsToken            *string      `json:"cubejsToken"`
	HideGettingStartedPage *bool        `json:"hideGettingStartedPage"`
	User                   *User        `json:"user"`
	Account                Account      `json:"account"`
}

type MemberAggregateGroupBy struct {
	ID        *string `json:"id"`
	CreatedAt *string `json:"createdAt"`
}

type MemberConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*MemberEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type MemberCountAggregate struct {
	ID        *int64 `json:"id"`
	CreatedAt *int64 `json:"createdAt"`
}

type MemberEdge struct {
	// The node containing the Member
	Node Member `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type MemberFilter struct {
	And       []*MemberFilter        `json:"and,omitempty"`
	Or        []*MemberFilter        `json:"or,omitempty"`
	ID        *StringFieldComparison `json:"id,omitempty"`
	CreatedAt *DateFieldComparison   `json:"createdAt,omitempty"`
}

type MemberInvitationError struct {
	Code   string `json:"code"`
	Reason string `json:"reason"`
}

type MemberMaxAggregate struct {
	ID        *string `json:"id"`
	CreatedAt *string `json:"createdAt"`
}

type MemberMinAggregate struct {
	ID        *string `json:"id"`
	CreatedAt *string `json:"createdAt"`
}

type MemberNotFoundError struct {
	Code string `json:"code"`
}

type MemberSort struct {
	Field     MemberSortFields `json:"field"`
	Direction SortDirection    `json:"direction"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

type MembersInviteResponse struct {
	SuccessInvites []string `json:"successInvites"`
	SkippedInvites []string `json:"skippedInvites"`
	FailedInvites  []string `json:"failedInvites"`
}

type MeterTypeFilterComparison struct {
	Is       *bool       `json:"is,omitempty"`
	IsNot    *bool       `json:"isNot,omitempty"`
	Eq       *MeterType  `json:"eq,omitempty"`
	Neq      *MeterType  `json:"neq,omitempty"`
	Gt       *MeterType  `json:"gt,omitempty"`
	Gte      *MeterType  `json:"gte,omitempty"`
	Lt       *MeterType  `json:"lt,omitempty"`
	Lte      *MeterType  `json:"lte,omitempty"`
	Like     *MeterType  `json:"like,omitempty"`
	NotLike  *MeterType  `json:"notLike,omitempty"`
	ILike    *MeterType  `json:"iLike,omitempty"`
	NotILike *MeterType  `json:"notILike,omitempty"`
	In       []MeterType `json:"in,omitempty"`
	NotIn    []MeterType `json:"notIn,omitempty"`
}

type MeteringNotAvailableForFeatureTypeError struct {
	Code        string `json:"code"`
	FeatureType string `json:"featureType"`
}

type MockPaywall struct {
	Plans         []*PaywallPlan        `json:"plans"`
	Configuration *PaywallConfiguration `json:"configuration"`
}

type Money struct {
	Amount   float64  `json:"amount"`
	Currency Currency `json:"currency"`
}

type MoneyInputDto struct {
	Amount   float64   `json:"amount"`
	Currency *Currency `json:"currency,omitempty"`
}

type MonthlyResetPeriodConfig struct {
	MonthlyAccordingTo *MonthlyAccordingTo `json:"monthlyAccordingTo"`
}

func (MonthlyResetPeriodConfig) IsResetPeriodConfiguration() {}

type MonthlyResetPeriodConfigInput struct {
	AccordingTo MonthlyAccordingTo `json:"accordingTo"`
}

type NumberFieldComparison struct {
	Is         *bool                         `json:"is,omitempty"`
	IsNot      *bool                         `json:"isNot,omitempty"`
	Eq         *float64                      `json:"eq,omitempty"`
	Neq        *float64                      `json:"neq,omitempty"`
	Gt         *float64                      `json:"gt,omitempty"`
	Gte        *float64                      `json:"gte,omitempty"`
	Lt         *float64                      `json:"lt,omitempty"`
	Lte        *float64                      `json:"lte,omitempty"`
	In         []float64                     `json:"in,omitempty"`
	NotIn      []float64                     `json:"notIn,omitempty"`
	Between    *NumberFieldComparisonBetween `json:"between,omitempty"`
	NotBetween *NumberFieldComparisonBetween `json:"notBetween,omitempty"`
}

type NumberFieldComparisonBetween struct {
	Lower float64 `json:"lower"`
	Upper float64 `json:"upper"`
}

type PackageAlreadyPublishedError struct {
	Code string `json:"code"`
}

type PackageChanges struct {
	DisplayName        *StringChangeDto             `json:"displayName"`
	Description        *StringChangeDto             `json:"description"`
	PricingType        *PricingTypeChange           `json:"pricingType"`
	Entitlements       []*PackageEntitlementChange  `json:"entitlements"`
	Prices             []*PackagePriceChange        `json:"prices"`
	CompatibleAddons   []*PlanCompatibleAddonChange `json:"compatibleAddons"`
	BasePlan           *BasePlanChange              `json:"basePlan"`
	DefaultTrialConfig *DefaultTrialConfigChange    `json:"defaultTrialConfig"`
	AdditionalMetaData *AdditionalMetaDataChange    `json:"additionalMetaData"`
	TotalChanges       int64                        `json:"totalChanges"`
}

type PackageDto struct {
	ID                 string                 `json:"id"`
	CreatedAt          *string                `json:"createdAt"`
	UpdatedAt          *string                `json:"updatedAt"`
	RefID              string                 `json:"refId"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	DisplayName        string                 `json:"displayName"`
	Status             PackageStatus          `json:"status"`
	PricingType        *PricingType           `json:"pricingType"`
	Description        *string                `json:"description"`
	EnvironmentID      *string                `json:"environmentId"`
	Type               *string                `json:"type"`
	ProductID          *string                `json:"productId"`
	IsLatest           *bool                  `json:"isLatest"`
	Entitlements       []*PackageEntitlement  `json:"entitlements"`
	DraftSummary       *PackageDraftSummary   `json:"draftSummary"`
	DraftDetails       *PackageDraftDetails   `json:"draftDetails"`
	VersionNumber      int64                  `json:"versionNumber"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	SyncStates         []*SyncState           `json:"syncStates"`
}

type PackageDTOFilter struct {
	And           []*PackageDTOFilter            `json:"and,omitempty"`
	Or            []*PackageDTOFilter            `json:"or,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PackageDTOSort struct {
	Field     PackageDTOSortFields `json:"field"`
	Direction SortDirection        `json:"direction"`
	Nulls     *SortNulls           `json:"nulls,omitempty"`
}

type PackageDraftDetails struct {
	Version             int64           `json:"version"`
	UpdatedAt           string          `json:"updatedAt"`
	UpdatedBy           *string         `json:"updatedBy"`
	CustomersAffected   *int64          `json:"customersAffected"`
	ChildPlansWithDraft []*Plan         `json:"childPlansWithDraft"`
	AffectedChildPlans  []*Plan         `json:"affectedChildPlans"`
	Changes             *PackageChanges `json:"changes"`
}

type PackageDraftSummary struct {
	Version   int64   `json:"version"`
	UpdatedAt string  `json:"updatedAt"`
	UpdatedBy *string `json:"updatedBy"`
}

type PackageEntitlement struct {
	ID                       string                   `json:"id"`
	Description              *string                  `json:"description"`
	FeatureID                string                   `json:"featureId"`
	PackageID                string                   `json:"packageId"`
	CreatedAt                *string                  `json:"createdAt"`
	UpdatedAt                *string                  `json:"updatedAt"`
	UsageLimit               *float64                 `json:"usageLimit"`
	HasUnlimitedUsage        *bool                    `json:"hasUnlimitedUsage"`
	EnvironmentID            string                   `json:"environmentId"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	Order                    *float64                 `json:"order"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
	Feature                  Feature                  `json:"feature"`
	Package                  *PackageDto              `json:"package"`
}

type PackageEntitlementAggregateGroupBy struct {
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	CreatedAt     *string `json:"createdAt"`
	UpdatedAt     *string `json:"updatedAt"`
	EnvironmentID *string `json:"environmentId"`
}

type PackageEntitlementChange struct {
	Before     *PackageEntitlement `json:"before"`
	After      *PackageEntitlement `json:"after"`
	ChangeType *ChangeType         `json:"changeType"`
}

type PackageEntitlementConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*PackageEntitlementEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PackageEntitlementCountAggregate struct {
	ID            *int64 `json:"id"`
	PackageID     *int64 `json:"packageId"`
	CreatedAt     *int64 `json:"createdAt"`
	UpdatedAt     *int64 `json:"updatedAt"`
	EnvironmentID *int64 `json:"environmentId"`
}

type PackageEntitlementDeleteResponse struct {
	ID                       *string                  `json:"id"`
	Description              *string                  `json:"description"`
	FeatureID                *string                  `json:"featureId"`
	PackageID                *string                  `json:"packageId"`
	CreatedAt                *string                  `json:"createdAt"`
	UpdatedAt                *string                  `json:"updatedAt"`
	UsageLimit               *float64                 `json:"usageLimit"`
	HasUnlimitedUsage        *bool                    `json:"hasUnlimitedUsage"`
	EnvironmentID            *string                  `json:"environmentId"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	Order                    *float64                 `json:"order"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
}

type PackageEntitlementEdge struct {
	// The node containing the PackageEntitlement
	Node PackageEntitlement `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type PackageEntitlementFilter struct {
	And           []*PackageEntitlementFilter               `json:"and,omitempty"`
	Or            []*PackageEntitlementFilter               `json:"or,omitempty"`
	ID            *StringFieldComparison                    `json:"id,omitempty"`
	PackageID     *StringFieldComparison                    `json:"packageId,omitempty"`
	CreatedAt     *DateFieldComparison                      `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison                      `json:"updatedAt,omitempty"`
	EnvironmentID *StringFieldComparison                    `json:"environmentId,omitempty"`
	Package       *PackageEntitlementFilterPackageDTOFilter `json:"package,omitempty"`
	Feature       *PackageEntitlementFilterFeatureFilter    `json:"feature,omitempty"`
}

type PackageEntitlementFilterFeatureFilter struct {
	And           []*PackageEntitlementFilterFeatureFilter `json:"and,omitempty"`
	Or            []*PackageEntitlementFilterFeatureFilter `json:"or,omitempty"`
	ID            *StringFieldComparison                   `json:"id,omitempty"`
	DisplayName   *StringFieldComparison                   `json:"displayName,omitempty"`
	RefID         *StringFieldComparison                   `json:"refId,omitempty"`
	CreatedAt     *DateFieldComparison                     `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison                     `json:"updatedAt,omitempty"`
	Description   *StringFieldComparison                   `json:"description,omitempty"`
	FeatureType   *FeatureTypeFilterComparison             `json:"featureType,omitempty"`
	MeterType     *MeterTypeFilterComparison               `json:"meterType,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison           `json:"featureStatus,omitempty"`
	EnvironmentID *StringFieldComparison                   `json:"environmentId,omitempty"`
}

type PackageEntitlementFilterPackageDTOFilter struct {
	And           []*PackageEntitlementFilterPackageDTOFilter `json:"and,omitempty"`
	Or            []*PackageEntitlementFilterPackageDTOFilter `json:"or,omitempty"`
	ID            *StringFieldComparison                      `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison                        `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison                        `json:"updatedAt,omitempty"`
	RefID         *StringFieldComparison                      `json:"refId,omitempty"`
	BillingID     *StringFieldComparison                      `json:"billingId,omitempty"`
	DisplayName   *StringFieldComparison                      `json:"displayName,omitempty"`
	Status        *PackageStatusFilterComparison              `json:"status,omitempty"`
	PricingType   *PricingTypeFilterComparison                `json:"pricingType,omitempty"`
	Description   *StringFieldComparison                      `json:"description,omitempty"`
	EnvironmentID *StringFieldComparison                      `json:"environmentId,omitempty"`
	ProductID     *StringFieldComparison                      `json:"productId,omitempty"`
	IsLatest      *BooleanFieldComparison                     `json:"isLatest,omitempty"`
	VersionNumber *IntFieldComparison                         `json:"versionNumber,omitempty"`
}

type PackageEntitlementInput struct {
	Description                     *string                        `json:"description,omitempty"`
	FeatureID                       string                         `json:"featureId"`
	PackageID                       string                         `json:"packageId"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	EnvironmentID                   string                         `json:"environmentId"`
	Order                           *float64                       `json:"order,omitempty"`
}

type PackageEntitlementMaxAggregate struct {
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	CreatedAt     *string `json:"createdAt"`
	UpdatedAt     *string `json:"updatedAt"`
	EnvironmentID *string `json:"environmentId"`
}

type PackageEntitlementMinAggregate struct {
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	CreatedAt     *string `json:"createdAt"`
	UpdatedAt     *string `json:"updatedAt"`
	EnvironmentID *string `json:"environmentId"`
}

type PackageEntitlementSort struct {
	Field     PackageEntitlementSortFields `json:"field"`
	Direction SortDirection                `json:"direction"`
	Nulls     *SortNulls                   `json:"nulls,omitempty"`
}

type PackageEntitlementUpdateInput struct {
	Description                     *string                        `json:"description,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	Order                           *float64                       `json:"order,omitempty"`
	HiddenFromWidgets               []WidgetType                   `json:"hiddenFromWidgets,omitempty"`
	DisplayNameOverride             *string                        `json:"displayNameOverride,omitempty"`
}

type PackagePrice struct {
	PackageID   string      `json:"packageId"`
	PricingType PricingType `json:"pricingType"`
}

type PackagePriceChange struct {
	Before     *Price      `json:"before"`
	After      *Price      `json:"after"`
	ChangeType *ChangeType `json:"changeType"`
}

type PackagePricingInput struct {
	PricingType   PricingType              `json:"pricingType"`
	EnvironmentID string                   `json:"environmentId"`
	PackageID     string                   `json:"packageId"`
	PricingModel  *PricingModelCreateInput `json:"pricingModel,omitempty"`
}

type PackagePricingTypeNotSetError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type PackagePublishInput struct {
	ID            string               `json:"id"`
	MigrationType PublishMigrationType `json:"migrationType"`
}

type PackageStatusFilterComparison struct {
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Eq       *PackageStatus  `json:"eq,omitempty"`
	Neq      *PackageStatus  `json:"neq,omitempty"`
	Gt       *PackageStatus  `json:"gt,omitempty"`
	Gte      *PackageStatus  `json:"gte,omitempty"`
	Lt       *PackageStatus  `json:"lt,omitempty"`
	Lte      *PackageStatus  `json:"lte,omitempty"`
	Like     *PackageStatus  `json:"like,omitempty"`
	NotLike  *PackageStatus  `json:"notLike,omitempty"`
	ILike    *PackageStatus  `json:"iLike,omitempty"`
	NotILike *PackageStatus  `json:"notILike,omitempty"`
	In       []PackageStatus `json:"in,omitempty"`
	NotIn    []PackageStatus `json:"notIn,omitempty"`
}

type PageInfo struct {
	// true if paging forward and there are more records.
	HasNextPage *bool `json:"hasNextPage"`
	// true if paging backwards and there are more records.
	HasPreviousPage *bool `json:"hasPreviousPage"`
	// The cursor of the first returned record.
	StartCursor *string `json:"startCursor"`
	// The cursor of the last returned record.
	EndCursor *string `json:"endCursor"`
}

type Paywall struct {
	Plans         []*Plan               `json:"plans"`
	Configuration *PaywallConfiguration `json:"configuration"`
}

type PaywallAddon struct {
	RefID              string                 `json:"refId"`
	Description        *string                `json:"description"`
	DisplayName        string                 `json:"displayName"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	Entitlements       []*Entitlement         `json:"entitlements"`
	Prices             []*PaywallPrice        `json:"prices"`
	PricingType        *PricingType           `json:"pricingType"`
}

type PaywallBasePlan struct {
	RefID       string `json:"refId"`
	DisplayName string `json:"displayName"`
}

type PaywallColorsPalette struct {
	Primary               *string `json:"primary"`
	TextColor             *string `json:"textColor"`
	BackgroundColor       *string `json:"backgroundColor"`
	BorderColor           *string `json:"borderColor"`
	CurrentPlanBackground *string `json:"currentPlanBackground"`
}

type PaywallColorsPaletteInput struct {
	Primary               *string `json:"primary,omitempty"`
	TextColor             *string `json:"textColor,omitempty"`
	BackgroundColor       *string `json:"backgroundColor,omitempty"`
	BorderColor           *string `json:"borderColor,omitempty"`
	CurrentPlanBackground *string `json:"currentPlanBackground,omitempty"`
}

type PaywallConfiguration struct {
	Palette    *PaywallColorsPalette       `json:"palette"`
	Typography *TypographyConfiguration    `json:"typography"`
	Layout     *PaywallLayoutConfiguration `json:"layout"`
}

type PaywallConfigurationInput struct {
	Palette    *PaywallColorsPaletteInput       `json:"palette,omitempty"`
	Typography *TypographyConfigurationInput    `json:"typography,omitempty"`
	Layout     *PaywallLayoutConfigurationInput `json:"layout,omitempty"`
}

type PaywallLayoutConfiguration struct {
	Alignment   *Alignment `json:"alignment"`
	PlanWidth   *float64   `json:"planWidth"`
	PlanMargin  *float64   `json:"planMargin"`
	PlanPadding *float64   `json:"planPadding"`
}

type PaywallLayoutConfigurationInput struct {
	Alignment   *Alignment `json:"alignment,omitempty"`
	PlanWidth   *float64   `json:"planWidth,omitempty"`
	PlanMargin  *float64   `json:"planMargin,omitempty"`
	PlanPadding *float64   `json:"planPadding,omitempty"`
}

type PaywallPlan struct {
	RefID                 string                 `json:"refId"`
	Description           *string                `json:"description"`
	DisplayName           string                 `json:"displayName"`
	AdditionalMetaData    map[string]interface{} `json:"additionalMetaData"`
	Product               PaywallProduct         `json:"product"`
	BasePlan              *PaywallBasePlan       `json:"basePlan"`
	DefaultTrialConfig    *DefaultTrialConfig    `json:"defaultTrialConfig"`
	CompatibleAddons      []*PaywallAddon        `json:"compatibleAddons"`
	Prices                []*PaywallPrice        `json:"prices"`
	PricingType           *PricingType           `json:"pricingType"`
	InheritedEntitlements []*Entitlement         `json:"inheritedEntitlements"`
	Entitlements          []*Entitlement         `json:"entitlements"`
}

type PaywallPrice struct {
	BillingPeriod   BillingPeriod       `json:"billingPeriod"`
	BillingModel    BillingModel        `json:"billingModel"`
	Price           Money               `json:"price"`
	FeatureID       *string             `json:"featureId"`
	MinUnitQuantity *float64            `json:"minUnitQuantity"`
	MaxUnitQuantity *float64            `json:"maxUnitQuantity"`
	Feature         *EntitlementFeature `json:"feature"`
}

type PaywallProduct struct {
	RefID              string                 `json:"refId"`
	DisplayName        *string                `json:"displayName"`
	Description        *string                `json:"description"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
}

type Plan struct {
	ID                    string                 `json:"id"`
	CreatedAt             *string                `json:"createdAt"`
	UpdatedAt             *string                `json:"updatedAt"`
	RefID                 string                 `json:"refId"`
	BillingID             *string                `json:"billingId"`
	BillingLinkURL        *string                `json:"billingLinkUrl"`
	DisplayName           string                 `json:"displayName"`
	Status                PackageStatus          `json:"status"`
	PricingType           *PricingType           `json:"pricingType"`
	Description           *string                `json:"description"`
	EnvironmentID         *string                `json:"environmentId"`
	Type                  *string                `json:"type"`
	ProductID             *string                `json:"productId"`
	IsLatest              *bool                  `json:"isLatest"`
	Entitlements          []*PackageEntitlement  `json:"entitlements"`
	DraftSummary          *PackageDraftSummary   `json:"draftSummary"`
	DraftDetails          *PackageDraftDetails   `json:"draftDetails"`
	VersionNumber         int64                  `json:"versionNumber"`
	AdditionalMetaData    map[string]interface{} `json:"additionalMetaData"`
	SyncStates            []*SyncState           `json:"syncStates"`
	IsParent              bool                   `json:"isParent"`
	InheritedEntitlements []*PackageEntitlement  `json:"inheritedEntitlements"`
	DefaultTrialConfig    *DefaultTrialConfig    `json:"defaultTrialConfig"`
	Product               Product                `json:"product"`
	BasePlan              *Plan                  `json:"basePlan"`
	Environment           *Environment           `json:"environment"`
	CompatibleAddons      []*Addon               `json:"compatibleAddons"`
	Prices                []*Price               `json:"prices"`
}

type PlanAggregateGroupBy struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	RefID         *string        `json:"refId"`
	BillingID     *string        `json:"billingId"`
	DisplayName   *string        `json:"displayName"`
	Status        *PackageStatus `json:"status"`
	PricingType   *PricingType   `json:"pricingType"`
	Description   *string        `json:"description"`
	EnvironmentID *string        `json:"environmentId"`
	ProductID     *string        `json:"productId"`
	IsLatest      *bool          `json:"isLatest"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type PlanCompatibleAddonChange struct {
	Before     *Addon      `json:"before"`
	After      *Addon      `json:"after"`
	ChangeType *ChangeType `json:"changeType"`
}

type PlanConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*PlanEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PlanCountAggregate struct {
	ID            *int64 `json:"id"`
	CreatedAt     *int64 `json:"createdAt"`
	UpdatedAt     *int64 `json:"updatedAt"`
	RefID         *int64 `json:"refId"`
	BillingID     *int64 `json:"billingId"`
	DisplayName   *int64 `json:"displayName"`
	Status        *int64 `json:"status"`
	PricingType   *int64 `json:"pricingType"`
	Description   *int64 `json:"description"`
	EnvironmentID *int64 `json:"environmentId"`
	ProductID     *int64 `json:"productId"`
	IsLatest      *int64 `json:"isLatest"`
	VersionNumber *int64 `json:"versionNumber"`
}

type PlanCreateInput struct {
	DisplayName        string                 `json:"displayName"`
	Description        *string                `json:"description,omitempty"`
	RefID              *string                `json:"refId,omitempty"`
	Status             *PackageStatus         `json:"status,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	ProductID          string                 `json:"productId"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	ParentPlanID       *string                `json:"parentPlanId,omitempty"`
}

type PlanEdge struct {
	// The node containing the Plan
	Node Plan `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type PlanFilter struct {
	And              []*PlanFilter                  `json:"and,omitempty"`
	Or               []*PlanFilter                  `json:"or,omitempty"`
	ID               *StringFieldComparison         `json:"id,omitempty"`
	CreatedAt        *DateFieldComparison           `json:"createdAt,omitempty"`
	UpdatedAt        *DateFieldComparison           `json:"updatedAt,omitempty"`
	RefID            *StringFieldComparison         `json:"refId,omitempty"`
	BillingID        *StringFieldComparison         `json:"billingId,omitempty"`
	DisplayName      *StringFieldComparison         `json:"displayName,omitempty"`
	Status           *PackageStatusFilterComparison `json:"status,omitempty"`
	PricingType      *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	Description      *StringFieldComparison         `json:"description,omitempty"`
	EnvironmentID    *StringFieldComparison         `json:"environmentId,omitempty"`
	ProductID        *StringFieldComparison         `json:"productId,omitempty"`
	IsLatest         *BooleanFieldComparison        `json:"isLatest,omitempty"`
	VersionNumber    *IntFieldComparison            `json:"versionNumber,omitempty"`
	Product          *PlanFilterProductFilter       `json:"product,omitempty"`
	CompatibleAddons *PlanFilterAddonFilter         `json:"compatibleAddons,omitempty"`
}

type PlanFilterAddonFilter struct {
	And           []*PlanFilterAddonFilter       `json:"and,omitempty"`
	Or            []*PlanFilterAddonFilter       `json:"or,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PlanFilterProductFilter struct {
	And              []*PlanFilterProductFilter `json:"and,omitempty"`
	Or               []*PlanFilterProductFilter `json:"or,omitempty"`
	ID               *StringFieldComparison     `json:"id,omitempty"`
	DisplayName      *StringFieldComparison     `json:"displayName,omitempty"`
	RefID            *StringFieldComparison     `json:"refId,omitempty"`
	Description      *StringFieldComparison     `json:"description,omitempty"`
	CreatedAt        *DateFieldComparison       `json:"createdAt,omitempty"`
	UpdatedAt        *DateFieldComparison       `json:"updatedAt,omitempty"`
	EnvironmentID    *StringFieldComparison     `json:"environmentId,omitempty"`
	IsDefaultProduct *BooleanFieldComparison    `json:"isDefaultProduct,omitempty"`
}

type PlanMaxAggregate struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	RefID         *string        `json:"refId"`
	BillingID     *string        `json:"billingId"`
	DisplayName   *string        `json:"displayName"`
	Status        *PackageStatus `json:"status"`
	PricingType   *PricingType   `json:"pricingType"`
	Description   *string        `json:"description"`
	EnvironmentID *string        `json:"environmentId"`
	ProductID     *string        `json:"productId"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanMinAggregate struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	UpdatedAt     *string        `json:"updatedAt"`
	RefID         *string        `json:"refId"`
	BillingID     *string        `json:"billingId"`
	DisplayName   *string        `json:"displayName"`
	Status        *PackageStatus `json:"status"`
	PricingType   *PricingType   `json:"pricingType"`
	Description   *string        `json:"description"`
	EnvironmentID *string        `json:"environmentId"`
	ProductID     *string        `json:"productId"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type PlanSort struct {
	Field     PlanSortFields `json:"field"`
	Direction SortDirection  `json:"direction"`
	Nulls     *SortNulls     `json:"nulls,omitempty"`
}

type PlanSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type PlanUpdateInput struct {
	ID                 string                      `json:"id"`
	DisplayName        *string                     `json:"displayName,omitempty"`
	Description        *string                     `json:"description,omitempty"`
	Status             *PackageStatus              `json:"status,omitempty"`
	BillingID          *string                     `json:"billingId,omitempty"`
	ParentPlanID       *string                     `json:"parentPlanId,omitempty"`
	DefaultTrialConfig *DefaultTrialConfigInputDto `json:"defaultTrialConfig,omitempty"`
	AdditionalMetaData map[string]interface{}      `json:"additionalMetaData,omitempty"`
}

type Price struct {
	ID              string        `json:"id"`
	CreatedAt       *string       `json:"createdAt"`
	BillingPeriod   BillingPeriod `json:"billingPeriod"`
	BillingModel    BillingModel  `json:"billingModel"`
	Price           Money         `json:"price"`
	FeatureID       *string       `json:"featureId"`
	MinUnitQuantity *float64      `json:"minUnitQuantity"`
	MaxUnitQuantity *float64      `json:"maxUnitQuantity"`
	Feature         *Feature      `json:"feature"`
	CrmID           *string       `json:"crmId"`
	CrmLinkURL      *string       `json:"crmLinkUrl"`
	Package         PackageDto    `json:"package"`
}

type PriceAggregateGroupBy struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	BillingModel  *BillingModel  `json:"billingModel"`
}

type PriceCountAggregate struct {
	ID            *int64 `json:"id"`
	CreatedAt     *int64 `json:"createdAt"`
	BillingPeriod *int64 `json:"billingPeriod"`
	BillingModel  *int64 `json:"billingModel"`
}

type PriceDeleteResponse struct {
	ID              *string        `json:"id"`
	CreatedAt       *string        `json:"createdAt"`
	BillingPeriod   *BillingPeriod `json:"billingPeriod"`
	BillingModel    *BillingModel  `json:"billingModel"`
	Price           *Money         `json:"price"`
	FeatureID       *string        `json:"featureId"`
	MinUnitQuantity *float64       `json:"minUnitQuantity"`
	MaxUnitQuantity *float64       `json:"maxUnitQuantity"`
	Feature         *Feature       `json:"feature"`
	CrmID           *string        `json:"crmId"`
	CrmLinkURL      *string        `json:"crmLinkUrl"`
}

type PriceEdge struct {
	// The node containing the Price
	Node Price `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type PriceEntitlement struct {
	Description              *string                  `json:"description"`
	FeatureID                string                   `json:"featureId"`
	PackageID                string                   `json:"packageId"`
	UpdatedAt                *string                  `json:"updatedAt"`
	UsageLimit               *float64                 `json:"usageLimit"`
	HasUnlimitedUsage        *bool                    `json:"hasUnlimitedUsage"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	Package                  PackageDto               `json:"package"`
	Feature                  Feature                  `json:"feature"`
}

type PriceFilter struct {
	And           []*PriceFilter                 `json:"and,omitempty"`
	Or            []*PriceFilter                 `json:"or,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	BillingPeriod *BillingPeriodFilterComparison `json:"billingPeriod,omitempty"`
	BillingModel  *BillingModelFilterComparison  `json:"billingModel,omitempty"`
	Package       *PriceFilterPackageDTOFilter   `json:"package,omitempty"`
}

type PriceFilterPackageDTOFilter struct {
	And           []*PriceFilterPackageDTOFilter `json:"and,omitempty"`
	Or            []*PriceFilterPackageDTOFilter `json:"or,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PriceMaxAggregate struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	BillingModel  *BillingModel  `json:"billingModel"`
}

type PriceMinAggregate struct {
	ID            *string        `json:"id"`
	CreatedAt     *string        `json:"createdAt"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	BillingModel  *BillingModel  `json:"billingModel"`
}

type PriceNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PricePeriodInput struct {
	BillingPeriod BillingPeriod `json:"billingPeriod"`
	Price         MoneyInputDto `json:"price"`
}

type PriceSort struct {
	Field     PriceSortFields `json:"field"`
	Direction SortDirection   `json:"direction"`
	Nulls     *SortNulls      `json:"nulls,omitempty"`
}

type PricingModelCreateInput struct {
	BillingModel    BillingModel        `json:"billingModel"`
	PricePeriods    []*PricePeriodInput `json:"pricePeriods"`
	FeatureID       *string             `json:"featureId,omitempty"`
	MinUnitQuantity *float64            `json:"minUnitQuantity,omitempty"`
	MaxUnitQuantity *float64            `json:"maxUnitQuantity,omitempty"`
}

type PricingTypeChange struct {
	Before     *PricingType `json:"before"`
	After      *PricingType `json:"after"`
	ChangeType *ChangeType  `json:"changeType"`
}

type PricingTypeFilterComparison struct {
	Is       *bool         `json:"is,omitempty"`
	IsNot    *bool         `json:"isNot,omitempty"`
	Eq       *PricingType  `json:"eq,omitempty"`
	Neq      *PricingType  `json:"neq,omitempty"`
	Gt       *PricingType  `json:"gt,omitempty"`
	Gte      *PricingType  `json:"gte,omitempty"`
	Lt       *PricingType  `json:"lt,omitempty"`
	Lte      *PricingType  `json:"lte,omitempty"`
	Like     *PricingType  `json:"like,omitempty"`
	NotLike  *PricingType  `json:"notLike,omitempty"`
	ILike    *PricingType  `json:"iLike,omitempty"`
	NotILike *PricingType  `json:"notILike,omitempty"`
	In       []PricingType `json:"in,omitempty"`
	NotIn    []PricingType `json:"notIn,omitempty"`
}

type Product struct {
	ID                    string                 `json:"id"`
	DisplayName           *string                `json:"displayName"`
	RefID                 string                 `json:"refId"`
	Description           *string                `json:"description"`
	CreatedAt             string                 `json:"createdAt"`
	UpdatedAt             string                 `json:"updatedAt"`
	EnvironmentID         string                 `json:"environmentId"`
	IsDefaultProduct      bool                   `json:"isDefaultProduct"`
	Plans                 []*Plan                `json:"plans"`
	Addons                []*Addon               `json:"addons"`
	ProductSettings       ProductSettings        `json:"productSettings"`
	AdditionalMetaData    map[string]interface{} `json:"additionalMetaData"`
	Environment           *Environment           `json:"environment"`
	DowngradePlan         *Plan                  `json:"downgradePlan"`
	SubscriptionStartPlan *Plan                  `json:"subscriptionStartPlan"`
}

type ProductAggregateGroupBy struct {
	ID               *string `json:"id"`
	DisplayName      *string `json:"displayName"`
	RefID            *string `json:"refId"`
	Description      *string `json:"description"`
	CreatedAt        *string `json:"createdAt"`
	UpdatedAt        *string `json:"updatedAt"`
	EnvironmentID    *string `json:"environmentId"`
	IsDefaultProduct *bool   `json:"isDefaultProduct"`
}

type ProductConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*ProductEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type ProductCountAggregate struct {
	ID               *int64 `json:"id"`
	DisplayName      *int64 `json:"displayName"`
	RefID            *int64 `json:"refId"`
	Description      *int64 `json:"description"`
	CreatedAt        *int64 `json:"createdAt"`
	UpdatedAt        *int64 `json:"updatedAt"`
	EnvironmentID    *int64 `json:"environmentId"`
	IsDefaultProduct *int64 `json:"isDefaultProduct"`
}

type ProductCreateInput struct {
	Description        *string                `json:"description,omitempty"`
	DisplayName        *string                `json:"displayName,omitempty"`
	RefID              string                 `json:"refId"`
	EnvironmentID      string                 `json:"environmentId"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
}

type ProductDeleteResponse struct {
	ID                 *string                `json:"id"`
	DisplayName        *string                `json:"displayName"`
	RefID              *string                `json:"refId"`
	Description        *string                `json:"description"`
	CreatedAt          *string                `json:"createdAt"`
	UpdatedAt          *string                `json:"updatedAt"`
	EnvironmentID      *string                `json:"environmentId"`
	IsDefaultProduct   *bool                  `json:"isDefaultProduct"`
	Plans              []*Plan                `json:"plans"`
	Addons             []*Addon               `json:"addons"`
	ProductSettings    *ProductSettings       `json:"productSettings"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
}

type ProductEdge struct {
	// The node containing the Product
	Node Product `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type ProductFilter struct {
	And              []*ProductFilter        `json:"and,omitempty"`
	Or               []*ProductFilter        `json:"or,omitempty"`
	ID               *StringFieldComparison  `json:"id,omitempty"`
	DisplayName      *StringFieldComparison  `json:"displayName,omitempty"`
	RefID            *StringFieldComparison  `json:"refId,omitempty"`
	Description      *StringFieldComparison  `json:"description,omitempty"`
	CreatedAt        *DateFieldComparison    `json:"createdAt,omitempty"`
	UpdatedAt        *DateFieldComparison    `json:"updatedAt,omitempty"`
	EnvironmentID    *StringFieldComparison  `json:"environmentId,omitempty"`
	IsDefaultProduct *BooleanFieldComparison `json:"isDefaultProduct,omitempty"`
}

type ProductMaxAggregate struct {
	ID            *string `json:"id"`
	DisplayName   *string `json:"displayName"`
	RefID         *string `json:"refId"`
	Description   *string `json:"description"`
	CreatedAt     *string `json:"createdAt"`
	UpdatedAt     *string `json:"updatedAt"`
	EnvironmentID *string `json:"environmentId"`
}

type ProductMinAggregate struct {
	ID            *string `json:"id"`
	DisplayName   *string `json:"displayName"`
	RefID         *string `json:"refId"`
	Description   *string `json:"description"`
	CreatedAt     *string `json:"createdAt"`
	UpdatedAt     *string `json:"updatedAt"`
	EnvironmentID *string `json:"environmentId"`
}

type ProductSettings struct {
	SubscriptionEndSetup         SubscriptionEndSetup         `json:"subscriptionEndSetup"`
	SubscriptionCancellationTime SubscriptionCancellationTime `json:"subscriptionCancellationTime"`
	DowngradePlan                *Plan                        `json:"downgradePlan"`
	DowngradePlanID              *string                      `json:"downgradePlanId"`
	SubscriptionStartSetup       SubscriptionStartSetup       `json:"subscriptionStartSetup"`
	SubscriptionStartPlan        *Plan                        `json:"subscriptionStartPlan"`
	SubscriptionStartPlanID      *string                      `json:"subscriptionStartPlanId"`
}

type ProductSettingsInput struct {
	SubscriptionEndSetup         SubscriptionEndSetup         `json:"subscriptionEndSetup"`
	SubscriptionCancellationTime SubscriptionCancellationTime `json:"subscriptionCancellationTime"`
	DowngradePlanID              *string                      `json:"downgradePlanId,omitempty"`
	SubscriptionStartSetup       SubscriptionStartSetup       `json:"subscriptionStartSetup"`
	SubscriptionStartPlanID      *string                      `json:"subscriptionStartPlanId,omitempty"`
}

type ProductSort struct {
	Field     ProductSortFields `json:"field"`
	Direction SortDirection     `json:"direction"`
	Nulls     *SortNulls        `json:"nulls,omitempty"`
}

type ProductUpdateInput struct {
	Description        *string                `json:"description,omitempty"`
	DisplayName        *string                `json:"displayName,omitempty"`
	ProductSettings    *ProductSettingsInput  `json:"productSettings,omitempty"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
}

type PromotionalEntitlement struct {
	ID                       string                       `json:"id"`
	Description              *string                      `json:"description"`
	FeatureID                string                       `json:"featureId"`
	CreatedAt                *string                      `json:"createdAt"`
	UpdatedAt                *string                      `json:"updatedAt"`
	StartDate                string                       `json:"startDate"`
	EndDate                  *string                      `json:"endDate"`
	IsVisible                bool                         `json:"isVisible"`
	UsageLimit               *float64                     `json:"usageLimit"`
	HasUnlimitedUsage        *bool                        `json:"hasUnlimitedUsage"`
	Unlimited                *bool                        `json:"unlimited"`
	Status                   PromotionalEntitlementStatus `json:"status"`
	Period                   PromotionalEntitlementPeriod `json:"period"`
	ResetPeriod              *EntitlementResetPeriod      `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration     `json:"resetPeriodConfiguration"`
	EnvironmentID            string                       `json:"environmentId"`
	Feature                  Feature                      `json:"feature"`
	Customer                 Customer                     `json:"customer"`
}

type PromotionalEntitlementAggregateGroupBy struct {
	ID            *string                       `json:"id"`
	CreatedAt     *string                       `json:"createdAt"`
	UpdatedAt     *string                       `json:"updatedAt"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	EnvironmentID *string                       `json:"environmentId"`
}

type PromotionalEntitlementConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*PromotionalEntitlementEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PromotionalEntitlementCountAggregate struct {
	ID            *int64 `json:"id"`
	CreatedAt     *int64 `json:"createdAt"`
	UpdatedAt     *int64 `json:"updatedAt"`
	Status        *int64 `json:"status"`
	EnvironmentID *int64 `json:"environmentId"`
}

type PromotionalEntitlementDeleteResponse struct {
	ID                       *string                       `json:"id"`
	Description              *string                       `json:"description"`
	FeatureID                *string                       `json:"featureId"`
	CreatedAt                *string                       `json:"createdAt"`
	UpdatedAt                *string                       `json:"updatedAt"`
	StartDate                *string                       `json:"startDate"`
	EndDate                  *string                       `json:"endDate"`
	IsVisible                *bool                         `json:"isVisible"`
	UsageLimit               *float64                      `json:"usageLimit"`
	HasUnlimitedUsage        *bool                         `json:"hasUnlimitedUsage"`
	Unlimited                *bool                         `json:"unlimited"`
	Status                   *PromotionalEntitlementStatus `json:"status"`
	Period                   *PromotionalEntitlementPeriod `json:"period"`
	ResetPeriod              *EntitlementResetPeriod       `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration      `json:"resetPeriodConfiguration"`
	EnvironmentID            *string                       `json:"environmentId"`
}

type PromotionalEntitlementEdge struct {
	// The node containing the PromotionalEntitlement
	Node PromotionalEntitlement `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type PromotionalEntitlementFilter struct {
	And           []*PromotionalEntitlementFilter               `json:"and,omitempty"`
	Or            []*PromotionalEntitlementFilter               `json:"or,omitempty"`
	ID            *StringFieldComparison                        `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
	Status        *PromotionalEntitlementStatusFilterComparison `json:"status,omitempty"`
	EnvironmentID *StringFieldComparison                        `json:"environmentId,omitempty"`
}

type PromotionalEntitlementInput struct {
	Description                     *string                        `json:"description,omitempty"`
	FeatureID                       string                         `json:"featureId"`
	CustomerID                      string                         `json:"customerId"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	EndDate                         *string                        `json:"endDate,omitempty"`
	Period                          PromotionalEntitlementPeriod   `json:"period"`
	IsVisible                       bool                           `json:"isVisible"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	EnvironmentID                   string                         `json:"environmentId"`
}

type PromotionalEntitlementMaxAggregate struct {
	ID            *string                       `json:"id"`
	CreatedAt     *string                       `json:"createdAt"`
	UpdatedAt     *string                       `json:"updatedAt"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	EnvironmentID *string                       `json:"environmentId"`
}

type PromotionalEntitlementMinAggregate struct {
	ID            *string                       `json:"id"`
	CreatedAt     *string                       `json:"createdAt"`
	UpdatedAt     *string                       `json:"updatedAt"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	EnvironmentID *string                       `json:"environmentId"`
}

type PromotionalEntitlementSort struct {
	Field     PromotionalEntitlementSortFields `json:"field"`
	Direction SortDirection                    `json:"direction"`
	Nulls     *SortNulls                       `json:"nulls,omitempty"`
}

type PromotionalEntitlementStatusFilterComparison struct {
	Is       *bool                          `json:"is,omitempty"`
	IsNot    *bool                          `json:"isNot,omitempty"`
	Eq       *PromotionalEntitlementStatus  `json:"eq,omitempty"`
	Neq      *PromotionalEntitlementStatus  `json:"neq,omitempty"`
	Gt       *PromotionalEntitlementStatus  `json:"gt,omitempty"`
	Gte      *PromotionalEntitlementStatus  `json:"gte,omitempty"`
	Lt       *PromotionalEntitlementStatus  `json:"lt,omitempty"`
	Lte      *PromotionalEntitlementStatus  `json:"lte,omitempty"`
	Like     *PromotionalEntitlementStatus  `json:"like,omitempty"`
	NotLike  *PromotionalEntitlementStatus  `json:"notLike,omitempty"`
	ILike    *PromotionalEntitlementStatus  `json:"iLike,omitempty"`
	NotILike *PromotionalEntitlementStatus  `json:"notILike,omitempty"`
	In       []PromotionalEntitlementStatus `json:"in,omitempty"`
	NotIn    []PromotionalEntitlementStatus `json:"notIn,omitempty"`
}

type PromotionalEntitlementUpdateInput struct {
	Description                     *string                        `json:"description,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	EndDate                         *string                        `json:"endDate,omitempty"`
	Period                          PromotionalEntitlementPeriod   `json:"period"`
	IsVisible                       bool                           `json:"isVisible"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
}

type ProvisionCustomerInput struct {
	Name                  *string                             `json:"name,omitempty"`
	Email                 *string                             `json:"email,omitempty"`
	RefID                 *string                             `json:"refId,omitempty"`
	CustomerID            *string                             `json:"customerId,omitempty"`
	EnvironmentID         *string                             `json:"environmentId,omitempty"`
	BillingID             *string                             `json:"billingId,omitempty"`
	CrmID                 *string                             `json:"crmId,omitempty"`
	CouponRefID           *string                             `json:"couponRefId,omitempty"`
	BillingInformation    *CustomerBillingInfo                `json:"billingInformation,omitempty"`
	AdditionalMetaData    map[string]interface{}              `json:"additionalMetaData,omitempty"`
	ShouldSyncFree        *bool                               `json:"shouldSyncFree,omitempty"`
	CreatedAt             *string                             `json:"createdAt,omitempty"`
	SubscriptionParams    *ProvisionCustomerSubscriptionInput `json:"subscriptionParams,omitempty"`
	ExcludeFromExperiment *bool                               `json:"excludeFromExperiment,omitempty"`
}

type ProvisionCustomerSubscriptionInput struct {
	PlanID                   string                    `json:"planId"`
	BillingPeriod            *BillingPeriod            `json:"billingPeriod,omitempty"`
	PriceUnitAmount          *float64                  `json:"priceUnitAmount,omitempty"`
	Addons                   []*SubscriptionAddonInput `json:"addons,omitempty"`
	StartDate                *string                   `json:"startDate,omitempty"`
	RefID                    *string                   `json:"refId,omitempty"`
	AdditionalMetaData       map[string]interface{}    `json:"additionalMetaData,omitempty"`
	AwaitPaymentConfirmation *bool                     `json:"awaitPaymentConfirmation,omitempty"`
	BillingInformation       *SubscriptionBillingInfo  `json:"billingInformation,omitempty"`
	SubscriptionID           *string                   `json:"subscriptionId,omitempty"`
}

type ProvisionSubscriptionInput struct {
	PlanID                   string                    `json:"planId"`
	BillingPeriod            *BillingPeriod            `json:"billingPeriod,omitempty"`
	PriceUnitAmount          *float64                  `json:"priceUnitAmount,omitempty"`
	Addons                   []*SubscriptionAddonInput `json:"addons,omitempty"`
	StartDate                *string                   `json:"startDate,omitempty"`
	RefID                    *string                   `json:"refId,omitempty"`
	AdditionalMetaData       map[string]interface{}    `json:"additionalMetaData,omitempty"`
	AwaitPaymentConfirmation *bool                     `json:"awaitPaymentConfirmation,omitempty"`
	BillingInformation       *SubscriptionBillingInfo  `json:"billingInformation,omitempty"`
	SubscriptionID           *string                   `json:"subscriptionId,omitempty"`
	CustomerID               string                    `json:"customerId"`
	SkipTrial                *bool                     `json:"skipTrial,omitempty"`
	CheckoutOptions          *CheckoutOptions          `json:"checkoutOptions,omitempty"`
}

type ProvisionSubscriptionResult struct {
	ID                string                      `json:"id"`
	Status            ProvisionSubscriptionStatus `json:"status"`
	CheckoutBillingID *string                     `json:"checkoutBillingId"`
	CheckoutURL       *string                     `json:"checkoutUrl"`
	Subscription      *CustomerSubscription       `json:"subscription"`
}

type ProvisionedCustomer struct {
	Customer                     Customer                     `json:"customer"`
	SubscriptionStrategyDecision SubscriptionDecisionStrategy `json:"subscriptionStrategyDecision"`
	SubscriptionDecisionStrategy SubscriptionDecisionStrategy `json:"subscriptionDecisionStrategy"`
	Subscription                 *CustomerSubscription        `json:"subscription"`
}

type PublishPackageResult struct {
	TaskID *string `json:"taskId"`
}

type RemoveBasePlanFromPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveCompatibleAddonsFromPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type RemoveCouponFromCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveCouponFromCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveExperimentFromCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveExperimentFromCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type ResyncIntegrationInput struct {
	EnvironmentID    string           `json:"environmentId"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

type ResyncIntegrationResult struct {
	TaskID string `json:"taskId"`
}

type SdkConfiguration struct {
	SentryDsn                *string `json:"sentryDsn"`
	IsWidgetWatermarkEnabled *bool   `json:"isWidgetWatermarkEnabled"`
}

type SetBasePlanOnPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetCompatibleAddonsOnPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type SetCouponOnCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetCouponOnCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetExperimentOnCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetExperimentOnCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type StartExperimentInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	RefID         string  `json:"refId"`
}

type StopExperimentInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	RefID         string  `json:"refId"`
}

type StringChangeDto struct {
	Before     *string     `json:"before"`
	After      *string     `json:"after"`
	ChangeType *ChangeType `json:"changeType"`
}

type StringFieldComparison struct {
	Is       *bool    `json:"is,omitempty"`
	IsNot    *bool    `json:"isNot,omitempty"`
	Eq       *string  `json:"eq,omitempty"`
	Neq      *string  `json:"neq,omitempty"`
	Gt       *string  `json:"gt,omitempty"`
	Gte      *string  `json:"gte,omitempty"`
	Lt       *string  `json:"lt,omitempty"`
	Lte      *string  `json:"lte,omitempty"`
	Like     *string  `json:"like,omitempty"`
	NotLike  *string  `json:"notLike,omitempty"`
	ILike    *string  `json:"iLike,omitempty"`
	NotILike *string  `json:"notILike,omitempty"`
	In       []string `json:"in,omitempty"`
	NotIn    []string `json:"notIn,omitempty"`
}

type StripeCredentials struct {
	AccountID          string `json:"accountId"`
	IsTestMode         bool   `json:"isTestMode"`
	AccountDisplayName string `json:"accountDisplayName"`
}

func (StripeCredentials) IsCredentials() {}

type StripeCredentialsInput struct {
	AuthorizationCode string  `json:"authorizationCode"`
	IsTestMode        bool    `json:"isTestMode"`
	AccountID         *string `json:"accountId,omitempty"`
}

type StripeCustomer struct {
	ID                   string  `json:"id"`
	Name                 string  `json:"name"`
	Email                string  `json:"email"`
	SubscriptionsCount   float64 `json:"subscriptionsCount"`
	SubscriptionPlanName *string `json:"subscriptionPlanName"`
	CreatedAt            string  `json:"createdAt"`
	IsSynced             bool    `json:"isSynced"`
	EnvironmentID        *string `json:"environmentId"`
}

type StripeCustomerIsDeleted struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	BillingID         string `json:"billingId"`
}

type StripeCustomerSearchInput struct {
	EnvironmentID string  `json:"environmentId"`
	NextPage      *string `json:"nextPage,omitempty"`
	CustomerName  *string `json:"customerName,omitempty"`
}

type StripeCustomerSearchResult struct {
	Customers  []*StripeCustomer `json:"customers"`
	TotalCount int64             `json:"totalCount"`
	NextPage   *string           `json:"nextPage"`
}

type StripeProduct struct {
	ID                    string                `json:"id"`
	Name                  string                `json:"name"`
	Prices                []*StripeProductPrice `json:"prices"`
	NotSupportedForImport bool                  `json:"notSupportedForImport"`
	UpdatedAt             string                `json:"updatedAt"`
	IsSynced              bool                  `json:"isSynced"`
	EnvironmentID         *string               `json:"environmentId"`
}

type StripeProductPrice struct {
	Amount        float64        `json:"amount"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
}

type StripeProductSearchInput struct {
	EnvironmentID string  `json:"environmentId"`
	NextPage      *string `json:"nextPage,omitempty"`
	ProductName   *string `json:"productName,omitempty"`
}

type StripeProductSearchResult struct {
	Products                 []*StripeProduct `json:"products"`
	TotalCount               int64            `json:"totalCount"`
	NextPage                 *string          `json:"nextPage"`
	UsageBasedProductPresent *bool            `json:"usageBasedProductPresent"`
}

type StripeSubscription struct {
	ID string `json:"id"`
}

type StripeSubscriptionSearchInput struct {
	EnvironmentID string  `json:"environmentId"`
	NextPage      *string `json:"nextPage,omitempty"`
}

type StripeSubscriptionSearchResult struct {
	Subscriptions []*StripeSubscription `json:"subscriptions"`
	TotalCount    int64                 `json:"totalCount"`
	NextPage      *string               `json:"nextPage"`
}

type Subscription struct {
	EntitlementsUpdated EntitlementsUpdated `json:"entitlementsUpdated"`
	UsageUpdated        UsageUpdated        `json:"usageUpdated"`
}

type SubscriptionAddon struct {
	ID           string               `json:"id"`
	Quantity     float64              `json:"quantity"`
	UpdatedAt    string               `json:"updatedAt"`
	CreatedAt    *string              `json:"createdAt"`
	Subscription CustomerSubscription `json:"subscription"`
	Addon        Addon                `json:"addon"`
	Price        *Price               `json:"price"`
}

type SubscriptionAddonAggregateGroupBy struct {
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
	CreatedAt *string  `json:"createdAt"`
}

type SubscriptionAddonAvgAggregate struct {
	Quantity *float64 `json:"quantity"`
}

type SubscriptionAddonCountAggregate struct {
	ID        *int64 `json:"id"`
	Quantity  *int64 `json:"quantity"`
	UpdatedAt *int64 `json:"updatedAt"`
	CreatedAt *int64 `json:"createdAt"`
}

type SubscriptionAddonEdge struct {
	// The node containing the SubscriptionAddon
	Node SubscriptionAddon `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type SubscriptionAddonFilter struct {
	And          []*SubscriptionAddonFilter                         `json:"and,omitempty"`
	Or           []*SubscriptionAddonFilter                         `json:"or,omitempty"`
	ID           *StringFieldComparison                             `json:"id,omitempty"`
	Quantity     *NumberFieldComparison                             `json:"quantity,omitempty"`
	UpdatedAt    *DateFieldComparison                               `json:"updatedAt,omitempty"`
	CreatedAt    *DateFieldComparison                               `json:"createdAt,omitempty"`
	Price        *SubscriptionAddonFilterPriceFilter                `json:"price,omitempty"`
	Addon        *SubscriptionAddonFilterAddonFilter                `json:"addon,omitempty"`
	Subscription *SubscriptionAddonFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
}

type SubscriptionAddonFilterAddonFilter struct {
	And           []*SubscriptionAddonFilterAddonFilter `json:"and,omitempty"`
	Or            []*SubscriptionAddonFilterAddonFilter `json:"or,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison                  `json:"updatedAt,omitempty"`
	RefID         *StringFieldComparison                `json:"refId,omitempty"`
	BillingID     *StringFieldComparison                `json:"billingId,omitempty"`
	DisplayName   *StringFieldComparison                `json:"displayName,omitempty"`
	Status        *PackageStatusFilterComparison        `json:"status,omitempty"`
	PricingType   *PricingTypeFilterComparison          `json:"pricingType,omitempty"`
	Description   *StringFieldComparison                `json:"description,omitempty"`
	EnvironmentID *StringFieldComparison                `json:"environmentId,omitempty"`
	ProductID     *StringFieldComparison                `json:"productId,omitempty"`
	IsLatest      *BooleanFieldComparison               `json:"isLatest,omitempty"`
	VersionNumber *IntFieldComparison                   `json:"versionNumber,omitempty"`
}

type SubscriptionAddonFilterCustomerSubscriptionFilter struct {
	And              []*SubscriptionAddonFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	Or               []*SubscriptionAddonFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	EnvironmentID    *StringFieldComparison                               `json:"environmentId,omitempty"`
	ID               *StringFieldComparison                               `json:"id,omitempty"`
	CreatedAt        *DateFieldComparison                                 `json:"createdAt,omitempty"`
	StartDate        *DateFieldComparison                                 `json:"startDate,omitempty"`
	EndDate          *DateFieldComparison                                 `json:"endDate,omitempty"`
	CancellationDate *DateFieldComparison                                 `json:"cancellationDate,omitempty"`
	TrialEndDate     *DateFieldComparison                                 `json:"trialEndDate,omitempty"`
	EffectiveEndDate *DateFieldComparison                                 `json:"effectiveEndDate,omitempty"`
	BillingID        *StringFieldComparison                               `json:"billingId,omitempty"`
	CrmID            *StringFieldComparison                               `json:"crmId,omitempty"`
	CrmLinkURL       *StringFieldComparison                               `json:"crmLinkUrl,omitempty"`
	Status           *SubscriptionStatusFilterComparison                  `json:"status,omitempty"`
	CancelReason     *SubscriptionCancelReasonFilterComparison            `json:"cancelReason,omitempty"`
	RefID            *StringFieldComparison                               `json:"refId,omitempty"`
	SubscriptionID   *StringFieldComparison                               `json:"subscriptionId,omitempty"`
	PricingType      *PricingTypeFilterComparison                         `json:"pricingType,omitempty"`
}

type SubscriptionAddonFilterPriceFilter struct {
	And           []*SubscriptionAddonFilterPriceFilter `json:"and,omitempty"`
	Or            []*SubscriptionAddonFilterPriceFilter `json:"or,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	BillingPeriod *BillingPeriodFilterComparison        `json:"billingPeriod,omitempty"`
	BillingModel  *BillingModelFilterComparison         `json:"billingModel,omitempty"`
}

type SubscriptionAddonInput struct {
	AddonID  string `json:"addonId"`
	Quantity *int64 `json:"quantity,omitempty"`
}

type SubscriptionAddonMaxAggregate struct {
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
	CreatedAt *string  `json:"createdAt"`
}

type SubscriptionAddonMinAggregate struct {
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
	CreatedAt *string  `json:"createdAt"`
}

type SubscriptionAddonSort struct {
	Field     SubscriptionAddonSortFields `json:"field"`
	Direction SortDirection               `json:"direction"`
	Nulls     *SortNulls                  `json:"nulls,omitempty"`
}

type SubscriptionAddonSumAggregate struct {
	Quantity *float64 `json:"quantity"`
}

type SubscriptionAlreadyCanceledOrExpired struct {
	Code              string             `json:"code"`
	IsValidationError bool               `json:"isValidationError"`
	RefID             string             `json:"refId"`
	Status            SubscriptionStatus `json:"status"`
}

type SubscriptionBillingInfo struct {
	TaxRateIds []string `json:"taxRateIds,omitempty"`
}

type SubscriptionCancelReasonFilterComparison struct {
	Is       *bool                      `json:"is,omitempty"`
	IsNot    *bool                      `json:"isNot,omitempty"`
	Eq       *SubscriptionCancelReason  `json:"eq,omitempty"`
	Neq      *SubscriptionCancelReason  `json:"neq,omitempty"`
	Gt       *SubscriptionCancelReason  `json:"gt,omitempty"`
	Gte      *SubscriptionCancelReason  `json:"gte,omitempty"`
	Lt       *SubscriptionCancelReason  `json:"lt,omitempty"`
	Lte      *SubscriptionCancelReason  `json:"lte,omitempty"`
	Like     *SubscriptionCancelReason  `json:"like,omitempty"`
	NotLike  *SubscriptionCancelReason  `json:"notLike,omitempty"`
	ILike    *SubscriptionCancelReason  `json:"iLike,omitempty"`
	NotILike *SubscriptionCancelReason  `json:"notILike,omitempty"`
	In       []SubscriptionCancelReason `json:"in,omitempty"`
	NotIn    []SubscriptionCancelReason `json:"notIn,omitempty"`
}

type SubscriptionCancellationInput struct {
	SubscriptionRefID            string                        `json:"subscriptionRefId"`
	EnvironmentID                *string                       `json:"environmentId,omitempty"`
	SubscriptionCancellationTime *SubscriptionCancellationTime `json:"subscriptionCancellationTime,omitempty"`
	EndDate                      *string                       `json:"endDate,omitempty"`
}

type SubscriptionCoupon struct {
	ID            string     `json:"id"`
	Name          string     `json:"name"`
	RefID         string     `json:"refId"`
	EnvironmentID string     `json:"environmentId"`
	Type          CouponType `json:"type"`
	DiscountValue float64    `json:"discountValue"`
}

type SubscriptionInput struct {
	PlanID                    string                    `json:"planId"`
	BillingPeriod             *BillingPeriod            `json:"billingPeriod,omitempty"`
	PriceUnitAmount           *float64                  `json:"priceUnitAmount,omitempty"`
	Addons                    []*SubscriptionAddonInput `json:"addons,omitempty"`
	StartDate                 *string                   `json:"startDate,omitempty"`
	RefID                     *string                   `json:"refId,omitempty"`
	AdditionalMetaData        map[string]interface{}    `json:"additionalMetaData,omitempty"`
	AwaitPaymentConfirmation  *bool                     `json:"awaitPaymentConfirmation,omitempty"`
	BillingInformation        *SubscriptionBillingInfo  `json:"billingInformation,omitempty"`
	SubscriptionID            *string                   `json:"subscriptionId,omitempty"`
	CustomerID                string                    `json:"customerId"`
	BillingID                 *string                   `json:"billingId,omitempty"`
	CrmID                     *string                   `json:"crmId,omitempty"`
	IsTrial                   *bool                     `json:"isTrial,omitempty"`
	IsOverridingTrialConfig   *bool                     `json:"isOverridingTrialConfig,omitempty"`
	IsCustomPriceSubscription *bool                     `json:"isCustomPriceSubscription,omitempty"`
	EndDate                   *string                   `json:"endDate,omitempty"`
	EnvironmentID             *string                   `json:"environmentId,omitempty"`
}

type SubscriptionMigrationInput struct {
	SubscriptionID string `json:"subscriptionId"`
}

type SubscriptionMigrationTask struct {
	ID                     string        `json:"id"`
	EnvironmentID          string        `json:"environmentId"`
	CreatedAt              *string       `json:"createdAt"`
	TaskType               TaskType      `json:"taskType"`
	Status                 TaskStatus    `json:"status"`
	StartDate              string        `json:"startDate"`
	EndDate                *string       `json:"endDate"`
	Progress               int64         `json:"progress"`
	InitiatedPackageID     *string       `json:"initiatedPackageId"`
	AffectedCustomersCount int64         `json:"affectedCustomersCount"`
	Packages               []*PackageDto `json:"packages"`
}

type SubscriptionMigrationTaskAggregateGroupBy struct {
	ID            *string     `json:"id"`
	EnvironmentID *string     `json:"environmentId"`
	CreatedAt     *string     `json:"createdAt"`
	TaskType      *TaskType   `json:"taskType"`
	Status        *TaskStatus `json:"status"`
}

type SubscriptionMigrationTaskConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*SubscriptionMigrationTaskEdge `json:"edges"`
}

type SubscriptionMigrationTaskCountAggregate struct {
	ID            *int64 `json:"id"`
	EnvironmentID *int64 `json:"environmentId"`
	CreatedAt     *int64 `json:"createdAt"`
	TaskType      *int64 `json:"taskType"`
	Status        *int64 `json:"status"`
}

type SubscriptionMigrationTaskEdge struct {
	// The node containing the SubscriptionMigrationTask
	Node SubscriptionMigrationTask `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type SubscriptionMigrationTaskFilter struct {
	And           []*SubscriptionMigrationTaskFilter `json:"and,omitempty"`
	Or            []*SubscriptionMigrationTaskFilter `json:"or,omitempty"`
	ID            *StringFieldComparison             `json:"id,omitempty"`
	EnvironmentID *StringFieldComparison             `json:"environmentId,omitempty"`
	CreatedAt     *DateFieldComparison               `json:"createdAt,omitempty"`
	TaskType      *TaskTypeFilterComparison          `json:"taskType,omitempty"`
	Status        *TaskStatusFilterComparison        `json:"status,omitempty"`
}

type SubscriptionMigrationTaskMaxAggregate struct {
	ID            *string     `json:"id"`
	EnvironmentID *string     `json:"environmentId"`
	CreatedAt     *string     `json:"createdAt"`
	TaskType      *TaskType   `json:"taskType"`
	Status        *TaskStatus `json:"status"`
}

type SubscriptionMigrationTaskMinAggregate struct {
	ID            *string     `json:"id"`
	EnvironmentID *string     `json:"environmentId"`
	CreatedAt     *string     `json:"createdAt"`
	TaskType      *TaskType   `json:"taskType"`
	Status        *TaskStatus `json:"status"`
}

type SubscriptionMigrationTaskSort struct {
	Field     SubscriptionMigrationTaskSortFields `json:"field"`
	Direction SortDirection                       `json:"direction"`
	Nulls     *SortNulls                          `json:"nulls,omitempty"`
}

type SubscriptionMustHaveSinglePlanError struct {
	Code              string   `json:"code"`
	IsValidationError bool     `json:"isValidationError"`
	RefIds            []string `json:"refIds"`
}

type SubscriptionPreview struct {
	SubTotal           Money                          `json:"subTotal"`
	Total              Money                          `json:"total"`
	BillingPeriodRange DateRange                      `json:"billingPeriodRange"`
	Proration          *SubscriptionPreviewProrations `json:"proration"`
}

type SubscriptionPreviewProrations struct {
	ProrationDate string `json:"prorationDate"`
	Credit        Money  `json:"credit"`
	Debit         Money  `json:"debit"`
}

type SubscriptionPrice struct {
	ID           string               `json:"id"`
	CreatedAt    *string              `json:"createdAt"`
	UpdatedAt    string               `json:"updatedAt"`
	UsageLimit   *float64             `json:"usageLimit"`
	Subscription CustomerSubscription `json:"subscription"`
	Price        *Price               `json:"price"`
}

type SubscriptionPriceAggregateGroupBy struct {
	ID         *string  `json:"id"`
	CreatedAt  *string  `json:"createdAt"`
	UpdatedAt  *string  `json:"updatedAt"`
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPriceAvgAggregate struct {
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPriceCountAggregate struct {
	ID         *int64 `json:"id"`
	CreatedAt  *int64 `json:"createdAt"`
	UpdatedAt  *int64 `json:"updatedAt"`
	UsageLimit *int64 `json:"usageLimit"`
}

type SubscriptionPriceEdge struct {
	// The node containing the SubscriptionPrice
	Node SubscriptionPrice `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type SubscriptionPriceFilter struct {
	And          []*SubscriptionPriceFilter                         `json:"and,omitempty"`
	Or           []*SubscriptionPriceFilter                         `json:"or,omitempty"`
	ID           *StringFieldComparison                             `json:"id,omitempty"`
	CreatedAt    *DateFieldComparison                               `json:"createdAt,omitempty"`
	UpdatedAt    *DateFieldComparison                               `json:"updatedAt,omitempty"`
	UsageLimit   *NumberFieldComparison                             `json:"usageLimit,omitempty"`
	Price        *SubscriptionPriceFilterPriceFilter                `json:"price,omitempty"`
	Subscription *SubscriptionPriceFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
}

type SubscriptionPriceFilterCustomerSubscriptionFilter struct {
	And              []*SubscriptionPriceFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	Or               []*SubscriptionPriceFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	EnvironmentID    *StringFieldComparison                               `json:"environmentId,omitempty"`
	ID               *StringFieldComparison                               `json:"id,omitempty"`
	CreatedAt        *DateFieldComparison                                 `json:"createdAt,omitempty"`
	StartDate        *DateFieldComparison                                 `json:"startDate,omitempty"`
	EndDate          *DateFieldComparison                                 `json:"endDate,omitempty"`
	CancellationDate *DateFieldComparison                                 `json:"cancellationDate,omitempty"`
	TrialEndDate     *DateFieldComparison                                 `json:"trialEndDate,omitempty"`
	EffectiveEndDate *DateFieldComparison                                 `json:"effectiveEndDate,omitempty"`
	BillingID        *StringFieldComparison                               `json:"billingId,omitempty"`
	CrmID            *StringFieldComparison                               `json:"crmId,omitempty"`
	CrmLinkURL       *StringFieldComparison                               `json:"crmLinkUrl,omitempty"`
	Status           *SubscriptionStatusFilterComparison                  `json:"status,omitempty"`
	CancelReason     *SubscriptionCancelReasonFilterComparison            `json:"cancelReason,omitempty"`
	RefID            *StringFieldComparison                               `json:"refId,omitempty"`
	SubscriptionID   *StringFieldComparison                               `json:"subscriptionId,omitempty"`
	PricingType      *PricingTypeFilterComparison                         `json:"pricingType,omitempty"`
}

type SubscriptionPriceFilterPriceFilter struct {
	And           []*SubscriptionPriceFilterPriceFilter `json:"and,omitempty"`
	Or            []*SubscriptionPriceFilterPriceFilter `json:"or,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	BillingPeriod *BillingPeriodFilterComparison        `json:"billingPeriod,omitempty"`
	BillingModel  *BillingModelFilterComparison         `json:"billingModel,omitempty"`
}

type SubscriptionPriceMaxAggregate struct {
	ID         *string  `json:"id"`
	CreatedAt  *string  `json:"createdAt"`
	UpdatedAt  *string  `json:"updatedAt"`
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPriceMinAggregate struct {
	ID         *string  `json:"id"`
	CreatedAt  *string  `json:"createdAt"`
	UpdatedAt  *string  `json:"updatedAt"`
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPriceSort struct {
	Field     SubscriptionPriceSortFields `json:"field"`
	Direction SortDirection               `json:"direction"`
	Nulls     *SortNulls                  `json:"nulls,omitempty"`
}

type SubscriptionPriceSumAggregate struct {
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionStatusFilterComparison struct {
	Is       *bool                `json:"is,omitempty"`
	IsNot    *bool                `json:"isNot,omitempty"`
	Eq       *SubscriptionStatus  `json:"eq,omitempty"`
	Neq      *SubscriptionStatus  `json:"neq,omitempty"`
	Gt       *SubscriptionStatus  `json:"gt,omitempty"`
	Gte      *SubscriptionStatus  `json:"gte,omitempty"`
	Lt       *SubscriptionStatus  `json:"lt,omitempty"`
	Lte      *SubscriptionStatus  `json:"lte,omitempty"`
	Like     *SubscriptionStatus  `json:"like,omitempty"`
	NotLike  *SubscriptionStatus  `json:"notLike,omitempty"`
	ILike    *SubscriptionStatus  `json:"iLike,omitempty"`
	NotILike *SubscriptionStatus  `json:"notILike,omitempty"`
	In       []SubscriptionStatus `json:"in,omitempty"`
	NotIn    []SubscriptionStatus `json:"notIn,omitempty"`
}

type SyncState struct {
	Status           SyncStatus       `json:"status"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
	Error            *string          `json:"error"`
}

type TaskStatusFilterComparison struct {
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Eq       *TaskStatus  `json:"eq,omitempty"`
	Neq      *TaskStatus  `json:"neq,omitempty"`
	Gt       *TaskStatus  `json:"gt,omitempty"`
	Gte      *TaskStatus  `json:"gte,omitempty"`
	Lt       *TaskStatus  `json:"lt,omitempty"`
	Lte      *TaskStatus  `json:"lte,omitempty"`
	Like     *TaskStatus  `json:"like,omitempty"`
	NotLike  *TaskStatus  `json:"notLike,omitempty"`
	ILike    *TaskStatus  `json:"iLike,omitempty"`
	NotILike *TaskStatus  `json:"notILike,omitempty"`
	In       []TaskStatus `json:"in,omitempty"`
	NotIn    []TaskStatus `json:"notIn,omitempty"`
}

type TaskTypeFilterComparison struct {
	Is       *bool      `json:"is,omitempty"`
	IsNot    *bool      `json:"isNot,omitempty"`
	Eq       *TaskType  `json:"eq,omitempty"`
	Neq      *TaskType  `json:"neq,omitempty"`
	Gt       *TaskType  `json:"gt,omitempty"`
	Gte      *TaskType  `json:"gte,omitempty"`
	Lt       *TaskType  `json:"lt,omitempty"`
	Lte      *TaskType  `json:"lte,omitempty"`
	Like     *TaskType  `json:"like,omitempty"`
	NotLike  *TaskType  `json:"notLike,omitempty"`
	ILike    *TaskType  `json:"iLike,omitempty"`
	NotILike *TaskType  `json:"notILike,omitempty"`
	In       []TaskType `json:"in,omitempty"`
	NotIn    []TaskType `json:"notIn,omitempty"`
}

type TaxExempt struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

type TestHook struct {
	TestHookEventType string `json:"testHookEventType"`
	TestHookPayload   string `json:"testHookPayload"`
}

type TestHookInput struct {
	EnvironmentID string       `json:"environmentId"`
	EndpointURL   string       `json:"endpointUrl"`
	HookEventType EventLogType `json:"hookEventType"`
}

type TestHookResult struct {
	ResponseStatusCode *float64 `json:"responseStatusCode"`
	ResponseStatusText *string  `json:"responseStatusText"`
	ResponsePayload    string   `json:"responsePayload"`
	ResponseSuccess    bool     `json:"responseSuccess"`
}

type TrialMinDateError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type TrialMustBeCancelledImmediately struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type TrialedPlan struct {
	ProductID    *string `json:"productId"`
	PlanID       *string `json:"planId"`
	PlanRefID    *string `json:"planRefId"`
	ProductRefID *string `json:"productRefId"`
}

type TypographyConfiguration struct {
	FontFamily *string      `json:"fontFamily"`
	H1         *FontVariant `json:"h1"`
	H2         *FontVariant `json:"h2"`
	H3         *FontVariant `json:"h3"`
	Body       *FontVariant `json:"body"`
}

type TypographyConfigurationInput struct {
	FontFamily *string           `json:"fontFamily,omitempty"`
	H1         *FontVariantInput `json:"h1,omitempty"`
	H2         *FontVariantInput `json:"h2,omitempty"`
	H3         *FontVariantInput `json:"h3,omitempty"`
	Body       *FontVariantInput `json:"body,omitempty"`
}

type UnPublishedPackageError struct {
	Code                   string   `json:"code"`
	PackageType            string   `json:"packageType"`
	NonPublishedPackageIds []string `json:"nonPublishedPackageIds"`
}

type UncompatibleSubscriptionAddonError struct {
	Code                string   `json:"code"`
	IsValidationError   bool     `json:"isValidationError"`
	PlanDisplayName     string   `json:"planDisplayName"`
	NonCompatibleAddons []string `json:"nonCompatibleAddons"`
}

type UnsupportedFeatureTypeError struct {
	Code        string `json:"code"`
	FeatureType string `json:"featureType"`
}

type UnsupportedVendorIdentifierError struct {
	Code             string `json:"code"`
	VendorIdentifier string `json:"vendorIdentifier"`
}

type UpdateAccountInput struct {
	ID                        string         `json:"id"`
	DisplayName               string         `json:"displayName"`
	Timezone                  *string        `json:"timezone,omitempty"`
	SubscriptionBillingAnchor *BillingAnchor `json:"subscriptionBillingAnchor,omitempty"`
}

type UpdateCouponInput struct {
	RefID              string                 `json:"refId"`
	Description        *string                `json:"description,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	Name               string                 `json:"name"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
}

type UpdateCustomerInput struct {
	RefID              *string                `json:"refId,omitempty"`
	CustomerID         *string                `json:"customerId,omitempty"`
	Name               *string                `json:"name,omitempty"`
	Email              *string                `json:"email,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	CrmID              *string                `json:"crmId,omitempty"`
	CouponRefID        *string                `json:"couponRefId,omitempty"`
	BillingInformation *CustomerBillingInfo   `json:"billingInformation,omitempty"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
}

type UpdateEntitlementsOrderDto struct {
	ID    string   `json:"id"`
	Order *float64 `json:"order"`
}

type UpdateEnvironment struct {
	ID              *string                     `json:"id,omitempty"`
	CreatedAt       *string                     `json:"createdAt,omitempty"`
	DisplayName     *string                     `json:"displayName,omitempty"`
	Description     *string                     `json:"description,omitempty"`
	Slug            *string                     `json:"slug,omitempty"`
	ProvisionStatus *EnvironmentProvisionStatus `json:"provisionStatus,omitempty"`
}

type UpdateExperimentInput struct {
	EnvironmentID     *string               `json:"environmentId,omitempty"`
	RefID             string                `json:"refId"`
	Description       *string               `json:"description,omitempty"`
	Name              *string               `json:"name,omitempty"`
	ProductID         *string               `json:"productId,omitempty"`
	VariantPercentage *float64              `json:"variantPercentage,omitempty"`
	ControlGroupName  *string               `json:"controlGroupName,omitempty"`
	VariantGroupName  *string               `json:"variantGroupName,omitempty"`
	ProductSettings   *ProductSettingsInput `json:"productSettings,omitempty"`
}

type UpdateFeature struct {
	ID                 *string        `json:"id,omitempty"`
	DisplayName        *string        `json:"displayName,omitempty"`
	RefID              *string        `json:"refId,omitempty"`
	CreatedAt          *string        `json:"createdAt,omitempty"`
	UpdatedAt          *string        `json:"updatedAt,omitempty"`
	FeatureUnits       *string        `json:"featureUnits,omitempty"`
	FeatureUnitsPlural *string        `json:"featureUnitsPlural,omitempty"`
	Description        *string        `json:"description,omitempty"`
	FeatureType        *FeatureType   `json:"featureType,omitempty"`
	MeterType          *MeterType     `json:"meterType,omitempty"`
	FeatureStatus      *FeatureStatus `json:"featureStatus,omitempty"`
	EnvironmentID      *string        `json:"environmentId,omitempty"`
}

type UpdateFeatureInput struct {
	FeatureUnits       *string `json:"featureUnits,omitempty"`
	FeatureUnitsPlural *string `json:"featureUnitsPlural,omitempty"`
	Description        *string `json:"description,omitempty"`
	EnvironmentID      string  `json:"environmentId"`
	DisplayName        *string `json:"displayName,omitempty"`
	RefID              string  `json:"refId"`
}

type UpdateHook struct {
	ID            *string        `json:"id,omitempty"`
	Description   *string        `json:"description,omitempty"`
	SecretKey     *string        `json:"secretKey,omitempty"`
	Endpoint      *string        `json:"endpoint,omitempty"`
	Status        *HookStatus    `json:"status,omitempty"`
	CreatedAt     *string        `json:"createdAt,omitempty"`
	EnvironmentID *string        `json:"environmentId,omitempty"`
	EventLogTypes []EventLogType `json:"eventLogTypes,omitempty"`
}

type UpdateIntegrationInput struct {
	VendorIdentifier  VendorIdentifier        `json:"vendorIdentifier"`
	ZuoraCredentials  *ZuoraCredentialsInput  `json:"zuoraCredentials,omitempty"`
	StripeCredentials *StripeCredentialsInput `json:"stripeCredentials,omitempty"`
}

type UpdateOneEnvironmentInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateEnvironment `json:"update"`
}

type UpdateOneFeatureInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateFeature `json:"update"`
}

type UpdateOneHookInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateHook `json:"update"`
}

type UpdateOneIntegrationInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateIntegrationInput `json:"update"`
}

type UpdateOnePackageEntitlementInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update PackageEntitlementUpdateInput `json:"update"`
}

type UpdateOneProductInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update ProductUpdateInput `json:"update"`
}

type UpdateOnePromotionalEntitlementInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update PromotionalEntitlementUpdateInput `json:"update"`
}

type UpdatePackageEntitlementOrderInput struct {
	EnvironmentID *string                                   `json:"environmentId,omitempty"`
	PackageID     string                                    `json:"packageId"`
	Entitlements  []*UpdatePackageEntitlementOrderItemInput `json:"entitlements"`
}

type UpdatePackageEntitlementOrderItemInput struct {
	ID    string   `json:"id"`
	Order *float64 `json:"order,omitempty"`
}

type UpdateSubscriptionInput struct {
	AdditionalMetaData map[string]interface{}    `json:"additionalMetaData,omitempty"`
	EnvironmentID      *string                   `json:"environmentId,omitempty"`
	UnitQuantity       *float64                  `json:"unitQuantity,omitempty"`
	RefID              *string                   `json:"refId,omitempty"`
	SubscriptionID     *string                   `json:"subscriptionId,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	TrialEndDate       *string                   `json:"trialEndDate,omitempty"`
}

type UsageHistory struct {
	StartDate         string                   `json:"startDate"`
	EndDate           *string                  `json:"endDate"`
	UsageMeasurements []*UsageMeasurementPoint `json:"usageMeasurements"`
}

type UsageHistoryInput struct {
	StartDate                       string                         `json:"startDate"`
	EndDate                         *string                        `json:"endDate,omitempty"`
	FeatureRefID                    string                         `json:"featureRefId"`
	CustomerRefID                   string                         `json:"customerRefId"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	EnvironmentID                   *string                        `json:"environmentId,omitempty"`
}

type UsageMeasurement struct {
	ID            string      `json:"id"`
	Value         float64     `json:"value"`
	FeatureID     string      `json:"featureId"`
	CustomerID    string      `json:"customerId"`
	EnvironmentID string      `json:"environmentId"`
	CreatedAt     string      `json:"createdAt"`
	Environment   Environment `json:"environment"`
	Feature       Feature     `json:"feature"`
	Customer      Customer    `json:"customer"`
}

type UsageMeasurementAggregateGroupBy struct {
	ID            *string `json:"id"`
	EnvironmentID *string `json:"environmentId"`
	CreatedAt     *string `json:"createdAt"`
}

type UsageMeasurementAvgAggregate struct {
	ID *float64 `json:"id"`
}

type UsageMeasurementConnection struct {
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Array of edges.
	Edges []*UsageMeasurementEdge `json:"edges"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type UsageMeasurementCountAggregate struct {
	ID            *int64 `json:"id"`
	EnvironmentID *int64 `json:"environmentId"`
	CreatedAt     *int64 `json:"createdAt"`
}

type UsageMeasurementCreateInput struct {
	Value         float64 `json:"value"`
	FeatureID     string  `json:"featureId"`
	CustomerID    string  `json:"customerId"`
	CreatedAt     *string `json:"createdAt,omitempty"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type UsageMeasurementEdge struct {
	// The node containing the UsageMeasurement
	Node UsageMeasurement `json:"node"`
	// Cursor for this node.
	Cursor string `json:"cursor"`
}

type UsageMeasurementFilter struct {
	And           []*UsageMeasurementFilter             `json:"and,omitempty"`
	Or            []*UsageMeasurementFilter             `json:"or,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	EnvironmentID *StringFieldComparison                `json:"environmentId,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	Customer      *UsageMeasurementFilterCustomerFilter `json:"customer,omitempty"`
	Feature       *UsageMeasurementFilterFeatureFilter  `json:"feature,omitempty"`
}

type UsageMeasurementFilterCustomerFilter struct {
	And                  []*UsageMeasurementFilterCustomerFilter `json:"and,omitempty"`
	Or                   []*UsageMeasurementFilterCustomerFilter `json:"or,omitempty"`
	ID                   *StringFieldComparison                  `json:"id,omitempty"`
	Name                 *StringFieldComparison                  `json:"name,omitempty"`
	Email                *StringFieldComparison                  `json:"email,omitempty"`
	RefID                *StringFieldComparison                  `json:"refId,omitempty"`
	CustomerID           *StringFieldComparison                  `json:"customerId,omitempty"`
	CreatedAt            *DateFieldComparison                    `json:"createdAt,omitempty"`
	UpdatedAt            *DateFieldComparison                    `json:"updatedAt,omitempty"`
	EnvironmentID        *StringFieldComparison                  `json:"environmentId,omitempty"`
	BillingID            *StringFieldComparison                  `json:"billingId,omitempty"`
	CrmID                *StringFieldComparison                  `json:"crmId,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                  `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                  `json:"crmHubspotCompanyUrl,omitempty"`
}

type UsageMeasurementFilterFeatureFilter struct {
	And           []*UsageMeasurementFilterFeatureFilter `json:"and,omitempty"`
	Or            []*UsageMeasurementFilterFeatureFilter `json:"or,omitempty"`
	ID            *StringFieldComparison                 `json:"id,omitempty"`
	DisplayName   *StringFieldComparison                 `json:"displayName,omitempty"`
	RefID         *StringFieldComparison                 `json:"refId,omitempty"`
	CreatedAt     *DateFieldComparison                   `json:"createdAt,omitempty"`
	UpdatedAt     *DateFieldComparison                   `json:"updatedAt,omitempty"`
	Description   *StringFieldComparison                 `json:"description,omitempty"`
	FeatureType   *FeatureTypeFilterComparison           `json:"featureType,omitempty"`
	MeterType     *MeterTypeFilterComparison             `json:"meterType,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison         `json:"featureStatus,omitempty"`
	EnvironmentID *StringFieldComparison                 `json:"environmentId,omitempty"`
}

type UsageMeasurementMaxAggregate struct {
	ID            *string `json:"id"`
	EnvironmentID *string `json:"environmentId"`
	CreatedAt     *string `json:"createdAt"`
}

type UsageMeasurementMinAggregate struct {
	ID            *string `json:"id"`
	EnvironmentID *string `json:"environmentId"`
	CreatedAt     *string `json:"createdAt"`
}

type UsageMeasurementPoint struct {
	Date         string  `json:"date"`
	Value        float64 `json:"value"`
	IsResetPoint *bool   `json:"isResetPoint"`
}

type UsageMeasurementSort struct {
	Field     UsageMeasurementSortFields `json:"field"`
	Direction SortDirection              `json:"direction"`
	Nulls     *SortNulls                 `json:"nulls,omitempty"`
}

type UsageMeasurementSumAggregate struct {
	ID *float64 `json:"id"`
}

type UsageMeasurementUpdated struct {
	CurrentUsage  float64  `json:"currentUsage"`
	FeatureID     string   `json:"featureId"`
	CustomerID    string   `json:"customerId"`
	EnvironmentID string   `json:"environmentId"`
	AccountID     string   `json:"accountId"`
	NextResetDate *float64 `json:"nextResetDate"`
}

type UsageUpdated struct {
	Usage       UsageMeasurementUpdated `json:"usage"`
	Entitlement Entitlement             `json:"entitlement"`
}

type User struct {
	ID              string    `json:"id"`
	Email           *string   `json:"email"`
	Name            *string   `json:"name"`
	ProfileImageURL *string   `json:"profileImageUrl"`
	LastSeenAt      *string   `json:"lastSeenAt"`
	Memberships     []*Member `json:"memberships"`
}

type VendorIdentifierFilterComparison struct {
	Is       *bool              `json:"is,omitempty"`
	IsNot    *bool              `json:"isNot,omitempty"`
	Eq       *VendorIdentifier  `json:"eq,omitempty"`
	Neq      *VendorIdentifier  `json:"neq,omitempty"`
	Gt       *VendorIdentifier  `json:"gt,omitempty"`
	Gte      *VendorIdentifier  `json:"gte,omitempty"`
	Lt       *VendorIdentifier  `json:"lt,omitempty"`
	Lte      *VendorIdentifier  `json:"lte,omitempty"`
	Like     *VendorIdentifier  `json:"like,omitempty"`
	NotLike  *VendorIdentifier  `json:"notLike,omitempty"`
	ILike    *VendorIdentifier  `json:"iLike,omitempty"`
	NotILike *VendorIdentifier  `json:"notILike,omitempty"`
	In       []VendorIdentifier `json:"in,omitempty"`
	NotIn    []VendorIdentifier `json:"notIn,omitempty"`
}

type WeeklyResetPeriodConfig struct {
	WeeklyAccordingTo *WeeklyAccordingTo `json:"weeklyAccordingTo"`
}

func (WeeklyResetPeriodConfig) IsResetPeriodConfiguration() {}

type WeeklyResetPeriodConfigInput struct {
	AccordingTo WeeklyAccordingTo `json:"accordingTo"`
}

type WidgetConfiguration struct {
	CustomerPortal *CustomerPortalConfiguration `json:"customerPortal"`
	Paywall        *PaywallConfiguration        `json:"paywall"`
}

type WidgetConfigurationUpdateInput struct {
	EnvironmentID               *string                           `json:"environmentId,omitempty"`
	PaywallConfiguration        *PaywallConfigurationInput        `json:"paywallConfiguration,omitempty"`
	CustomerPortalConfiguration *CustomerPortalConfigurationInput `json:"customerPortalConfiguration,omitempty"`
}

type ZuoraCredentials struct {
	BaseURL      string `json:"baseUrl"`
	ClientID     string `json:"clientId"`
	ClientSecret string `json:"clientSecret"`
}

func (ZuoraCredentials) IsCredentials() {}

type ZuoraCredentialsInput struct {
	BaseURL      string `json:"baseUrl"`
	ClientID     string `json:"clientId"`
	ClientSecret string `json:"clientSecret"`
}

type ExperimentInfo struct {
	ID        string              `json:"id"`
	Name      string              `json:"name"`
	Status    ExperimentStatus    `json:"status"`
	GroupType ExperimentGroupType `json:"groupType"`
	GroupName string              `json:"groupName"`
}

// DenyReason of get access policy
type AccessDeniedReason string

const (
	AccessDeniedReasonFeatureNotFound                    AccessDeniedReason = "FeatureNotFound"
	AccessDeniedReasonCustomerNotFound                   AccessDeniedReason = "CustomerNotFound"
	AccessDeniedReasonNoActiveSubscription               AccessDeniedReason = "NoActiveSubscription"
	AccessDeniedReasonNoFeatureEntitlementInSubscription AccessDeniedReason = "NoFeatureEntitlementInSubscription"
	AccessDeniedReasonRequestedUsageExceedingLimit       AccessDeniedReason = "RequestedUsageExceedingLimit"
	AccessDeniedReasonUnknown                            AccessDeniedReason = "Unknown"
)

var AllAccessDeniedReason = []AccessDeniedReason{
	AccessDeniedReasonFeatureNotFound,
	AccessDeniedReasonCustomerNotFound,
	AccessDeniedReasonNoActiveSubscription,
	AccessDeniedReasonNoFeatureEntitlementInSubscription,
	AccessDeniedReasonRequestedUsageExceedingLimit,
	AccessDeniedReasonUnknown,
}

func (e AccessDeniedReason) IsValid() bool {
	switch e {
	case AccessDeniedReasonFeatureNotFound, AccessDeniedReasonCustomerNotFound, AccessDeniedReasonNoActiveSubscription, AccessDeniedReasonNoFeatureEntitlementInSubscription, AccessDeniedReasonRequestedUsageExceedingLimit, AccessDeniedReasonUnknown:
		return true
	}
	return false
}

func (e AccessDeniedReason) String() string {
	return string(e)
}

func (e *AccessDeniedReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessDeniedReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessDeniedReason", str)
	}
	return nil
}

func (e AccessDeniedReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AddonSortFields string

const (
	AddonSortFieldsID            AddonSortFields = "id"
	AddonSortFieldsCreatedAt     AddonSortFields = "createdAt"
	AddonSortFieldsUpdatedAt     AddonSortFields = "updatedAt"
	AddonSortFieldsRefID         AddonSortFields = "refId"
	AddonSortFieldsBillingID     AddonSortFields = "billingId"
	AddonSortFieldsDisplayName   AddonSortFields = "displayName"
	AddonSortFieldsStatus        AddonSortFields = "status"
	AddonSortFieldsPricingType   AddonSortFields = "pricingType"
	AddonSortFieldsDescription   AddonSortFields = "description"
	AddonSortFieldsEnvironmentID AddonSortFields = "environmentId"
	AddonSortFieldsProductID     AddonSortFields = "productId"
	AddonSortFieldsIsLatest      AddonSortFields = "isLatest"
	AddonSortFieldsVersionNumber AddonSortFields = "versionNumber"
)

var AllAddonSortFields = []AddonSortFields{
	AddonSortFieldsID,
	AddonSortFieldsCreatedAt,
	AddonSortFieldsUpdatedAt,
	AddonSortFieldsRefID,
	AddonSortFieldsBillingID,
	AddonSortFieldsDisplayName,
	AddonSortFieldsStatus,
	AddonSortFieldsPricingType,
	AddonSortFieldsDescription,
	AddonSortFieldsEnvironmentID,
	AddonSortFieldsProductID,
	AddonSortFieldsIsLatest,
	AddonSortFieldsVersionNumber,
}

func (e AddonSortFields) IsValid() bool {
	switch e {
	case AddonSortFieldsID, AddonSortFieldsCreatedAt, AddonSortFieldsUpdatedAt, AddonSortFieldsRefID, AddonSortFieldsBillingID, AddonSortFieldsDisplayName, AddonSortFieldsStatus, AddonSortFieldsPricingType, AddonSortFieldsDescription, AddonSortFieldsEnvironmentID, AddonSortFieldsProductID, AddonSortFieldsIsLatest, AddonSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e AddonSortFields) String() string {
	return string(e)
}

func (e *AddonSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddonSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddonSortFields", str)
	}
	return nil
}

func (e AddonSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Alignment
type Alignment string

const (
	AlignmentLeft   Alignment = "LEFT"
	AlignmentCenter Alignment = "CENTER"
	AlignmentRight  Alignment = "RIGHT"
)

var AllAlignment = []Alignment{
	AlignmentLeft,
	AlignmentCenter,
	AlignmentRight,
}

func (e Alignment) IsValid() bool {
	switch e {
	case AlignmentLeft, AlignmentCenter, AlignmentRight:
		return true
	}
	return false
}

func (e Alignment) String() string {
	return string(e)
}

func (e *Alignment) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Alignment(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Alignment", str)
	}
	return nil
}

func (e Alignment) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type APIKeySortFields string

const (
	APIKeySortFieldsID APIKeySortFields = "id"
)

var AllAPIKeySortFields = []APIKeySortFields{
	APIKeySortFieldsID,
}

func (e APIKeySortFields) IsValid() bool {
	switch e {
	case APIKeySortFieldsID:
		return true
	}
	return false
}

func (e APIKeySortFields) String() string {
	return string(e)
}

func (e *APIKeySortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APIKeySortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApiKeySortFields", str)
	}
	return nil
}

func (e APIKeySortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type APIKeyType string

const (
	APIKeyTypeServer APIKeyType = "SERVER"
	APIKeyTypeClient APIKeyType = "CLIENT"
)

var AllAPIKeyType = []APIKeyType{
	APIKeyTypeServer,
	APIKeyTypeClient,
}

func (e APIKeyType) IsValid() bool {
	switch e {
	case APIKeyTypeServer, APIKeyTypeClient:
		return true
	}
	return false
}

func (e APIKeyType) String() string {
	return string(e)
}

func (e *APIKeyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APIKeyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApiKeyType", str)
	}
	return nil
}

func (e APIKeyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BillingAnchor string

const (
	BillingAnchorSubscriptionStart BillingAnchor = "SUBSCRIPTION_START"
	BillingAnchorStartOfTheMonth   BillingAnchor = "START_OF_THE_MONTH"
)

var AllBillingAnchor = []BillingAnchor{
	BillingAnchorSubscriptionStart,
	BillingAnchorStartOfTheMonth,
}

func (e BillingAnchor) IsValid() bool {
	switch e {
	case BillingAnchorSubscriptionStart, BillingAnchorStartOfTheMonth:
		return true
	}
	return false
}

func (e BillingAnchor) String() string {
	return string(e)
}

func (e *BillingAnchor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingAnchor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingAnchor", str)
	}
	return nil
}

func (e BillingAnchor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing model.
type BillingModel string

const (
	BillingModelFlatFee    BillingModel = "FLAT_FEE"
	BillingModelPerUnit    BillingModel = "PER_UNIT"
	BillingModelUsageBased BillingModel = "USAGE_BASED"
)

var AllBillingModel = []BillingModel{
	BillingModelFlatFee,
	BillingModelPerUnit,
	BillingModelUsageBased,
}

func (e BillingModel) IsValid() bool {
	switch e {
	case BillingModelFlatFee, BillingModelPerUnit, BillingModelUsageBased:
		return true
	}
	return false
}

func (e BillingModel) String() string {
	return string(e)
}

func (e *BillingModel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingModel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingModel", str)
	}
	return nil
}

func (e BillingModel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing period.
type BillingPeriod string

const (
	BillingPeriodMonthly  BillingPeriod = "MONTHLY"
	BillingPeriodAnnually BillingPeriod = "ANNUALLY"
)

var AllBillingPeriod = []BillingPeriod{
	BillingPeriodMonthly,
	BillingPeriodAnnually,
}

func (e BillingPeriod) IsValid() bool {
	switch e {
	case BillingPeriodMonthly, BillingPeriodAnnually:
		return true
	}
	return false
}

func (e BillingPeriod) String() string {
	return string(e)
}

func (e *BillingPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingPeriod", str)
	}
	return nil
}

func (e BillingPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChangeType string

const (
	ChangeTypeReordered ChangeType = "REORDERED"
	ChangeTypeModified  ChangeType = "MODIFIED"
	ChangeTypeAdded     ChangeType = "ADDED"
	ChangeTypeDeleted   ChangeType = "DELETED"
)

var AllChangeType = []ChangeType{
	ChangeTypeReordered,
	ChangeTypeModified,
	ChangeTypeAdded,
	ChangeTypeDeleted,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeReordered, ChangeTypeModified, ChangeTypeAdded, ChangeTypeDeleted:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CouponSortFields string

const (
	CouponSortFieldsID            CouponSortFields = "id"
	CouponSortFieldsName          CouponSortFields = "name"
	CouponSortFieldsRefID         CouponSortFields = "refId"
	CouponSortFieldsDescription   CouponSortFields = "description"
	CouponSortFieldsCreatedAt     CouponSortFields = "createdAt"
	CouponSortFieldsUpdatedAt     CouponSortFields = "updatedAt"
	CouponSortFieldsEnvironmentID CouponSortFields = "environmentId"
	CouponSortFieldsType          CouponSortFields = "type"
	CouponSortFieldsStatus        CouponSortFields = "status"
	CouponSortFieldsBillingID     CouponSortFields = "billingId"
)

var AllCouponSortFields = []CouponSortFields{
	CouponSortFieldsID,
	CouponSortFieldsName,
	CouponSortFieldsRefID,
	CouponSortFieldsDescription,
	CouponSortFieldsCreatedAt,
	CouponSortFieldsUpdatedAt,
	CouponSortFieldsEnvironmentID,
	CouponSortFieldsType,
	CouponSortFieldsStatus,
	CouponSortFieldsBillingID,
}

func (e CouponSortFields) IsValid() bool {
	switch e {
	case CouponSortFieldsID, CouponSortFieldsName, CouponSortFieldsRefID, CouponSortFieldsDescription, CouponSortFieldsCreatedAt, CouponSortFieldsUpdatedAt, CouponSortFieldsEnvironmentID, CouponSortFieldsType, CouponSortFieldsStatus, CouponSortFieldsBillingID:
		return true
	}
	return false
}

func (e CouponSortFields) String() string {
	return string(e)
}

func (e *CouponSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponSortFields", str)
	}
	return nil
}

func (e CouponSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the coupon
type CouponStatus string

const (
	CouponStatusActive   CouponStatus = "ACTIVE"
	CouponStatusArchived CouponStatus = "ARCHIVED"
)

var AllCouponStatus = []CouponStatus{
	CouponStatusActive,
	CouponStatusArchived,
}

func (e CouponStatus) IsValid() bool {
	switch e {
	case CouponStatusActive, CouponStatusArchived:
		return true
	}
	return false
}

func (e CouponStatus) String() string {
	return string(e)
}

func (e *CouponStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponStatus", str)
	}
	return nil
}

func (e CouponStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the coupon
type CouponType string

const (
	CouponTypeFixed      CouponType = "FIXED"
	CouponTypePercentage CouponType = "PERCENTAGE"
)

var AllCouponType = []CouponType{
	CouponTypeFixed,
	CouponTypePercentage,
}

func (e CouponType) IsValid() bool {
	switch e {
	case CouponTypeFixed, CouponTypePercentage:
		return true
	}
	return false
}

func (e CouponType) String() string {
	return string(e)
}

func (e *CouponType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponType", str)
	}
	return nil
}

func (e CouponType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Currency
type Currency string

const (
	CurrencyUsd Currency = "USD"
	CurrencyIls Currency = "ILS"
)

var AllCurrency = []Currency{
	CurrencyUsd,
	CurrencyIls,
}

func (e Currency) IsValid() bool {
	switch e {
	case CurrencyUsd, CurrencyIls:
		return true
	}
	return false
}

func (e Currency) String() string {
	return string(e)
}

func (e *Currency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Currency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Currency", str)
	}
	return nil
}

func (e Currency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerSortFields string

const (
	CustomerSortFieldsID                   CustomerSortFields = "id"
	CustomerSortFieldsName                 CustomerSortFields = "name"
	CustomerSortFieldsEmail                CustomerSortFields = "email"
	CustomerSortFieldsRefID                CustomerSortFields = "refId"
	CustomerSortFieldsCustomerID           CustomerSortFields = "customerId"
	CustomerSortFieldsCreatedAt            CustomerSortFields = "createdAt"
	CustomerSortFieldsUpdatedAt            CustomerSortFields = "updatedAt"
	CustomerSortFieldsEnvironmentID        CustomerSortFields = "environmentId"
	CustomerSortFieldsBillingID            CustomerSortFields = "billingId"
	CustomerSortFieldsCrmID                CustomerSortFields = "crmId"
	CustomerSortFieldsCrmHubspotCompanyID  CustomerSortFields = "crmHubspotCompanyId"
	CustomerSortFieldsCrmHubspotCompanyURL CustomerSortFields = "crmHubspotCompanyUrl"
)

var AllCustomerSortFields = []CustomerSortFields{
	CustomerSortFieldsID,
	CustomerSortFieldsName,
	CustomerSortFieldsEmail,
	CustomerSortFieldsRefID,
	CustomerSortFieldsCustomerID,
	CustomerSortFieldsCreatedAt,
	CustomerSortFieldsUpdatedAt,
	CustomerSortFieldsEnvironmentID,
	CustomerSortFieldsBillingID,
	CustomerSortFieldsCrmID,
	CustomerSortFieldsCrmHubspotCompanyID,
	CustomerSortFieldsCrmHubspotCompanyURL,
}

func (e CustomerSortFields) IsValid() bool {
	switch e {
	case CustomerSortFieldsID, CustomerSortFieldsName, CustomerSortFieldsEmail, CustomerSortFieldsRefID, CustomerSortFieldsCustomerID, CustomerSortFieldsCreatedAt, CustomerSortFieldsUpdatedAt, CustomerSortFieldsEnvironmentID, CustomerSortFieldsBillingID, CustomerSortFieldsCrmID, CustomerSortFieldsCrmHubspotCompanyID, CustomerSortFieldsCrmHubspotCompanyURL:
		return true
	}
	return false
}

func (e CustomerSortFields) String() string {
	return string(e)
}

func (e *CustomerSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSortFields", str)
	}
	return nil
}

func (e CustomerSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerSubscriptionSortFields string

const (
	CustomerSubscriptionSortFieldsEnvironmentID    CustomerSubscriptionSortFields = "environmentId"
	CustomerSubscriptionSortFieldsID               CustomerSubscriptionSortFields = "id"
	CustomerSubscriptionSortFieldsCreatedAt        CustomerSubscriptionSortFields = "createdAt"
	CustomerSubscriptionSortFieldsStartDate        CustomerSubscriptionSortFields = "startDate"
	CustomerSubscriptionSortFieldsEndDate          CustomerSubscriptionSortFields = "endDate"
	CustomerSubscriptionSortFieldsCancellationDate CustomerSubscriptionSortFields = "cancellationDate"
	CustomerSubscriptionSortFieldsTrialEndDate     CustomerSubscriptionSortFields = "trialEndDate"
	CustomerSubscriptionSortFieldsEffectiveEndDate CustomerSubscriptionSortFields = "effectiveEndDate"
	CustomerSubscriptionSortFieldsBillingID        CustomerSubscriptionSortFields = "billingId"
	CustomerSubscriptionSortFieldsCrmID            CustomerSubscriptionSortFields = "crmId"
	CustomerSubscriptionSortFieldsCrmLinkURL       CustomerSubscriptionSortFields = "crmLinkUrl"
	CustomerSubscriptionSortFieldsStatus           CustomerSubscriptionSortFields = "status"
	CustomerSubscriptionSortFieldsCancelReason     CustomerSubscriptionSortFields = "cancelReason"
	CustomerSubscriptionSortFieldsRefID            CustomerSubscriptionSortFields = "refId"
	CustomerSubscriptionSortFieldsSubscriptionID   CustomerSubscriptionSortFields = "subscriptionId"
	CustomerSubscriptionSortFieldsPricingType      CustomerSubscriptionSortFields = "pricingType"
)

var AllCustomerSubscriptionSortFields = []CustomerSubscriptionSortFields{
	CustomerSubscriptionSortFieldsEnvironmentID,
	CustomerSubscriptionSortFieldsID,
	CustomerSubscriptionSortFieldsCreatedAt,
	CustomerSubscriptionSortFieldsStartDate,
	CustomerSubscriptionSortFieldsEndDate,
	CustomerSubscriptionSortFieldsCancellationDate,
	CustomerSubscriptionSortFieldsTrialEndDate,
	CustomerSubscriptionSortFieldsEffectiveEndDate,
	CustomerSubscriptionSortFieldsBillingID,
	CustomerSubscriptionSortFieldsCrmID,
	CustomerSubscriptionSortFieldsCrmLinkURL,
	CustomerSubscriptionSortFieldsStatus,
	CustomerSubscriptionSortFieldsCancelReason,
	CustomerSubscriptionSortFieldsRefID,
	CustomerSubscriptionSortFieldsSubscriptionID,
	CustomerSubscriptionSortFieldsPricingType,
}

func (e CustomerSubscriptionSortFields) IsValid() bool {
	switch e {
	case CustomerSubscriptionSortFieldsEnvironmentID, CustomerSubscriptionSortFieldsID, CustomerSubscriptionSortFieldsCreatedAt, CustomerSubscriptionSortFieldsStartDate, CustomerSubscriptionSortFieldsEndDate, CustomerSubscriptionSortFieldsCancellationDate, CustomerSubscriptionSortFieldsTrialEndDate, CustomerSubscriptionSortFieldsEffectiveEndDate, CustomerSubscriptionSortFieldsBillingID, CustomerSubscriptionSortFieldsCrmID, CustomerSubscriptionSortFieldsCrmLinkURL, CustomerSubscriptionSortFieldsStatus, CustomerSubscriptionSortFieldsCancelReason, CustomerSubscriptionSortFieldsRefID, CustomerSubscriptionSortFieldsSubscriptionID, CustomerSubscriptionSortFieldsPricingType:
		return true
	}
	return false
}

func (e CustomerSubscriptionSortFields) String() string {
	return string(e)
}

func (e *CustomerSubscriptionSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSubscriptionSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSubscriptionSortFields", str)
	}
	return nil
}

func (e CustomerSubscriptionSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Entitlement reset period.
type EntitlementResetPeriod string

const (
	EntitlementResetPeriodMonth EntitlementResetPeriod = "MONTH"
	EntitlementResetPeriodWeek  EntitlementResetPeriod = "WEEK"
	EntitlementResetPeriodDay   EntitlementResetPeriod = "DAY"
	EntitlementResetPeriodHour  EntitlementResetPeriod = "HOUR"
)

var AllEntitlementResetPeriod = []EntitlementResetPeriod{
	EntitlementResetPeriodMonth,
	EntitlementResetPeriodWeek,
	EntitlementResetPeriodDay,
	EntitlementResetPeriodHour,
}

func (e EntitlementResetPeriod) IsValid() bool {
	switch e {
	case EntitlementResetPeriodMonth, EntitlementResetPeriodWeek, EntitlementResetPeriodDay, EntitlementResetPeriodHour:
		return true
	}
	return false
}

func (e EntitlementResetPeriod) String() string {
	return string(e)
}

func (e *EntitlementResetPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitlementResetPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitlementResetPeriod", str)
	}
	return nil
}

func (e EntitlementResetPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntitySelectionMode string

const (
	EntitySelectionModeBlackList EntitySelectionMode = "BLACK_LIST"
	EntitySelectionModeWhiteList EntitySelectionMode = "WHITE_LIST"
)

var AllEntitySelectionMode = []EntitySelectionMode{
	EntitySelectionModeBlackList,
	EntitySelectionModeWhiteList,
}

func (e EntitySelectionMode) IsValid() bool {
	switch e {
	case EntitySelectionModeBlackList, EntitySelectionModeWhiteList:
		return true
	}
	return false
}

func (e EntitySelectionMode) String() string {
	return string(e)
}

func (e *EntitySelectionMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitySelectionMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitySelectionMode", str)
	}
	return nil
}

func (e EntitySelectionMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// EnvironmentProvisionStatus.
type EnvironmentProvisionStatus string

const (
	EnvironmentProvisionStatusNotProvisioned EnvironmentProvisionStatus = "NOT_PROVISIONED"
	EnvironmentProvisionStatusInProgress     EnvironmentProvisionStatus = "IN_PROGRESS"
	EnvironmentProvisionStatusFailed         EnvironmentProvisionStatus = "FAILED"
	EnvironmentProvisionStatusDone           EnvironmentProvisionStatus = "DONE"
)

var AllEnvironmentProvisionStatus = []EnvironmentProvisionStatus{
	EnvironmentProvisionStatusNotProvisioned,
	EnvironmentProvisionStatusInProgress,
	EnvironmentProvisionStatusFailed,
	EnvironmentProvisionStatusDone,
}

func (e EnvironmentProvisionStatus) IsValid() bool {
	switch e {
	case EnvironmentProvisionStatusNotProvisioned, EnvironmentProvisionStatusInProgress, EnvironmentProvisionStatusFailed, EnvironmentProvisionStatusDone:
		return true
	}
	return false
}

func (e EnvironmentProvisionStatus) String() string {
	return string(e)
}

func (e *EnvironmentProvisionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentProvisionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentProvisionStatus", str)
	}
	return nil
}

func (e EnvironmentProvisionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EnvironmentSortFields string

const (
	EnvironmentSortFieldsID          EnvironmentSortFields = "id"
	EnvironmentSortFieldsCreatedAt   EnvironmentSortFields = "createdAt"
	EnvironmentSortFieldsDisplayName EnvironmentSortFields = "displayName"
	EnvironmentSortFieldsSlug        EnvironmentSortFields = "slug"
)

var AllEnvironmentSortFields = []EnvironmentSortFields{
	EnvironmentSortFieldsID,
	EnvironmentSortFieldsCreatedAt,
	EnvironmentSortFieldsDisplayName,
	EnvironmentSortFieldsSlug,
}

func (e EnvironmentSortFields) IsValid() bool {
	switch e {
	case EnvironmentSortFieldsID, EnvironmentSortFieldsCreatedAt, EnvironmentSortFieldsDisplayName, EnvironmentSortFieldsSlug:
		return true
	}
	return false
}

func (e EnvironmentSortFields) String() string {
	return string(e)
}

func (e *EnvironmentSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentSortFields", str)
	}
	return nil
}

func (e EnvironmentSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// error codes
type ErrorCode string

const (
	ErrorCodeRateLimitExceeded                                ErrorCode = "RateLimitExceeded"
	ErrorCodeBadUserInput                                     ErrorCode = "BadUserInput"
	ErrorCodeUnauthenticated                                  ErrorCode = "Unauthenticated"
	ErrorCodeCustomerNotFound                                 ErrorCode = "CustomerNotFound"
	ErrorCodeFeatureNotFound                                  ErrorCode = "FeatureNotFound"
	ErrorCodeDuplicatedEntityNotAllowed                       ErrorCode = "DuplicatedEntityNotAllowed"
	ErrorCodeIntegrityViolation                               ErrorCode = "IntegrityViolation"
	ErrorCodeMemberNotFound                                   ErrorCode = "MemberNotFound"
	ErrorCodePlanNotFound                                     ErrorCode = "PlanNotFound"
	ErrorCodeSubscriptionMustHaveSinglePlanError              ErrorCode = "SubscriptionMustHaveSinglePlanError"
	ErrorCodeAddonNotFound                                    ErrorCode = "AddonNotFound"
	ErrorCodeEnvironmentMissing                               ErrorCode = "EnvironmentMissing"
	ErrorCodeEntityIDDifferentFromRefIDError                  ErrorCode = "EntityIdDifferentFromRefIdError"
	ErrorCodeUnsupportedFeatureType                           ErrorCode = "UnsupportedFeatureType"
	ErrorCodeUnsupportedVendorIdentifier                      ErrorCode = "UnsupportedVendorIdentifier"
	ErrorCodeInvalidEntitlementResetPeriod                    ErrorCode = "InvalidEntitlementResetPeriod"
	ErrorCodeUncompatibleSubscriptionAddon                    ErrorCode = "UncompatibleSubscriptionAddon"
	ErrorCodeUnPublishedPackage                               ErrorCode = "UnPublishedPackage"
	ErrorCodeMeteringNotAvailableForFeatureType               ErrorCode = "MeteringNotAvailableForFeatureType"
	ErrorCodeIdentityForbidden                                ErrorCode = "IdentityForbidden"
	ErrorCodeMemberInvitationError                            ErrorCode = "MemberInvitationError"
	ErrorCodeInvalidUsageValueForIncrementalFeatureError      ErrorCode = "InvalidUsageValueForIncrementalFeatureError"
	ErrorCodeUnexpectedError                                  ErrorCode = "UnexpectedError"
	ErrorCodePlanAlreadyExtended                              ErrorCode = "PlanAlreadyExtended"
	ErrorCodePlansCircularDependencyError                     ErrorCode = "PlansCircularDependencyError"
	ErrorCodeNoFeatureEntitlementInSubscription               ErrorCode = "NoFeatureEntitlementInSubscription"
	ErrorCodeCheckoutIsNotSupported                           ErrorCode = "CheckoutIsNotSupported"
	ErrorCodePriceNotFound                                    ErrorCode = "PriceNotFound"
	ErrorCodeInvalidMemberDelete                              ErrorCode = "InvalidMemberDelete"
	ErrorCodePackageAlreadyPublished                          ErrorCode = "PackageAlreadyPublished"
	ErrorCodeSubscriptionNotFound                             ErrorCode = "SubscriptionNotFound"
	ErrorCodeDraftPlanCantBeArchived                          ErrorCode = "DraftPlanCantBeArchived"
	ErrorCodePlanWithChildCantBeDeleted                       ErrorCode = "PlanWithChildCantBeDeleted"
	ErrorCodePlanIsUsedAsDefaultStartPlan                     ErrorCode = "PlanIsUsedAsDefaultStartPlan"
	ErrorCodePlanIsUsedAsDowngradePlan                        ErrorCode = "PlanIsUsedAsDowngradePlan"
	ErrorCodeInvalidAddressError                              ErrorCode = "InvalidAddressError"
	ErrorCodeInvalidQuantity                                  ErrorCode = "InvalidQuantity"
	ErrorCodeBillingPeriodMissingError                        ErrorCode = "BillingPeriodMissingError"
	ErrorCodeCustomerHasNoPaymentMethod                       ErrorCode = "CustomerHasNoPaymentMethod"
	ErrorCodeCustomerAlreadyUsesCoupon                        ErrorCode = "CustomerAlreadyUsesCoupon"
	ErrorCodeCheckoutOptionsMissing                           ErrorCode = "CheckoutOptionsMissing"
	ErrorCodeSubscriptionAlreadyCanceledOrExpired             ErrorCode = "SubscriptionAlreadyCanceledOrExpired"
	ErrorCodeTrialMustBeCancelledImmediately                  ErrorCode = "TrialMustBeCancelledImmediately"
	ErrorCodeInvalidCancellationDate                          ErrorCode = "InvalidCancellationDate"
	ErrorCodeFailedToImportCustomer                           ErrorCode = "FailedToImportCustomer"
	ErrorCodePackagePricingTypeNotSet                         ErrorCode = "PackagePricingTypeNotSet"
	ErrorCodeTrialMinDateError                                ErrorCode = "TrialMinDateError"
	ErrorCodeInvalidSubscriptionStatus                        ErrorCode = "InvalidSubscriptionStatus"
	ErrorCodeInvalidArgumentError                             ErrorCode = "InvalidArgumentError"
	ErrorCodeEditAllowedOnDraftPackageOnlyError               ErrorCode = "EditAllowedOnDraftPackageOnlyError"
	ErrorCodeIntegrationNotFound                              ErrorCode = "IntegrationNotFound"
	ErrorCodeResyncAlreadyInProgress                          ErrorCode = "ResyncAlreadyInProgress"
	ErrorCodeCouponNotFound                                   ErrorCode = "CouponNotFound"
	ErrorCodeArchivedCouponCantBeApplied                      ErrorCode = "ArchivedCouponCantBeApplied"
	ErrorCodeImportAlreadyInProgress                          ErrorCode = "ImportAlreadyInProgress"
	ErrorCodeCustomerNoBillingID                              ErrorCode = "CustomerNoBillingId"
	ErrorCodeStripeCustomerIsDeleted                          ErrorCode = "StripeCustomerIsDeleted"
	ErrorCodeInitStripePaymentMethodError                     ErrorCode = "InitStripePaymentMethodError"
	ErrorCodeAddonHasToHavePriceError                         ErrorCode = "AddonHasToHavePriceError"
	ErrorCodeSelectedBillingModelDoesntMatchImportedItemError ErrorCode = "SelectedBillingModelDoesntMatchImportedItemError"
	ErrorCodeCannotDeleteCustomerError                        ErrorCode = "CannotDeleteCustomerError"
	ErrorCodeCannotDeleteFeatureError                         ErrorCode = "CannotDeleteFeatureError"
	ErrorCodeInvalidUpdatePriceUnitAmountError                ErrorCode = "InvalidUpdatePriceUnitAmountError"
	ErrorCodeAccountNotFoundError                             ErrorCode = "AccountNotFoundError"
	ErrorCodeExperimentNotFoundError                          ErrorCode = "ExperimentNotFoundError"
	ErrorCodeExperimentAlreadyRunning                         ErrorCode = "ExperimentAlreadyRunning"
	ErrorCodeExperimentStatusError                            ErrorCode = "ExperimentStatusError"
	ErrorCodeOperationNotAllowedDuringInProgressExperiment    ErrorCode = "OperationNotAllowedDuringInProgressExperiment"
	ErrorCodeEntitlementsMustBelongToSamePackage              ErrorCode = "EntitlementsMustBelongToSamePackage"
	ErrorCodeCannotEditPackageInNonDraftMode                  ErrorCode = "CannotEditPackageInNonDraftMode"
	ErrorCodeMissingEntityIDError                             ErrorCode = "MissingEntityIdError"
)

var AllErrorCode = []ErrorCode{
	ErrorCodeRateLimitExceeded,
	ErrorCodeBadUserInput,
	ErrorCodeUnauthenticated,
	ErrorCodeCustomerNotFound,
	ErrorCodeFeatureNotFound,
	ErrorCodeDuplicatedEntityNotAllowed,
	ErrorCodeIntegrityViolation,
	ErrorCodeMemberNotFound,
	ErrorCodePlanNotFound,
	ErrorCodeSubscriptionMustHaveSinglePlanError,
	ErrorCodeAddonNotFound,
	ErrorCodeEnvironmentMissing,
	ErrorCodeEntityIDDifferentFromRefIDError,
	ErrorCodeUnsupportedFeatureType,
	ErrorCodeUnsupportedVendorIdentifier,
	ErrorCodeInvalidEntitlementResetPeriod,
	ErrorCodeUncompatibleSubscriptionAddon,
	ErrorCodeUnPublishedPackage,
	ErrorCodeMeteringNotAvailableForFeatureType,
	ErrorCodeIdentityForbidden,
	ErrorCodeMemberInvitationError,
	ErrorCodeInvalidUsageValueForIncrementalFeatureError,
	ErrorCodeUnexpectedError,
	ErrorCodePlanAlreadyExtended,
	ErrorCodePlansCircularDependencyError,
	ErrorCodeNoFeatureEntitlementInSubscription,
	ErrorCodeCheckoutIsNotSupported,
	ErrorCodePriceNotFound,
	ErrorCodeInvalidMemberDelete,
	ErrorCodePackageAlreadyPublished,
	ErrorCodeSubscriptionNotFound,
	ErrorCodeDraftPlanCantBeArchived,
	ErrorCodePlanWithChildCantBeDeleted,
	ErrorCodePlanIsUsedAsDefaultStartPlan,
	ErrorCodePlanIsUsedAsDowngradePlan,
	ErrorCodeInvalidAddressError,
	ErrorCodeInvalidQuantity,
	ErrorCodeBillingPeriodMissingError,
	ErrorCodeCustomerHasNoPaymentMethod,
	ErrorCodeCustomerAlreadyUsesCoupon,
	ErrorCodeCheckoutOptionsMissing,
	ErrorCodeSubscriptionAlreadyCanceledOrExpired,
	ErrorCodeTrialMustBeCancelledImmediately,
	ErrorCodeInvalidCancellationDate,
	ErrorCodeFailedToImportCustomer,
	ErrorCodePackagePricingTypeNotSet,
	ErrorCodeTrialMinDateError,
	ErrorCodeInvalidSubscriptionStatus,
	ErrorCodeInvalidArgumentError,
	ErrorCodeEditAllowedOnDraftPackageOnlyError,
	ErrorCodeIntegrationNotFound,
	ErrorCodeResyncAlreadyInProgress,
	ErrorCodeCouponNotFound,
	ErrorCodeArchivedCouponCantBeApplied,
	ErrorCodeImportAlreadyInProgress,
	ErrorCodeCustomerNoBillingID,
	ErrorCodeStripeCustomerIsDeleted,
	ErrorCodeInitStripePaymentMethodError,
	ErrorCodeAddonHasToHavePriceError,
	ErrorCodeSelectedBillingModelDoesntMatchImportedItemError,
	ErrorCodeCannotDeleteCustomerError,
	ErrorCodeCannotDeleteFeatureError,
	ErrorCodeInvalidUpdatePriceUnitAmountError,
	ErrorCodeAccountNotFoundError,
	ErrorCodeExperimentNotFoundError,
	ErrorCodeExperimentAlreadyRunning,
	ErrorCodeExperimentStatusError,
	ErrorCodeOperationNotAllowedDuringInProgressExperiment,
	ErrorCodeEntitlementsMustBelongToSamePackage,
	ErrorCodeCannotEditPackageInNonDraftMode,
	ErrorCodeMissingEntityIDError,
}

func (e ErrorCode) IsValid() bool {
	switch e {
	case ErrorCodeRateLimitExceeded, ErrorCodeBadUserInput, ErrorCodeUnauthenticated, ErrorCodeCustomerNotFound, ErrorCodeFeatureNotFound, ErrorCodeDuplicatedEntityNotAllowed, ErrorCodeIntegrityViolation, ErrorCodeMemberNotFound, ErrorCodePlanNotFound, ErrorCodeSubscriptionMustHaveSinglePlanError, ErrorCodeAddonNotFound, ErrorCodeEnvironmentMissing, ErrorCodeEntityIDDifferentFromRefIDError, ErrorCodeUnsupportedFeatureType, ErrorCodeUnsupportedVendorIdentifier, ErrorCodeInvalidEntitlementResetPeriod, ErrorCodeUncompatibleSubscriptionAddon, ErrorCodeUnPublishedPackage, ErrorCodeMeteringNotAvailableForFeatureType, ErrorCodeIdentityForbidden, ErrorCodeMemberInvitationError, ErrorCodeInvalidUsageValueForIncrementalFeatureError, ErrorCodeUnexpectedError, ErrorCodePlanAlreadyExtended, ErrorCodePlansCircularDependencyError, ErrorCodeNoFeatureEntitlementInSubscription, ErrorCodeCheckoutIsNotSupported, ErrorCodePriceNotFound, ErrorCodeInvalidMemberDelete, ErrorCodePackageAlreadyPublished, ErrorCodeSubscriptionNotFound, ErrorCodeDraftPlanCantBeArchived, ErrorCodePlanWithChildCantBeDeleted, ErrorCodePlanIsUsedAsDefaultStartPlan, ErrorCodePlanIsUsedAsDowngradePlan, ErrorCodeInvalidAddressError, ErrorCodeInvalidQuantity, ErrorCodeBillingPeriodMissingError, ErrorCodeCustomerHasNoPaymentMethod, ErrorCodeCustomerAlreadyUsesCoupon, ErrorCodeCheckoutOptionsMissing, ErrorCodeSubscriptionAlreadyCanceledOrExpired, ErrorCodeTrialMustBeCancelledImmediately, ErrorCodeInvalidCancellationDate, ErrorCodeFailedToImportCustomer, ErrorCodePackagePricingTypeNotSet, ErrorCodeTrialMinDateError, ErrorCodeInvalidSubscriptionStatus, ErrorCodeInvalidArgumentError, ErrorCodeEditAllowedOnDraftPackageOnlyError, ErrorCodeIntegrationNotFound, ErrorCodeResyncAlreadyInProgress, ErrorCodeCouponNotFound, ErrorCodeArchivedCouponCantBeApplied, ErrorCodeImportAlreadyInProgress, ErrorCodeCustomerNoBillingID, ErrorCodeStripeCustomerIsDeleted, ErrorCodeInitStripePaymentMethodError, ErrorCodeAddonHasToHavePriceError, ErrorCodeSelectedBillingModelDoesntMatchImportedItemError, ErrorCodeCannotDeleteCustomerError, ErrorCodeCannotDeleteFeatureError, ErrorCodeInvalidUpdatePriceUnitAmountError, ErrorCodeAccountNotFoundError, ErrorCodeExperimentNotFoundError, ErrorCodeExperimentAlreadyRunning, ErrorCodeExperimentStatusError, ErrorCodeOperationNotAllowedDuringInProgressExperiment, ErrorCodeEntitlementsMustBelongToSamePackage, ErrorCodeCannotEditPackageInNonDraftMode, ErrorCodeMissingEntityIDError:
		return true
	}
	return false
}

func (e ErrorCode) String() string {
	return string(e)
}

func (e *ErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCode", str)
	}
	return nil
}

func (e ErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// EventLogType
type EventLogType string

const (
	EventLogTypeCustomerCreated                     EventLogType = "CUSTOMER_CREATED"
	EventLogTypeCustomerUpdated                     EventLogType = "CUSTOMER_UPDATED"
	EventLogTypeCustomerDeleted                     EventLogType = "CUSTOMER_DELETED"
	EventLogTypeSubscriptionCreated                 EventLogType = "SUBSCRIPTION_CREATED"
	EventLogTypeSubscriptionTrialStarted            EventLogType = "SUBSCRIPTION_TRIAL_STARTED"
	EventLogTypeSubscriptionTrialExpired            EventLogType = "SUBSCRIPTION_TRIAL_EXPIRED"
	EventLogTypeSubscriptionTrialConverted          EventLogType = "SUBSCRIPTION_TRIAL_CONVERTED"
	EventLogTypeSubscriptionTrialEndsSoon           EventLogType = "SUBSCRIPTION_TRIAL_ENDS_SOON"
	EventLogTypeSubscriptionUpdated                 EventLogType = "SUBSCRIPTION_UPDATED"
	EventLogTypeSubscriptionCanceled                EventLogType = "SUBSCRIPTION_CANCELED"
	EventLogTypeSubscriptionExpired                 EventLogType = "SUBSCRIPTION_EXPIRED"
	EventLogTypeSubscriptionUsageUpdated            EventLogType = "SUBSCRIPTION_USAGE_UPDATED"
	EventLogTypeCreateSubscriptionFailed            EventLogType = "CREATE_SUBSCRIPTION_FAILED"
	EventLogTypePlanCreated                         EventLogType = "PLAN_CREATED"
	EventLogTypePlanUpdated                         EventLogType = "PLAN_UPDATED"
	EventLogTypePlanDeleted                         EventLogType = "PLAN_DELETED"
	EventLogTypeAddonCreated                        EventLogType = "ADDON_CREATED"
	EventLogTypeAddonUpdated                        EventLogType = "ADDON_UPDATED"
	EventLogTypeAddonDeleted                        EventLogType = "ADDON_DELETED"
	EventLogTypeFeatureCreated                      EventLogType = "FEATURE_CREATED"
	EventLogTypeFeatureUpdated                      EventLogType = "FEATURE_UPDATED"
	EventLogTypeFeatureDeleted                      EventLogType = "FEATURE_DELETED"
	EventLogTypeEntitlementRequested                EventLogType = "ENTITLEMENT_REQUESTED"
	EventLogTypeEntitlementGranted                  EventLogType = "ENTITLEMENT_GRANTED"
	EventLogTypeEntitlementDenied                   EventLogType = "ENTITLEMENT_DENIED"
	EventLogTypeEntitlementsUpdated                 EventLogType = "ENTITLEMENTS_UPDATED"
	EventLogTypeMeasurementReported                 EventLogType = "MEASUREMENT_REPORTED"
	EventLogTypePromotionalEntitlementGranted       EventLogType = "PROMOTIONAL_ENTITLEMENT_GRANTED"
	EventLogTypePromotionalEntitlementUpdated       EventLogType = "PROMOTIONAL_ENTITLEMENT_UPDATED"
	EventLogTypePromotionalEntitlementExpired       EventLogType = "PROMOTIONAL_ENTITLEMENT_EXPIRED"
	EventLogTypePromotionalEntitlementRevoked       EventLogType = "PROMOTIONAL_ENTITLEMENT_REVOKED"
	EventLogTypePackagePublished                    EventLogType = "PACKAGE_PUBLISHED"
	EventLogTypeResyncIntegrationTriggered          EventLogType = "RESYNC_INTEGRATION_TRIGGERED"
	EventLogTypeCouponCreated                       EventLogType = "COUPON_CREATED"
	EventLogTypeCouponUpdated                       EventLogType = "COUPON_UPDATED"
	EventLogTypeCouponArchived                      EventLogType = "COUPON_ARCHIVED"
	EventLogTypeImportIntegrationCatalogTriggered   EventLogType = "IMPORT_INTEGRATION_CATALOG_TRIGGERED"
	EventLogTypeImportIntegrationCustomersTriggered EventLogType = "IMPORT_INTEGRATION_CUSTOMERS_TRIGGERED"
	EventLogTypeSyncFailed                          EventLogType = "SYNC_FAILED"
	EventLogTypeCustomerPaymentFailed               EventLogType = "CUSTOMER_PAYMENT_FAILED"
)

var AllEventLogType = []EventLogType{
	EventLogTypeCustomerCreated,
	EventLogTypeCustomerUpdated,
	EventLogTypeCustomerDeleted,
	EventLogTypeSubscriptionCreated,
	EventLogTypeSubscriptionTrialStarted,
	EventLogTypeSubscriptionTrialExpired,
	EventLogTypeSubscriptionTrialConverted,
	EventLogTypeSubscriptionTrialEndsSoon,
	EventLogTypeSubscriptionUpdated,
	EventLogTypeSubscriptionCanceled,
	EventLogTypeSubscriptionExpired,
	EventLogTypeSubscriptionUsageUpdated,
	EventLogTypeCreateSubscriptionFailed,
	EventLogTypePlanCreated,
	EventLogTypePlanUpdated,
	EventLogTypePlanDeleted,
	EventLogTypeAddonCreated,
	EventLogTypeAddonUpdated,
	EventLogTypeAddonDeleted,
	EventLogTypeFeatureCreated,
	EventLogTypeFeatureUpdated,
	EventLogTypeFeatureDeleted,
	EventLogTypeEntitlementRequested,
	EventLogTypeEntitlementGranted,
	EventLogTypeEntitlementDenied,
	EventLogTypeEntitlementsUpdated,
	EventLogTypeMeasurementReported,
	EventLogTypePromotionalEntitlementGranted,
	EventLogTypePromotionalEntitlementUpdated,
	EventLogTypePromotionalEntitlementExpired,
	EventLogTypePromotionalEntitlementRevoked,
	EventLogTypePackagePublished,
	EventLogTypeResyncIntegrationTriggered,
	EventLogTypeCouponCreated,
	EventLogTypeCouponUpdated,
	EventLogTypeCouponArchived,
	EventLogTypeImportIntegrationCatalogTriggered,
	EventLogTypeImportIntegrationCustomersTriggered,
	EventLogTypeSyncFailed,
	EventLogTypeCustomerPaymentFailed,
}

func (e EventLogType) IsValid() bool {
	switch e {
	case EventLogTypeCustomerCreated, EventLogTypeCustomerUpdated, EventLogTypeCustomerDeleted, EventLogTypeSubscriptionCreated, EventLogTypeSubscriptionTrialStarted, EventLogTypeSubscriptionTrialExpired, EventLogTypeSubscriptionTrialConverted, EventLogTypeSubscriptionTrialEndsSoon, EventLogTypeSubscriptionUpdated, EventLogTypeSubscriptionCanceled, EventLogTypeSubscriptionExpired, EventLogTypeSubscriptionUsageUpdated, EventLogTypeCreateSubscriptionFailed, EventLogTypePlanCreated, EventLogTypePlanUpdated, EventLogTypePlanDeleted, EventLogTypeAddonCreated, EventLogTypeAddonUpdated, EventLogTypeAddonDeleted, EventLogTypeFeatureCreated, EventLogTypeFeatureUpdated, EventLogTypeFeatureDeleted, EventLogTypeEntitlementRequested, EventLogTypeEntitlementGranted, EventLogTypeEntitlementDenied, EventLogTypeEntitlementsUpdated, EventLogTypeMeasurementReported, EventLogTypePromotionalEntitlementGranted, EventLogTypePromotionalEntitlementUpdated, EventLogTypePromotionalEntitlementExpired, EventLogTypePromotionalEntitlementRevoked, EventLogTypePackagePublished, EventLogTypeResyncIntegrationTriggered, EventLogTypeCouponCreated, EventLogTypeCouponUpdated, EventLogTypeCouponArchived, EventLogTypeImportIntegrationCatalogTriggered, EventLogTypeImportIntegrationCustomersTriggered, EventLogTypeSyncFailed, EventLogTypeCustomerPaymentFailed:
		return true
	}
	return false
}

func (e EventLogType) String() string {
	return string(e)
}

func (e *EventLogType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventLogType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventLogType", str)
	}
	return nil
}

func (e EventLogType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ExperimentSortFields string

const (
	ExperimentSortFieldsID            ExperimentSortFields = "id"
	ExperimentSortFieldsName          ExperimentSortFields = "name"
	ExperimentSortFieldsRefID         ExperimentSortFields = "refId"
	ExperimentSortFieldsCreatedAt     ExperimentSortFields = "createdAt"
	ExperimentSortFieldsEnvironmentID ExperimentSortFields = "environmentId"
	ExperimentSortFieldsProductID     ExperimentSortFields = "productId"
	ExperimentSortFieldsStatus        ExperimentSortFields = "status"
)

var AllExperimentSortFields = []ExperimentSortFields{
	ExperimentSortFieldsID,
	ExperimentSortFieldsName,
	ExperimentSortFieldsRefID,
	ExperimentSortFieldsCreatedAt,
	ExperimentSortFieldsEnvironmentID,
	ExperimentSortFieldsProductID,
	ExperimentSortFieldsStatus,
}

func (e ExperimentSortFields) IsValid() bool {
	switch e {
	case ExperimentSortFieldsID, ExperimentSortFieldsName, ExperimentSortFieldsRefID, ExperimentSortFieldsCreatedAt, ExperimentSortFieldsEnvironmentID, ExperimentSortFieldsProductID, ExperimentSortFieldsStatus:
		return true
	}
	return false
}

func (e ExperimentSortFields) String() string {
	return string(e)
}

func (e *ExperimentSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentSortFields", str)
	}
	return nil
}

func (e ExperimentSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the EXPERIMENT
type ExperimentStatus string

const (
	ExperimentStatusDraft      ExperimentStatus = "DRAFT"
	ExperimentStatusInProgress ExperimentStatus = "IN_PROGRESS"
	ExperimentStatusCompleted  ExperimentStatus = "COMPLETED"
)

var AllExperimentStatus = []ExperimentStatus{
	ExperimentStatusDraft,
	ExperimentStatusInProgress,
	ExperimentStatusCompleted,
}

func (e ExperimentStatus) IsValid() bool {
	switch e {
	case ExperimentStatusDraft, ExperimentStatusInProgress, ExperimentStatusCompleted:
		return true
	}
	return false
}

func (e ExperimentStatus) String() string {
	return string(e)
}

func (e *ExperimentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentStatus", str)
	}
	return nil
}

func (e ExperimentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FeatureSortFields string

const (
	FeatureSortFieldsID            FeatureSortFields = "id"
	FeatureSortFieldsDisplayName   FeatureSortFields = "displayName"
	FeatureSortFieldsRefID         FeatureSortFields = "refId"
	FeatureSortFieldsCreatedAt     FeatureSortFields = "createdAt"
	FeatureSortFieldsUpdatedAt     FeatureSortFields = "updatedAt"
	FeatureSortFieldsDescription   FeatureSortFields = "description"
	FeatureSortFieldsFeatureType   FeatureSortFields = "featureType"
	FeatureSortFieldsMeterType     FeatureSortFields = "meterType"
	FeatureSortFieldsFeatureStatus FeatureSortFields = "featureStatus"
	FeatureSortFieldsEnvironmentID FeatureSortFields = "environmentId"
)

var AllFeatureSortFields = []FeatureSortFields{
	FeatureSortFieldsID,
	FeatureSortFieldsDisplayName,
	FeatureSortFieldsRefID,
	FeatureSortFieldsCreatedAt,
	FeatureSortFieldsUpdatedAt,
	FeatureSortFieldsDescription,
	FeatureSortFieldsFeatureType,
	FeatureSortFieldsMeterType,
	FeatureSortFieldsFeatureStatus,
	FeatureSortFieldsEnvironmentID,
}

func (e FeatureSortFields) IsValid() bool {
	switch e {
	case FeatureSortFieldsID, FeatureSortFieldsDisplayName, FeatureSortFieldsRefID, FeatureSortFieldsCreatedAt, FeatureSortFieldsUpdatedAt, FeatureSortFieldsDescription, FeatureSortFieldsFeatureType, FeatureSortFieldsMeterType, FeatureSortFieldsFeatureStatus, FeatureSortFieldsEnvironmentID:
		return true
	}
	return false
}

func (e FeatureSortFields) String() string {
	return string(e)
}

func (e *FeatureSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureSortFields", str)
	}
	return nil
}

func (e FeatureSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feature status.
type FeatureStatus string

const (
	FeatureStatusNew       FeatureStatus = "NEW"
	FeatureStatusSuspended FeatureStatus = "SUSPENDED"
	FeatureStatusActive    FeatureStatus = "ACTIVE"
)

var AllFeatureStatus = []FeatureStatus{
	FeatureStatusNew,
	FeatureStatusSuspended,
	FeatureStatusActive,
}

func (e FeatureStatus) IsValid() bool {
	switch e {
	case FeatureStatusNew, FeatureStatusSuspended, FeatureStatusActive:
		return true
	}
	return false
}

func (e FeatureStatus) String() string {
	return string(e)
}

func (e *FeatureStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureStatus", str)
	}
	return nil
}

func (e FeatureStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the feature
type FeatureType string

const (
	FeatureTypeBoolean FeatureType = "BOOLEAN"
	FeatureTypeNumber  FeatureType = "NUMBER"
)

var AllFeatureType = []FeatureType{
	FeatureTypeBoolean,
	FeatureTypeNumber,
}

func (e FeatureType) IsValid() bool {
	switch e {
	case FeatureTypeBoolean, FeatureTypeNumber:
		return true
	}
	return false
}

func (e FeatureType) String() string {
	return string(e)
}

func (e *FeatureType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureType", str)
	}
	return nil
}

func (e FeatureType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Font weight
type FontWeight string

const (
	FontWeightNormal FontWeight = "NORMAL"
	FontWeightBold   FontWeight = "BOLD"
)

var AllFontWeight = []FontWeight{
	FontWeightNormal,
	FontWeightBold,
}

func (e FontWeight) IsValid() bool {
	switch e {
	case FontWeightNormal, FontWeightBold:
		return true
	}
	return false
}

func (e FontWeight) String() string {
	return string(e)
}

func (e *FontWeight) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FontWeight(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FontWeight", str)
	}
	return nil
}

func (e FontWeight) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HookSortFields string

const (
	HookSortFieldsID            HookSortFields = "id"
	HookSortFieldsEndpoint      HookSortFields = "endpoint"
	HookSortFieldsStatus        HookSortFields = "status"
	HookSortFieldsCreatedAt     HookSortFields = "createdAt"
	HookSortFieldsEnvironmentID HookSortFields = "environmentId"
)

var AllHookSortFields = []HookSortFields{
	HookSortFieldsID,
	HookSortFieldsEndpoint,
	HookSortFieldsStatus,
	HookSortFieldsCreatedAt,
	HookSortFieldsEnvironmentID,
}

func (e HookSortFields) IsValid() bool {
	switch e {
	case HookSortFieldsID, HookSortFieldsEndpoint, HookSortFieldsStatus, HookSortFieldsCreatedAt, HookSortFieldsEnvironmentID:
		return true
	}
	return false
}

func (e HookSortFields) String() string {
	return string(e)
}

func (e *HookSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HookSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HookSortFields", str)
	}
	return nil
}

func (e HookSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// HookStatus.
type HookStatus string

const (
	HookStatusInactive HookStatus = "INACTIVE"
	HookStatusActive   HookStatus = "ACTIVE"
)

var AllHookStatus = []HookStatus{
	HookStatusInactive,
	HookStatusActive,
}

func (e HookStatus) IsValid() bool {
	switch e {
	case HookStatusInactive, HookStatusActive:
		return true
	}
	return false
}

func (e HookStatus) String() string {
	return string(e)
}

func (e *HookStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HookStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HookStatus", str)
	}
	return nil
}

func (e HookStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImportIntegrationTaskSortFields string

const (
	ImportIntegrationTaskSortFieldsID            ImportIntegrationTaskSortFields = "id"
	ImportIntegrationTaskSortFieldsEnvironmentID ImportIntegrationTaskSortFields = "environmentId"
	ImportIntegrationTaskSortFieldsCreatedAt     ImportIntegrationTaskSortFields = "createdAt"
	ImportIntegrationTaskSortFieldsTaskType      ImportIntegrationTaskSortFields = "taskType"
	ImportIntegrationTaskSortFieldsStatus        ImportIntegrationTaskSortFields = "status"
)

var AllImportIntegrationTaskSortFields = []ImportIntegrationTaskSortFields{
	ImportIntegrationTaskSortFieldsID,
	ImportIntegrationTaskSortFieldsEnvironmentID,
	ImportIntegrationTaskSortFieldsCreatedAt,
	ImportIntegrationTaskSortFieldsTaskType,
	ImportIntegrationTaskSortFieldsStatus,
}

func (e ImportIntegrationTaskSortFields) IsValid() bool {
	switch e {
	case ImportIntegrationTaskSortFieldsID, ImportIntegrationTaskSortFieldsEnvironmentID, ImportIntegrationTaskSortFieldsCreatedAt, ImportIntegrationTaskSortFieldsTaskType, ImportIntegrationTaskSortFieldsStatus:
		return true
	}
	return false
}

func (e ImportIntegrationTaskSortFields) String() string {
	return string(e)
}

func (e *ImportIntegrationTaskSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportIntegrationTaskSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportIntegrationTaskSortFields", str)
	}
	return nil
}

func (e ImportIntegrationTaskSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IntegrationSortFields string

const (
	IntegrationSortFieldsID               IntegrationSortFields = "id"
	IntegrationSortFieldsCreatedAt        IntegrationSortFields = "createdAt"
	IntegrationSortFieldsEnvironmentID    IntegrationSortFields = "environmentId"
	IntegrationSortFieldsVendorIdentifier IntegrationSortFields = "vendorIdentifier"
)

var AllIntegrationSortFields = []IntegrationSortFields{
	IntegrationSortFieldsID,
	IntegrationSortFieldsCreatedAt,
	IntegrationSortFieldsEnvironmentID,
	IntegrationSortFieldsVendorIdentifier,
}

func (e IntegrationSortFields) IsValid() bool {
	switch e {
	case IntegrationSortFieldsID, IntegrationSortFieldsCreatedAt, IntegrationSortFieldsEnvironmentID, IntegrationSortFieldsVendorIdentifier:
		return true
	}
	return false
}

func (e IntegrationSortFields) String() string {
	return string(e)
}

func (e *IntegrationSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationSortFields", str)
	}
	return nil
}

func (e IntegrationSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MemberSortFields string

const (
	MemberSortFieldsID        MemberSortFields = "id"
	MemberSortFieldsCreatedAt MemberSortFields = "createdAt"
)

var AllMemberSortFields = []MemberSortFields{
	MemberSortFieldsID,
	MemberSortFieldsCreatedAt,
}

func (e MemberSortFields) IsValid() bool {
	switch e {
	case MemberSortFieldsID, MemberSortFieldsCreatedAt:
		return true
	}
	return false
}

func (e MemberSortFields) String() string {
	return string(e)
}

func (e *MemberSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberSortFields", str)
	}
	return nil
}

func (e MemberSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Member Status.
type MemberStatus string

const (
	MemberStatusInvited    MemberStatus = "INVITED"
	MemberStatusRegistered MemberStatus = "REGISTERED"
)

var AllMemberStatus = []MemberStatus{
	MemberStatusInvited,
	MemberStatusRegistered,
}

func (e MemberStatus) IsValid() bool {
	switch e {
	case MemberStatusInvited, MemberStatusRegistered:
		return true
	}
	return false
}

func (e MemberStatus) String() string {
	return string(e)
}

func (e *MemberStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberStatus", str)
	}
	return nil
}

func (e MemberStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The meter type of the feature
type MeterType string

const (
	MeterTypeNone        MeterType = "None"
	MeterTypeFluctuating MeterType = "Fluctuating"
	MeterTypeIncremental MeterType = "Incremental"
)

var AllMeterType = []MeterType{
	MeterTypeNone,
	MeterTypeFluctuating,
	MeterTypeIncremental,
}

func (e MeterType) IsValid() bool {
	switch e {
	case MeterTypeNone, MeterTypeFluctuating, MeterTypeIncremental:
		return true
	}
	return false
}

func (e MeterType) String() string {
	return string(e)
}

func (e *MeterType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MeterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MeterType", str)
	}
	return nil
}

func (e MeterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Montly reset period according to configuration
type MonthlyAccordingTo string

const (
	MonthlyAccordingToSubscriptionStart MonthlyAccordingTo = "SubscriptionStart"
	MonthlyAccordingToStartOfTheMonth   MonthlyAccordingTo = "StartOfTheMonth"
)

var AllMonthlyAccordingTo = []MonthlyAccordingTo{
	MonthlyAccordingToSubscriptionStart,
	MonthlyAccordingToStartOfTheMonth,
}

func (e MonthlyAccordingTo) IsValid() bool {
	switch e {
	case MonthlyAccordingToSubscriptionStart, MonthlyAccordingToStartOfTheMonth:
		return true
	}
	return false
}

func (e MonthlyAccordingTo) String() string {
	return string(e)
}

func (e *MonthlyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MonthlyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MonthlyAccordingTo", str)
	}
	return nil
}

func (e MonthlyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PackageDTOSortFields string

const (
	PackageDTOSortFieldsID            PackageDTOSortFields = "id"
	PackageDTOSortFieldsCreatedAt     PackageDTOSortFields = "createdAt"
	PackageDTOSortFieldsUpdatedAt     PackageDTOSortFields = "updatedAt"
	PackageDTOSortFieldsRefID         PackageDTOSortFields = "refId"
	PackageDTOSortFieldsBillingID     PackageDTOSortFields = "billingId"
	PackageDTOSortFieldsDisplayName   PackageDTOSortFields = "displayName"
	PackageDTOSortFieldsStatus        PackageDTOSortFields = "status"
	PackageDTOSortFieldsPricingType   PackageDTOSortFields = "pricingType"
	PackageDTOSortFieldsDescription   PackageDTOSortFields = "description"
	PackageDTOSortFieldsEnvironmentID PackageDTOSortFields = "environmentId"
	PackageDTOSortFieldsProductID     PackageDTOSortFields = "productId"
	PackageDTOSortFieldsIsLatest      PackageDTOSortFields = "isLatest"
	PackageDTOSortFieldsVersionNumber PackageDTOSortFields = "versionNumber"
)

var AllPackageDTOSortFields = []PackageDTOSortFields{
	PackageDTOSortFieldsID,
	PackageDTOSortFieldsCreatedAt,
	PackageDTOSortFieldsUpdatedAt,
	PackageDTOSortFieldsRefID,
	PackageDTOSortFieldsBillingID,
	PackageDTOSortFieldsDisplayName,
	PackageDTOSortFieldsStatus,
	PackageDTOSortFieldsPricingType,
	PackageDTOSortFieldsDescription,
	PackageDTOSortFieldsEnvironmentID,
	PackageDTOSortFieldsProductID,
	PackageDTOSortFieldsIsLatest,
	PackageDTOSortFieldsVersionNumber,
}

func (e PackageDTOSortFields) IsValid() bool {
	switch e {
	case PackageDTOSortFieldsID, PackageDTOSortFieldsCreatedAt, PackageDTOSortFieldsUpdatedAt, PackageDTOSortFieldsRefID, PackageDTOSortFieldsBillingID, PackageDTOSortFieldsDisplayName, PackageDTOSortFieldsStatus, PackageDTOSortFieldsPricingType, PackageDTOSortFieldsDescription, PackageDTOSortFieldsEnvironmentID, PackageDTOSortFieldsProductID, PackageDTOSortFieldsIsLatest, PackageDTOSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e PackageDTOSortFields) String() string {
	return string(e)
}

func (e *PackageDTOSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageDTOSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageDTOSortFields", str)
	}
	return nil
}

func (e PackageDTOSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PackageEntitlementSortFields string

const (
	PackageEntitlementSortFieldsID            PackageEntitlementSortFields = "id"
	PackageEntitlementSortFieldsPackageID     PackageEntitlementSortFields = "packageId"
	PackageEntitlementSortFieldsCreatedAt     PackageEntitlementSortFields = "createdAt"
	PackageEntitlementSortFieldsUpdatedAt     PackageEntitlementSortFields = "updatedAt"
	PackageEntitlementSortFieldsEnvironmentID PackageEntitlementSortFields = "environmentId"
)

var AllPackageEntitlementSortFields = []PackageEntitlementSortFields{
	PackageEntitlementSortFieldsID,
	PackageEntitlementSortFieldsPackageID,
	PackageEntitlementSortFieldsCreatedAt,
	PackageEntitlementSortFieldsUpdatedAt,
	PackageEntitlementSortFieldsEnvironmentID,
}

func (e PackageEntitlementSortFields) IsValid() bool {
	switch e {
	case PackageEntitlementSortFieldsID, PackageEntitlementSortFieldsPackageID, PackageEntitlementSortFieldsCreatedAt, PackageEntitlementSortFieldsUpdatedAt, PackageEntitlementSortFieldsEnvironmentID:
		return true
	}
	return false
}

func (e PackageEntitlementSortFields) String() string {
	return string(e)
}

func (e *PackageEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageEntitlementSortFields", str)
	}
	return nil
}

func (e PackageEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Package status.
type PackageStatus string

const (
	PackageStatusDraft     PackageStatus = "DRAFT"
	PackageStatusPublished PackageStatus = "PUBLISHED"
	PackageStatusArchived  PackageStatus = "ARCHIVED"
)

var AllPackageStatus = []PackageStatus{
	PackageStatusDraft,
	PackageStatusPublished,
	PackageStatusArchived,
}

func (e PackageStatus) IsValid() bool {
	switch e {
	case PackageStatusDraft, PackageStatusPublished, PackageStatusArchived:
		return true
	}
	return false
}

func (e PackageStatus) String() string {
	return string(e)
}

func (e *PackageStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageStatus", str)
	}
	return nil
}

func (e PackageStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of a payment method
type PaymentMethodType string

const (
	PaymentMethodTypeCard PaymentMethodType = "CARD"
	PaymentMethodTypeBank PaymentMethodType = "BANK"
)

var AllPaymentMethodType = []PaymentMethodType{
	PaymentMethodTypeCard,
	PaymentMethodTypeBank,
}

func (e PaymentMethodType) IsValid() bool {
	switch e {
	case PaymentMethodTypeCard, PaymentMethodTypeBank:
		return true
	}
	return false
}

func (e PaymentMethodType) String() string {
	return string(e)
}

func (e *PaymentMethodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethodType", str)
	}
	return nil
}

func (e PaymentMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlanSortFields string

const (
	PlanSortFieldsID            PlanSortFields = "id"
	PlanSortFieldsCreatedAt     PlanSortFields = "createdAt"
	PlanSortFieldsUpdatedAt     PlanSortFields = "updatedAt"
	PlanSortFieldsRefID         PlanSortFields = "refId"
	PlanSortFieldsBillingID     PlanSortFields = "billingId"
	PlanSortFieldsDisplayName   PlanSortFields = "displayName"
	PlanSortFieldsStatus        PlanSortFields = "status"
	PlanSortFieldsPricingType   PlanSortFields = "pricingType"
	PlanSortFieldsDescription   PlanSortFields = "description"
	PlanSortFieldsEnvironmentID PlanSortFields = "environmentId"
	PlanSortFieldsProductID     PlanSortFields = "productId"
	PlanSortFieldsIsLatest      PlanSortFields = "isLatest"
	PlanSortFieldsVersionNumber PlanSortFields = "versionNumber"
)

var AllPlanSortFields = []PlanSortFields{
	PlanSortFieldsID,
	PlanSortFieldsCreatedAt,
	PlanSortFieldsUpdatedAt,
	PlanSortFieldsRefID,
	PlanSortFieldsBillingID,
	PlanSortFieldsDisplayName,
	PlanSortFieldsStatus,
	PlanSortFieldsPricingType,
	PlanSortFieldsDescription,
	PlanSortFieldsEnvironmentID,
	PlanSortFieldsProductID,
	PlanSortFieldsIsLatest,
	PlanSortFieldsVersionNumber,
}

func (e PlanSortFields) IsValid() bool {
	switch e {
	case PlanSortFieldsID, PlanSortFieldsCreatedAt, PlanSortFieldsUpdatedAt, PlanSortFieldsRefID, PlanSortFieldsBillingID, PlanSortFieldsDisplayName, PlanSortFieldsStatus, PlanSortFieldsPricingType, PlanSortFieldsDescription, PlanSortFieldsEnvironmentID, PlanSortFieldsProductID, PlanSortFieldsIsLatest, PlanSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e PlanSortFields) String() string {
	return string(e)
}

func (e *PlanSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlanSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlanSortFields", str)
	}
	return nil
}

func (e PlanSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PriceSortFields string

const (
	PriceSortFieldsID            PriceSortFields = "id"
	PriceSortFieldsCreatedAt     PriceSortFields = "createdAt"
	PriceSortFieldsBillingPeriod PriceSortFields = "billingPeriod"
	PriceSortFieldsBillingModel  PriceSortFields = "billingModel"
)

var AllPriceSortFields = []PriceSortFields{
	PriceSortFieldsID,
	PriceSortFieldsCreatedAt,
	PriceSortFieldsBillingPeriod,
	PriceSortFieldsBillingModel,
}

func (e PriceSortFields) IsValid() bool {
	switch e {
	case PriceSortFieldsID, PriceSortFieldsCreatedAt, PriceSortFieldsBillingPeriod, PriceSortFieldsBillingModel:
		return true
	}
	return false
}

func (e PriceSortFields) String() string {
	return string(e)
}

func (e *PriceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceSortFields", str)
	}
	return nil
}

func (e PriceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Package pricing type.
type PricingType string

const (
	PricingTypeFree   PricingType = "FREE"
	PricingTypePaid   PricingType = "PAID"
	PricingTypeCustom PricingType = "CUSTOM"
)

var AllPricingType = []PricingType{
	PricingTypeFree,
	PricingTypePaid,
	PricingTypeCustom,
}

func (e PricingType) IsValid() bool {
	switch e {
	case PricingTypeFree, PricingTypePaid, PricingTypeCustom:
		return true
	}
	return false
}

func (e PricingType) String() string {
	return string(e)
}

func (e *PricingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PricingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PricingType", str)
	}
	return nil
}

func (e PricingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductSortFields string

const (
	ProductSortFieldsID               ProductSortFields = "id"
	ProductSortFieldsDisplayName      ProductSortFields = "displayName"
	ProductSortFieldsRefID            ProductSortFields = "refId"
	ProductSortFieldsDescription      ProductSortFields = "description"
	ProductSortFieldsCreatedAt        ProductSortFields = "createdAt"
	ProductSortFieldsUpdatedAt        ProductSortFields = "updatedAt"
	ProductSortFieldsEnvironmentID    ProductSortFields = "environmentId"
	ProductSortFieldsIsDefaultProduct ProductSortFields = "isDefaultProduct"
)

var AllProductSortFields = []ProductSortFields{
	ProductSortFieldsID,
	ProductSortFieldsDisplayName,
	ProductSortFieldsRefID,
	ProductSortFieldsDescription,
	ProductSortFieldsCreatedAt,
	ProductSortFieldsUpdatedAt,
	ProductSortFieldsEnvironmentID,
	ProductSortFieldsIsDefaultProduct,
}

func (e ProductSortFields) IsValid() bool {
	switch e {
	case ProductSortFieldsID, ProductSortFieldsDisplayName, ProductSortFieldsRefID, ProductSortFieldsDescription, ProductSortFieldsCreatedAt, ProductSortFieldsUpdatedAt, ProductSortFieldsEnvironmentID, ProductSortFieldsIsDefaultProduct:
		return true
	}
	return false
}

func (e ProductSortFields) String() string {
	return string(e)
}

func (e *ProductSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortFields", str)
	}
	return nil
}

func (e ProductSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Promotional entitlement duration
type PromotionalEntitlementPeriod string

const (
	PromotionalEntitlementPeriodOneWeek  PromotionalEntitlementPeriod = "ONE_WEEK"
	PromotionalEntitlementPeriodOneMonth PromotionalEntitlementPeriod = "ONE_MONTH"
	PromotionalEntitlementPeriodSixMonth PromotionalEntitlementPeriod = "SIX_MONTH"
	PromotionalEntitlementPeriodOneYear  PromotionalEntitlementPeriod = "ONE_YEAR"
	PromotionalEntitlementPeriodLifetime PromotionalEntitlementPeriod = "LIFETIME"
	PromotionalEntitlementPeriodCustom   PromotionalEntitlementPeriod = "CUSTOM"
)

var AllPromotionalEntitlementPeriod = []PromotionalEntitlementPeriod{
	PromotionalEntitlementPeriodOneWeek,
	PromotionalEntitlementPeriodOneMonth,
	PromotionalEntitlementPeriodSixMonth,
	PromotionalEntitlementPeriodOneYear,
	PromotionalEntitlementPeriodLifetime,
	PromotionalEntitlementPeriodCustom,
}

func (e PromotionalEntitlementPeriod) IsValid() bool {
	switch e {
	case PromotionalEntitlementPeriodOneWeek, PromotionalEntitlementPeriodOneMonth, PromotionalEntitlementPeriodSixMonth, PromotionalEntitlementPeriodOneYear, PromotionalEntitlementPeriodLifetime, PromotionalEntitlementPeriodCustom:
		return true
	}
	return false
}

func (e PromotionalEntitlementPeriod) String() string {
	return string(e)
}

func (e *PromotionalEntitlementPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementPeriod", str)
	}
	return nil
}

func (e PromotionalEntitlementPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PromotionalEntitlementSortFields string

const (
	PromotionalEntitlementSortFieldsID            PromotionalEntitlementSortFields = "id"
	PromotionalEntitlementSortFieldsCreatedAt     PromotionalEntitlementSortFields = "createdAt"
	PromotionalEntitlementSortFieldsUpdatedAt     PromotionalEntitlementSortFields = "updatedAt"
	PromotionalEntitlementSortFieldsStatus        PromotionalEntitlementSortFields = "status"
	PromotionalEntitlementSortFieldsEnvironmentID PromotionalEntitlementSortFields = "environmentId"
)

var AllPromotionalEntitlementSortFields = []PromotionalEntitlementSortFields{
	PromotionalEntitlementSortFieldsID,
	PromotionalEntitlementSortFieldsCreatedAt,
	PromotionalEntitlementSortFieldsUpdatedAt,
	PromotionalEntitlementSortFieldsStatus,
	PromotionalEntitlementSortFieldsEnvironmentID,
}

func (e PromotionalEntitlementSortFields) IsValid() bool {
	switch e {
	case PromotionalEntitlementSortFieldsID, PromotionalEntitlementSortFieldsCreatedAt, PromotionalEntitlementSortFieldsUpdatedAt, PromotionalEntitlementSortFieldsStatus, PromotionalEntitlementSortFieldsEnvironmentID:
		return true
	}
	return false
}

func (e PromotionalEntitlementSortFields) String() string {
	return string(e)
}

func (e *PromotionalEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementSortFields", str)
	}
	return nil
}

func (e PromotionalEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Promotional entitlement status
type PromotionalEntitlementStatus string

const (
	PromotionalEntitlementStatusActive  PromotionalEntitlementStatus = "Active"
	PromotionalEntitlementStatusExpired PromotionalEntitlementStatus = "Expired"
	PromotionalEntitlementStatusPaused  PromotionalEntitlementStatus = "Paused"
)

var AllPromotionalEntitlementStatus = []PromotionalEntitlementStatus{
	PromotionalEntitlementStatusActive,
	PromotionalEntitlementStatusExpired,
	PromotionalEntitlementStatusPaused,
}

func (e PromotionalEntitlementStatus) IsValid() bool {
	switch e {
	case PromotionalEntitlementStatusActive, PromotionalEntitlementStatusExpired, PromotionalEntitlementStatusPaused:
		return true
	}
	return false
}

func (e PromotionalEntitlementStatus) String() string {
	return string(e)
}

func (e *PromotionalEntitlementStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementStatus", str)
	}
	return nil
}

func (e PromotionalEntitlementStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Provision subscription status
type ProvisionSubscriptionStatus string

const (
	ProvisionSubscriptionStatusPaymentRequired ProvisionSubscriptionStatus = "PAYMENT_REQUIRED"
	ProvisionSubscriptionStatusSuccess         ProvisionSubscriptionStatus = "SUCCESS"
)

var AllProvisionSubscriptionStatus = []ProvisionSubscriptionStatus{
	ProvisionSubscriptionStatusPaymentRequired,
	ProvisionSubscriptionStatusSuccess,
}

func (e ProvisionSubscriptionStatus) IsValid() bool {
	switch e {
	case ProvisionSubscriptionStatusPaymentRequired, ProvisionSubscriptionStatusSuccess:
		return true
	}
	return false
}

func (e ProvisionSubscriptionStatus) String() string {
	return string(e)
}

func (e *ProvisionSubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisionSubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisionSubscriptionStatus", str)
	}
	return nil
}

func (e ProvisionSubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PublishMigrationType
type PublishMigrationType string

const (
	PublishMigrationTypeNewCustomers PublishMigrationType = "NEW_CUSTOMERS"
	PublishMigrationTypeAllCustomers PublishMigrationType = "ALL_CUSTOMERS"
)

var AllPublishMigrationType = []PublishMigrationType{
	PublishMigrationTypeNewCustomers,
	PublishMigrationTypeAllCustomers,
}

func (e PublishMigrationType) IsValid() bool {
	switch e {
	case PublishMigrationTypeNewCustomers, PublishMigrationTypeAllCustomers:
		return true
	}
	return false
}

func (e PublishMigrationType) String() string {
	return string(e)
}

func (e *PublishMigrationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishMigrationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishMigrationType", str)
	}
	return nil
}

func (e PublishMigrationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort Directions
type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort Nulls Options
type SortNulls string

const (
	SortNullsNullsFirst SortNulls = "NULLS_FIRST"
	SortNullsNullsLast  SortNulls = "NULLS_LAST"
)

var AllSortNulls = []SortNulls{
	SortNullsNullsFirst,
	SortNullsNullsLast,
}

func (e SortNulls) IsValid() bool {
	switch e {
	case SortNullsNullsFirst, SortNullsNullsLast:
		return true
	}
	return false
}

func (e SortNulls) String() string {
	return string(e)
}

func (e *SortNulls) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortNulls(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortNulls", str)
	}
	return nil
}

func (e SortNulls) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SourceType string

const (
	SourceTypeJsClientSdk   SourceType = "JS_CLIENT_SDK"
	SourceTypeNodeServerSdk SourceType = "NODE_SERVER_SDK"
)

var AllSourceType = []SourceType{
	SourceTypeJsClientSdk,
	SourceTypeNodeServerSdk,
}

func (e SourceType) IsValid() bool {
	switch e {
	case SourceTypeJsClientSdk, SourceTypeNodeServerSdk:
		return true
	}
	return false
}

func (e SourceType) String() string {
	return string(e)
}

func (e *SourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SourceType", str)
	}
	return nil
}

func (e SourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionAddonSortFields string

const (
	SubscriptionAddonSortFieldsID        SubscriptionAddonSortFields = "id"
	SubscriptionAddonSortFieldsQuantity  SubscriptionAddonSortFields = "quantity"
	SubscriptionAddonSortFieldsUpdatedAt SubscriptionAddonSortFields = "updatedAt"
	SubscriptionAddonSortFieldsCreatedAt SubscriptionAddonSortFields = "createdAt"
)

var AllSubscriptionAddonSortFields = []SubscriptionAddonSortFields{
	SubscriptionAddonSortFieldsID,
	SubscriptionAddonSortFieldsQuantity,
	SubscriptionAddonSortFieldsUpdatedAt,
	SubscriptionAddonSortFieldsCreatedAt,
}

func (e SubscriptionAddonSortFields) IsValid() bool {
	switch e {
	case SubscriptionAddonSortFieldsID, SubscriptionAddonSortFieldsQuantity, SubscriptionAddonSortFieldsUpdatedAt, SubscriptionAddonSortFieldsCreatedAt:
		return true
	}
	return false
}

func (e SubscriptionAddonSortFields) String() string {
	return string(e)
}

func (e *SubscriptionAddonSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionAddonSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionAddonSortFields", str)
	}
	return nil
}

func (e SubscriptionAddonSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription cancellation status
type SubscriptionCancelReason string

const (
	SubscriptionCancelReasonUpgradeOrDowngrade    SubscriptionCancelReason = "UpgradeOrDowngrade"
	SubscriptionCancelReasonCancelledByBilling    SubscriptionCancelReason = "CancelledByBilling"
	SubscriptionCancelReasonExpired               SubscriptionCancelReason = "Expired"
	SubscriptionCancelReasonDetachBilling         SubscriptionCancelReason = "DetachBilling"
	SubscriptionCancelReasonTrialEnded            SubscriptionCancelReason = "TrialEnded"
	SubscriptionCancelReasonImmediate             SubscriptionCancelReason = "Immediate"
	SubscriptionCancelReasonTrialConverted        SubscriptionCancelReason = "TrialConverted"
	SubscriptionCancelReasonPendingPaymentExpired SubscriptionCancelReason = "PendingPaymentExpired"
	SubscriptionCancelReasonScheduledCancellation SubscriptionCancelReason = "ScheduledCancellation"
)

var AllSubscriptionCancelReason = []SubscriptionCancelReason{
	SubscriptionCancelReasonUpgradeOrDowngrade,
	SubscriptionCancelReasonCancelledByBilling,
	SubscriptionCancelReasonExpired,
	SubscriptionCancelReasonDetachBilling,
	SubscriptionCancelReasonTrialEnded,
	SubscriptionCancelReasonImmediate,
	SubscriptionCancelReasonTrialConverted,
	SubscriptionCancelReasonPendingPaymentExpired,
	SubscriptionCancelReasonScheduledCancellation,
}

func (e SubscriptionCancelReason) IsValid() bool {
	switch e {
	case SubscriptionCancelReasonUpgradeOrDowngrade, SubscriptionCancelReasonCancelledByBilling, SubscriptionCancelReasonExpired, SubscriptionCancelReasonDetachBilling, SubscriptionCancelReasonTrialEnded, SubscriptionCancelReasonImmediate, SubscriptionCancelReasonTrialConverted, SubscriptionCancelReasonPendingPaymentExpired, SubscriptionCancelReasonScheduledCancellation:
		return true
	}
	return false
}

func (e SubscriptionCancelReason) String() string {
	return string(e)
}

func (e *SubscriptionCancelReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancelReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancelReason", str)
	}
	return nil
}

func (e SubscriptionCancelReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionCancellationTime string

const (
	SubscriptionCancellationTimeEndOfBillingPeriod SubscriptionCancellationTime = "END_OF_BILLING_PERIOD"
	SubscriptionCancellationTimeImmediate          SubscriptionCancellationTime = "IMMEDIATE"
	SubscriptionCancellationTimeSpecificDate       SubscriptionCancellationTime = "SPECIFIC_DATE"
)

var AllSubscriptionCancellationTime = []SubscriptionCancellationTime{
	SubscriptionCancellationTimeEndOfBillingPeriod,
	SubscriptionCancellationTimeImmediate,
	SubscriptionCancellationTimeSpecificDate,
}

func (e SubscriptionCancellationTime) IsValid() bool {
	switch e {
	case SubscriptionCancellationTimeEndOfBillingPeriod, SubscriptionCancellationTimeImmediate, SubscriptionCancellationTimeSpecificDate:
		return true
	}
	return false
}

func (e SubscriptionCancellationTime) String() string {
	return string(e)
}

func (e *SubscriptionCancellationTime) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancellationTime(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancellationTime", str)
	}
	return nil
}

func (e SubscriptionCancellationTime) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription decision strategy
type SubscriptionDecisionStrategy string

const (
	SubscriptionDecisionStrategyPredefinedFreePlan          SubscriptionDecisionStrategy = "PREDEFINED_FREE_PLAN"
	SubscriptionDecisionStrategyPredefinedTrialPlan         SubscriptionDecisionStrategy = "PREDEFINED_TRIAL_PLAN"
	SubscriptionDecisionStrategyRequestedPlan               SubscriptionDecisionStrategy = "REQUESTED_PLAN"
	SubscriptionDecisionStrategySkippedSubscriptionCreation SubscriptionDecisionStrategy = "SKIPPED_SUBSCRIPTION_CREATION"
)

var AllSubscriptionDecisionStrategy = []SubscriptionDecisionStrategy{
	SubscriptionDecisionStrategyPredefinedFreePlan,
	SubscriptionDecisionStrategyPredefinedTrialPlan,
	SubscriptionDecisionStrategyRequestedPlan,
	SubscriptionDecisionStrategySkippedSubscriptionCreation,
}

func (e SubscriptionDecisionStrategy) IsValid() bool {
	switch e {
	case SubscriptionDecisionStrategyPredefinedFreePlan, SubscriptionDecisionStrategyPredefinedTrialPlan, SubscriptionDecisionStrategyRequestedPlan, SubscriptionDecisionStrategySkippedSubscriptionCreation:
		return true
	}
	return false
}

func (e SubscriptionDecisionStrategy) String() string {
	return string(e)
}

func (e *SubscriptionDecisionStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionDecisionStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionDecisionStrategy", str)
	}
	return nil
}

func (e SubscriptionDecisionStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionEndSetup string

const (
	SubscriptionEndSetupDowngradeToFree    SubscriptionEndSetup = "DOWNGRADE_TO_FREE"
	SubscriptionEndSetupCancelSubscription SubscriptionEndSetup = "CANCEL_SUBSCRIPTION"
)

var AllSubscriptionEndSetup = []SubscriptionEndSetup{
	SubscriptionEndSetupDowngradeToFree,
	SubscriptionEndSetupCancelSubscription,
}

func (e SubscriptionEndSetup) IsValid() bool {
	switch e {
	case SubscriptionEndSetupDowngradeToFree, SubscriptionEndSetupCancelSubscription:
		return true
	}
	return false
}

func (e SubscriptionEndSetup) String() string {
	return string(e)
}

func (e *SubscriptionEndSetup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEndSetup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionEndSetup", str)
	}
	return nil
}

func (e SubscriptionEndSetup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionMigrationTaskSortFields string

const (
	SubscriptionMigrationTaskSortFieldsID            SubscriptionMigrationTaskSortFields = "id"
	SubscriptionMigrationTaskSortFieldsEnvironmentID SubscriptionMigrationTaskSortFields = "environmentId"
	SubscriptionMigrationTaskSortFieldsCreatedAt     SubscriptionMigrationTaskSortFields = "createdAt"
	SubscriptionMigrationTaskSortFieldsTaskType      SubscriptionMigrationTaskSortFields = "taskType"
	SubscriptionMigrationTaskSortFieldsStatus        SubscriptionMigrationTaskSortFields = "status"
)

var AllSubscriptionMigrationTaskSortFields = []SubscriptionMigrationTaskSortFields{
	SubscriptionMigrationTaskSortFieldsID,
	SubscriptionMigrationTaskSortFieldsEnvironmentID,
	SubscriptionMigrationTaskSortFieldsCreatedAt,
	SubscriptionMigrationTaskSortFieldsTaskType,
	SubscriptionMigrationTaskSortFieldsStatus,
}

func (e SubscriptionMigrationTaskSortFields) IsValid() bool {
	switch e {
	case SubscriptionMigrationTaskSortFieldsID, SubscriptionMigrationTaskSortFieldsEnvironmentID, SubscriptionMigrationTaskSortFieldsCreatedAt, SubscriptionMigrationTaskSortFieldsTaskType, SubscriptionMigrationTaskSortFieldsStatus:
		return true
	}
	return false
}

func (e SubscriptionMigrationTaskSortFields) String() string {
	return string(e)
}

func (e *SubscriptionMigrationTaskSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionMigrationTaskSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionMigrationTaskSortFields", str)
	}
	return nil
}

func (e SubscriptionMigrationTaskSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionPriceSortFields string

const (
	SubscriptionPriceSortFieldsID         SubscriptionPriceSortFields = "id"
	SubscriptionPriceSortFieldsCreatedAt  SubscriptionPriceSortFields = "createdAt"
	SubscriptionPriceSortFieldsUpdatedAt  SubscriptionPriceSortFields = "updatedAt"
	SubscriptionPriceSortFieldsUsageLimit SubscriptionPriceSortFields = "usageLimit"
)

var AllSubscriptionPriceSortFields = []SubscriptionPriceSortFields{
	SubscriptionPriceSortFieldsID,
	SubscriptionPriceSortFieldsCreatedAt,
	SubscriptionPriceSortFieldsUpdatedAt,
	SubscriptionPriceSortFieldsUsageLimit,
}

func (e SubscriptionPriceSortFields) IsValid() bool {
	switch e {
	case SubscriptionPriceSortFieldsID, SubscriptionPriceSortFieldsCreatedAt, SubscriptionPriceSortFieldsUpdatedAt, SubscriptionPriceSortFieldsUsageLimit:
		return true
	}
	return false
}

func (e SubscriptionPriceSortFields) String() string {
	return string(e)
}

func (e *SubscriptionPriceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPriceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionPriceSortFields", str)
	}
	return nil
}

func (e SubscriptionPriceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionStartSetup string

const (
	SubscriptionStartSetupPlanSelection SubscriptionStartSetup = "PLAN_SELECTION"
	SubscriptionStartSetupTrialPeriod   SubscriptionStartSetup = "TRIAL_PERIOD"
	SubscriptionStartSetupFreePlan      SubscriptionStartSetup = "FREE_PLAN"
)

var AllSubscriptionStartSetup = []SubscriptionStartSetup{
	SubscriptionStartSetupPlanSelection,
	SubscriptionStartSetupTrialPeriod,
	SubscriptionStartSetupFreePlan,
}

func (e SubscriptionStartSetup) IsValid() bool {
	switch e {
	case SubscriptionStartSetupPlanSelection, SubscriptionStartSetupTrialPeriod, SubscriptionStartSetupFreePlan:
		return true
	}
	return false
}

func (e SubscriptionStartSetup) String() string {
	return string(e)
}

func (e *SubscriptionStartSetup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStartSetup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionStartSetup", str)
	}
	return nil
}

func (e SubscriptionStartSetup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription status
type SubscriptionStatus string

const (
	SubscriptionStatusPaymentPending SubscriptionStatus = "PAYMENT_PENDING"
	SubscriptionStatusActive         SubscriptionStatus = "ACTIVE"
	SubscriptionStatusExpired        SubscriptionStatus = "EXPIRED"
	SubscriptionStatusInTrial        SubscriptionStatus = "IN_TRIAL"
	SubscriptionStatusCanceled       SubscriptionStatus = "CANCELED"
	SubscriptionStatusNotStarted     SubscriptionStatus = "NOT_STARTED"
)

var AllSubscriptionStatus = []SubscriptionStatus{
	SubscriptionStatusPaymentPending,
	SubscriptionStatusActive,
	SubscriptionStatusExpired,
	SubscriptionStatusInTrial,
	SubscriptionStatusCanceled,
	SubscriptionStatusNotStarted,
}

func (e SubscriptionStatus) IsValid() bool {
	switch e {
	case SubscriptionStatusPaymentPending, SubscriptionStatusActive, SubscriptionStatusExpired, SubscriptionStatusInTrial, SubscriptionStatusCanceled, SubscriptionStatusNotStarted:
		return true
	}
	return false
}

func (e SubscriptionStatus) String() string {
	return string(e)
}

func (e *SubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionStatus", str)
	}
	return nil
}

func (e SubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of the integration sync
type SyncStatus string

const (
	SyncStatusPending        SyncStatus = "PENDING"
	SyncStatusError          SyncStatus = "ERROR"
	SyncStatusSuccess        SyncStatus = "SUCCESS"
	SyncStatusNoSyncRequired SyncStatus = "NO_SYNC_REQUIRED"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusPending,
	SyncStatusError,
	SyncStatusSuccess,
	SyncStatusNoSyncRequired,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusPending, SyncStatusError, SyncStatusSuccess, SyncStatusNoSyncRequired:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TaskStatus string

const (
	TaskStatusPending         TaskStatus = "PENDING"
	TaskStatusInProgress      TaskStatus = "IN_PROGRESS"
	TaskStatusCompleted       TaskStatus = "COMPLETED"
	TaskStatusPartiallyFailed TaskStatus = "PARTIALLY_FAILED"
	TaskStatusFailed          TaskStatus = "FAILED"
)

var AllTaskStatus = []TaskStatus{
	TaskStatusPending,
	TaskStatusInProgress,
	TaskStatusCompleted,
	TaskStatusPartiallyFailed,
	TaskStatusFailed,
}

func (e TaskStatus) IsValid() bool {
	switch e {
	case TaskStatusPending, TaskStatusInProgress, TaskStatusCompleted, TaskStatusPartiallyFailed, TaskStatusFailed:
		return true
	}
	return false
}

func (e TaskStatus) String() string {
	return string(e)
}

func (e *TaskStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskStatus", str)
	}
	return nil
}

func (e TaskStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TaskType string

const (
	TaskTypeSubscriptionMigration      TaskType = "SUBSCRIPTION_MIGRATION"
	TaskTypeResyncIntegration          TaskType = "RESYNC_INTEGRATION"
	TaskTypeImportIntegrationCatalog   TaskType = "IMPORT_INTEGRATION_CATALOG"
	TaskTypeImportIntegrationCustomers TaskType = "IMPORT_INTEGRATION_CUSTOMERS"
)

var AllTaskType = []TaskType{
	TaskTypeSubscriptionMigration,
	TaskTypeResyncIntegration,
	TaskTypeImportIntegrationCatalog,
	TaskTypeImportIntegrationCustomers,
}

func (e TaskType) IsValid() bool {
	switch e {
	case TaskTypeSubscriptionMigration, TaskTypeResyncIntegration, TaskTypeImportIntegrationCatalog, TaskTypeImportIntegrationCustomers:
		return true
	}
	return false
}

func (e TaskType) String() string {
	return string(e)
}

func (e *TaskType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskType", str)
	}
	return nil
}

func (e TaskType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// day or month.
type TrialPeriodUnits string

const (
	TrialPeriodUnitsDay   TrialPeriodUnits = "DAY"
	TrialPeriodUnitsMonth TrialPeriodUnits = "MONTH"
)

var AllTrialPeriodUnits = []TrialPeriodUnits{
	TrialPeriodUnitsDay,
	TrialPeriodUnitsMonth,
}

func (e TrialPeriodUnits) IsValid() bool {
	switch e {
	case TrialPeriodUnitsDay, TrialPeriodUnitsMonth:
		return true
	}
	return false
}

func (e TrialPeriodUnits) String() string {
	return string(e)
}

func (e *TrialPeriodUnits) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrialPeriodUnits(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrialPeriodUnits", str)
	}
	return nil
}

func (e TrialPeriodUnits) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsageMeasurementSortFields string

const (
	UsageMeasurementSortFieldsID            UsageMeasurementSortFields = "id"
	UsageMeasurementSortFieldsEnvironmentID UsageMeasurementSortFields = "environmentId"
	UsageMeasurementSortFieldsCreatedAt     UsageMeasurementSortFields = "createdAt"
)

var AllUsageMeasurementSortFields = []UsageMeasurementSortFields{
	UsageMeasurementSortFieldsID,
	UsageMeasurementSortFieldsEnvironmentID,
	UsageMeasurementSortFieldsCreatedAt,
}

func (e UsageMeasurementSortFields) IsValid() bool {
	switch e {
	case UsageMeasurementSortFieldsID, UsageMeasurementSortFieldsEnvironmentID, UsageMeasurementSortFieldsCreatedAt:
		return true
	}
	return false
}

func (e UsageMeasurementSortFields) String() string {
	return string(e)
}

func (e *UsageMeasurementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageMeasurementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageMeasurementSortFields", str)
	}
	return nil
}

func (e UsageMeasurementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VendorIdentifier string

const (
	VendorIdentifierZuora   VendorIdentifier = "ZUORA"
	VendorIdentifierStripe  VendorIdentifier = "STRIPE"
	VendorIdentifierHubspot VendorIdentifier = "HUBSPOT"
)

var AllVendorIdentifier = []VendorIdentifier{
	VendorIdentifierZuora,
	VendorIdentifierStripe,
	VendorIdentifierHubspot,
}

func (e VendorIdentifier) IsValid() bool {
	switch e {
	case VendorIdentifierZuora, VendorIdentifierStripe, VendorIdentifierHubspot:
		return true
	}
	return false
}

func (e VendorIdentifier) String() string {
	return string(e)
}

func (e *VendorIdentifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorIdentifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorIdentifier", str)
	}
	return nil
}

func (e VendorIdentifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Weekly reset period according to configuration
type WeeklyAccordingTo string

const (
	WeeklyAccordingToSubscriptionStart WeeklyAccordingTo = "SubscriptionStart"
	WeeklyAccordingToEverySunday       WeeklyAccordingTo = "EverySunday"
	WeeklyAccordingToEveryMonday       WeeklyAccordingTo = "EveryMonday"
	WeeklyAccordingToEveryTuesday      WeeklyAccordingTo = "EveryTuesday"
	WeeklyAccordingToEveryWednesday    WeeklyAccordingTo = "EveryWednesday"
	WeeklyAccordingToEveryThursday     WeeklyAccordingTo = "EveryThursday"
	WeeklyAccordingToEveryFriday       WeeklyAccordingTo = "EveryFriday"
	WeeklyAccordingToEverySaturday     WeeklyAccordingTo = "EverySaturday"
)

var AllWeeklyAccordingTo = []WeeklyAccordingTo{
	WeeklyAccordingToSubscriptionStart,
	WeeklyAccordingToEverySunday,
	WeeklyAccordingToEveryMonday,
	WeeklyAccordingToEveryTuesday,
	WeeklyAccordingToEveryWednesday,
	WeeklyAccordingToEveryThursday,
	WeeklyAccordingToEveryFriday,
	WeeklyAccordingToEverySaturday,
}

func (e WeeklyAccordingTo) IsValid() bool {
	switch e {
	case WeeklyAccordingToSubscriptionStart, WeeklyAccordingToEverySunday, WeeklyAccordingToEveryMonday, WeeklyAccordingToEveryTuesday, WeeklyAccordingToEveryWednesday, WeeklyAccordingToEveryThursday, WeeklyAccordingToEveryFriday, WeeklyAccordingToEverySaturday:
		return true
	}
	return false
}

func (e WeeklyAccordingTo) String() string {
	return string(e)
}

func (e *WeeklyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WeeklyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WeeklyAccordingTo", str)
	}
	return nil
}

func (e WeeklyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The widget type
type WidgetType string

const (
	WidgetTypePaywall        WidgetType = "PAYWALL"
	WidgetTypeCustomerPortal WidgetType = "CUSTOMER_PORTAL"
)

var AllWidgetType = []WidgetType{
	WidgetTypePaywall,
	WidgetTypeCustomerPortal,
}

func (e WidgetType) IsValid() bool {
	switch e {
	case WidgetTypePaywall, WidgetTypeCustomerPortal:
		return true
	}
	return false
}

func (e WidgetType) String() string {
	return string(e)
}

func (e *WidgetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetType", str)
	}
	return nil
}

func (e WidgetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The group of the experiment
type ExperimentGroupType string

const (
	ExperimentGroupTypeControl ExperimentGroupType = "CONTROL"
	ExperimentGroupTypeVariant ExperimentGroupType = "VARIANT"
)

var AllExperimentGroupType = []ExperimentGroupType{
	ExperimentGroupTypeControl,
	ExperimentGroupTypeVariant,
}

func (e ExperimentGroupType) IsValid() bool {
	switch e {
	case ExperimentGroupTypeControl, ExperimentGroupTypeVariant:
		return true
	}
	return false
}

func (e ExperimentGroupType) String() string {
	return string(e)
}

func (e *ExperimentGroupType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentGroupType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid experimentGroupType", str)
	}
	return nil
}

func (e ExperimentGroupType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
