// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package stigg

import (
	"fmt"
	"io"
	"strconv"
)

type Credentials interface {
	IsCredentials()
}

type ResetPeriodConfiguration interface {
	IsResetPeriodConfiguration()
}

type ScheduleVariables interface {
	IsScheduleVariables()
}

type Account struct {
	AccountEmailDomain            *string            `json:"accountEmailDomain"`
	AccountStatus                 *AccountStatus     `json:"accountStatus"`
	DisplayName                   string             `json:"displayName"`
	ID                            string             `json:"id"`
	SamlEnabled                   *bool              `json:"samlEnabled"`
	SubscriptionBillingAnchor     *BillingAnchor     `json:"subscriptionBillingAnchor"`
	SubscriptionProrationBehavior *ProrationBehavior `json:"subscriptionProrationBehavior"`
	Timezone                      *string            `json:"timezone"`
}

type AccountNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type AddCompatibleAddonsToPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type AdditionalMetaDataChange struct {
	After      map[string]interface{} `json:"after"`
	Before     map[string]interface{} `json:"before"`
	ChangeType *ChangeType            `json:"changeType"`
}

type Addon struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	CreatedAt          *string                `json:"createdAt"`
	Description        *string                `json:"description"`
	DisplayName        string                 `json:"displayName"`
	DraftDetails       *PackageDraftDetails   `json:"draftDetails"`
	DraftSummary       *PackageDraftSummary   `json:"draftSummary"`
	Entitlements       []*PackageEntitlement  `json:"entitlements"`
	Environment        Environment            `json:"environment"`
	EnvironmentID      string                 `json:"environmentId"`
	HiddenFromWidgets  []WidgetType           `json:"hiddenFromWidgets"`
	ID                 string                 `json:"id"`
	IsLatest           *bool                  `json:"isLatest"`
	OveragePrices      []*Price               `json:"overagePrices"`
	Prices             []*Price               `json:"prices"`
	PricingType        *PricingType           `json:"pricingType"`
	Product            *Product               `json:"product"`
	ProductID          *string                `json:"productId"`
	RefID              string                 `json:"refId"`
	Status             PackageStatus          `json:"status"`
	SyncStates         []*SyncState           `json:"syncStates"`
	Type               string                 `json:"type"`
	UpdatedAt          *string                `json:"updatedAt"`
	VersionNumber      int64                  `json:"versionNumber"`
}

type AddonAggregateGroupBy struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	IsLatest      *bool          `json:"isLatest"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type AddonChangeVariables struct {
	AddonRefID  string  `json:"addonRefId"`
	NewQuantity float64 `json:"newQuantity"`
}

func (AddonChangeVariables) IsScheduleVariables() {}

type AddonConnection struct {
	// Array of edges.
	Edges []*AddonEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type AddonCountAggregate struct {
	BillingID     *int64 `json:"billingId"`
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	DisplayName   *int64 `json:"displayName"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	IsLatest      *int64 `json:"isLatest"`
	PricingType   *int64 `json:"pricingType"`
	ProductID     *int64 `json:"productId"`
	RefID         *int64 `json:"refId"`
	Status        *int64 `json:"status"`
	UpdatedAt     *int64 `json:"updatedAt"`
	VersionNumber *int64 `json:"versionNumber"`
}

type AddonCreateInput struct {
	AdditionalMetaData          map[string]interface{} `json:"additionalMetaData,omitempty"`
	AwsMarketplacePlanDimension *string                `json:"awsMarketplacePlanDimension,omitempty"`
	BillingID                   *string                `json:"billingId,omitempty"`
	Description                 *string                `json:"description,omitempty"`
	DisplayName                 string                 `json:"displayName"`
	EnvironmentID               *string                `json:"environmentId,omitempty"`
	HiddenFromWidgets           []WidgetType           `json:"hiddenFromWidgets,omitempty"`
	PricingType                 *PricingType           `json:"pricingType,omitempty"`
	ProductID                   string                 `json:"productId"`
	RefID                       *string                `json:"refId,omitempty"`
	Status                      *PackageStatus         `json:"status,omitempty"`
}

type AddonDeleteResponse struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	CreatedAt          *string                `json:"createdAt"`
	Description        *string                `json:"description"`
	DisplayName        *string                `json:"displayName"`
	DraftDetails       *PackageDraftDetails   `json:"draftDetails"`
	DraftSummary       *PackageDraftSummary   `json:"draftSummary"`
	Entitlements       []*PackageEntitlement  `json:"entitlements"`
	EnvironmentID      *string                `json:"environmentId"`
	HiddenFromWidgets  []WidgetType           `json:"hiddenFromWidgets"`
	ID                 *string                `json:"id"`
	IsLatest           *bool                  `json:"isLatest"`
	OveragePrices      []*Price               `json:"overagePrices"`
	Prices             []*Price               `json:"prices"`
	PricingType        *PricingType           `json:"pricingType"`
	ProductID          *string                `json:"productId"`
	RefID              *string                `json:"refId"`
	Status             *PackageStatus         `json:"status"`
	SyncStates         []*SyncState           `json:"syncStates"`
	Type               *string                `json:"type"`
	UpdatedAt          *string                `json:"updatedAt"`
	VersionNumber      *int64                 `json:"versionNumber"`
}

type AddonEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Addon
	Node Addon `json:"node"`
}

type AddonFilter struct {
	And           []*AddonFilter                 `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*AddonFilter                 `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type AddonMaxAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonMinAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonSort struct {
	Direction SortDirection   `json:"direction"`
	Field     AddonSortFields `json:"field"`
	Nulls     *SortNulls      `json:"nulls,omitempty"`
}

type AddonSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type AddonUpdateInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	Description        *string                `json:"description,omitempty"`
	DisplayName        *string                `json:"displayName,omitempty"`
	HiddenFromWidgets  []WidgetType           `json:"hiddenFromWidgets,omitempty"`
	ID                 string                 `json:"id"`
	Status             *PackageStatus         `json:"status,omitempty"`
}

type Address struct {
	AddressLine1 *string `json:"addressLine1,omitempty"`
	AddressLine2 *string `json:"addressLine2,omitempty"`
	City         *string `json:"city,omitempty"`
	Country      *string `json:"country,omitempty"`
	PhoneNumber  *string `json:"phoneNumber,omitempty"`
	PostalCode   *string `json:"postalCode,omitempty"`
	State        *string `json:"state,omitempty"`
}

type AggregatedEventsByCustomer struct {
	AggregatedUsage []*CustomerAggregatedUsage `json:"aggregatedUsage"`
}

type AggregatedEventsByCustomerInput struct {
	Aggregation   MeterAggregation              `json:"aggregation"`
	CustomerID    *string                       `json:"customerId,omitempty"`
	EnvironmentID string                        `json:"environmentId"`
	Filters       []*MeterFilterDefinitionInput `json:"filters"`
}

type Aggregation struct {
	Field    *string             `json:"field"`
	Function AggregationFunction `json:"function"`
}

type APIKey struct {
	ID      string     `json:"id"`
	KeyType APIKeyType `json:"keyType"`
	Token   string     `json:"token"`
}

type APIKeyFilter struct {
	And []*APIKeyFilter        `json:"and,omitempty"`
	ID  *StringFieldComparison `json:"id,omitempty"`
	Or  []*APIKeyFilter        `json:"or,omitempty"`
}

type APIKeySort struct {
	Direction SortDirection    `json:"direction"`
	Field     APIKeySortFields `json:"field"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

type ApplySubscription struct {
	Entitlements []*Entitlement        `json:"entitlements"`
	Subscription *CustomerSubscription `json:"subscription"`
}

type ApplySubscriptionInput struct {
	AdditionalMetaData         map[string]interface{}           `json:"additionalMetaData,omitempty"`
	Addons                     []*SubscriptionAddonInput        `json:"addons,omitempty"`
	BillableFeatures           []*BillableFeatureInput          `json:"billableFeatures,omitempty"`
	BillingCountryCode         *string                          `json:"billingCountryCode,omitempty"`
	BillingID                  *string                          `json:"billingId,omitempty"`
	BillingInformation         *SubscriptionBillingInfo         `json:"billingInformation,omitempty"`
	BillingPeriod              *BillingPeriod                   `json:"billingPeriod,omitempty"`
	CustomerID                 string                           `json:"customerId"`
	PaymentMethodID            *string                          `json:"paymentMethodId,omitempty"`
	PlanID                     string                           `json:"planId"`
	PromotionCode              *string                          `json:"promotionCode,omitempty"`
	ResourceID                 *string                          `json:"resourceId,omitempty"`
	SkipTrial                  *bool                            `json:"skipTrial,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

type ArchiveCouponInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	RefID         string  `json:"refId"`
}

type ArchiveCustomerInput struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type ArchiveEnvironmentInput struct {
	ID   *string `json:"id,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

type ArchiveFeatureInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	ID            string  `json:"id"`
}

type ArchivePlanInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	ID            string  `json:"id"`
}

type AsyncTaskResult struct {
	TaskID string `json:"taskId"`
}

type AttachCustomerPaymentMethodInput struct {
	CustomerID       *string          `json:"customerId,omitempty"`
	EnvironmentID    *string          `json:"environmentId,omitempty"`
	PaymentMethodID  string           `json:"paymentMethodId"`
	RefID            *string          `json:"refId,omitempty"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

type AwsDimension struct {
	Description   string  `json:"description"`
	Key           string  `json:"key"`
	Name          string  `json:"name"`
	StiggPlanID   *string `json:"stiggPlanId"`
	StiggPlanName *string `json:"stiggPlanName"`
	Type          string  `json:"type"`
	Unit          string  `json:"unit"`
}

type AwsMarketplaceCredentials struct {
	AwsRoleArn string `json:"awsRoleArn"`
}

func (AwsMarketplaceCredentials) IsCredentials() {}

type AwsMarketplaceCredentialsInput struct {
	AwsRoleArn string `json:"awsRoleArn"`
}

type AwsProduct struct {
	Description       string  `json:"description"`
	LogoURL           *string `json:"logoUrl"`
	ProductCode       string  `json:"productCode"`
	ProductID         string  `json:"productId"`
	StiggProductID    *string `json:"stiggProductId"`
	StiggProductRefID *string `json:"stiggProductRefId"`
	Title             string  `json:"title"`
	Visibility        string  `json:"visibility"`
}

type BaseError struct {
	Code string `json:"code"`
}

type BasePlanChange struct {
	After      *Addon      `json:"after"`
	Before     *Addon      `json:"before"`
	ChangeType *ChangeType `json:"changeType"`
}

type BillableFeature struct {
	FeatureID string  `json:"featureId"`
	Quantity  float64 `json:"quantity"`
}

type BillableFeatureInput struct {
	FeatureID string  `json:"featureId"`
	Quantity  float64 `json:"quantity"`
}

type BillingAddress struct {
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	Line1      *string `json:"line1,omitempty"`
	Line2      *string `json:"line2,omitempty"`
	PostalCode *string `json:"postalCode,omitempty"`
	State      *string `json:"state,omitempty"`
}

type BillingModelFilterComparison struct {
	Eq       *BillingModel  `json:"eq,omitempty"`
	Gt       *BillingModel  `json:"gt,omitempty"`
	Gte      *BillingModel  `json:"gte,omitempty"`
	ILike    *BillingModel  `json:"iLike,omitempty"`
	In       []BillingModel `json:"in,omitempty"`
	Is       *bool          `json:"is,omitempty"`
	IsNot    *bool          `json:"isNot,omitempty"`
	Like     *BillingModel  `json:"like,omitempty"`
	Lt       *BillingModel  `json:"lt,omitempty"`
	Lte      *BillingModel  `json:"lte,omitempty"`
	Neq      *BillingModel  `json:"neq,omitempty"`
	NotILike *BillingModel  `json:"notILike,omitempty"`
	NotIn    []BillingModel `json:"notIn,omitempty"`
	NotLike  *BillingModel  `json:"notLike,omitempty"`
}

type BillingPeriodChangeVariables struct {
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
}

func (BillingPeriodChangeVariables) IsScheduleVariables() {}

type BillingPeriodFilterComparison struct {
	Eq       *BillingPeriod  `json:"eq,omitempty"`
	Gt       *BillingPeriod  `json:"gt,omitempty"`
	Gte      *BillingPeriod  `json:"gte,omitempty"`
	ILike    *BillingPeriod  `json:"iLike,omitempty"`
	In       []BillingPeriod `json:"in,omitempty"`
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Like     *BillingPeriod  `json:"like,omitempty"`
	Lt       *BillingPeriod  `json:"lt,omitempty"`
	Lte      *BillingPeriod  `json:"lte,omitempty"`
	Neq      *BillingPeriod  `json:"neq,omitempty"`
	NotILike *BillingPeriod  `json:"notILike,omitempty"`
	NotIn    []BillingPeriod `json:"notIn,omitempty"`
	NotLike  *BillingPeriod  `json:"notLike,omitempty"`
}

type BooleanFieldComparison struct {
	Is    *bool `json:"is,omitempty"`
	IsNot *bool `json:"isNot,omitempty"`
}

type CannotDeleteCustomerError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CannotDeleteFeatureError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CheckoutBillingIntegration struct {
	BillingIdentifier BillingVendorIdentifier `json:"billingIdentifier"`
	Credentials       CheckoutCredentials     `json:"credentials"`
}

type CheckoutColorPalette struct {
	BackgroundColor        *string `json:"backgroundColor"`
	BorderColor            *string `json:"borderColor"`
	Primary                *string `json:"primary"`
	SummaryBackgroundColor *string `json:"summaryBackgroundColor"`
	TextColor              *string `json:"textColor"`
}

type CheckoutConfiguration struct {
	Content    *CheckoutContent         `json:"content"`
	CustomCSS  *string                  `json:"customCss"`
	Palette    *CheckoutColorPalette    `json:"palette"`
	Typography *TypographyConfiguration `json:"typography"`
}

type CheckoutConfigurationInput struct {
	Content    *CheckoutContentInput         `json:"content,omitempty"`
	CustomCSS  *string                       `json:"customCss,omitempty"`
	Palette    *CheckoutPaletteInput         `json:"palette,omitempty"`
	Typography *TypographyConfigurationInput `json:"typography,omitempty"`
}

type CheckoutContent struct {
	CollectPhoneNumber *bool `json:"collectPhoneNumber"`
}

type CheckoutContentInput struct {
	CollectPhoneNumber *bool `json:"collectPhoneNumber,omitempty"`
}

type CheckoutCredentials struct {
	AccountID string `json:"accountId"`
	PublicKey string `json:"publicKey"`
}

type CheckoutOptions struct {
	AllowPromoCodes       *bool   `json:"allowPromoCodes,omitempty"`
	AllowTaxIDCollection  *bool   `json:"allowTaxIdCollection,omitempty"`
	CancelURL             string  `json:"cancelUrl"`
	CollectBillingAddress *bool   `json:"collectBillingAddress,omitempty"`
	CollectPhoneNumber    *bool   `json:"collectPhoneNumber,omitempty"`
	ReferenceID           *string `json:"referenceId,omitempty"`
	SuccessURL            string  `json:"successUrl"`
}

type CheckoutPaletteInput struct {
	BackgroundColor        *string `json:"backgroundColor,omitempty"`
	BorderColor            *string `json:"borderColor,omitempty"`
	Primary                *string `json:"primary,omitempty"`
	SummaryBackgroundColor *string `json:"summaryBackgroundColor,omitempty"`
	TextColor              *string `json:"textColor,omitempty"`
}

type CheckoutState struct {
	ActiveSubscription *CustomerSubscription      `json:"activeSubscription"`
	BillingIntegration CheckoutBillingIntegration `json:"billingIntegration"`
	Configuration      *CheckoutConfiguration     `json:"configuration"`
	Customer           Customer                   `json:"customer"`
	Plan               Plan                       `json:"plan"`
	Resource           *CustomerResource          `json:"resource"`
	SetupSecret        string                     `json:"setupSecret"`
}

type CheckoutStateInput struct {
	BillingCountryCode *string `json:"billingCountryCode,omitempty"`
	CustomerID         string  `json:"customerId"`
	PlanID             string  `json:"planId"`
	ResourceID         *string `json:"resourceId,omitempty"`
}

type ClearCustomerPersistentCacheInput struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
	ResourceID    *string `json:"resourceId,omitempty"`
}

type Coupon struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	CreatedAt          string                 `json:"createdAt"`
	Customers          []*Customer            `json:"customers"`
	Description        *string                `json:"description"`
	DiscountValue      float64                `json:"discountValue"`
	Environment        *Environment           `json:"environment"`
	EnvironmentID      string                 `json:"environmentId"`
	ID                 string                 `json:"id"`
	Name               string                 `json:"name"`
	RefID              string                 `json:"refId"`
	Status             CouponStatus           `json:"status"`
	SyncStates         []*SyncState           `json:"syncStates"`
	Type               CouponType             `json:"type"`
	UpdatedAt          string                 `json:"updatedAt"`
}

type CouponAggregateGroupBy struct {
	BillingID     *string       `json:"billingId"`
	CreatedAt     *string       `json:"createdAt"`
	Description   *string       `json:"description"`
	EnvironmentID *string       `json:"environmentId"`
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Status        *CouponStatus `json:"status"`
	Type          *CouponType   `json:"type"`
	UpdatedAt     *string       `json:"updatedAt"`
}

type CouponAvgAggregate struct {
	ID *float64 `json:"id"`
}

type CouponConnection struct {
	// Array of edges.
	Edges []*CouponEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CouponCountAggregate struct {
	BillingID     *int64 `json:"billingId"`
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Name          *int64 `json:"name"`
	RefID         *int64 `json:"refId"`
	Status        *int64 `json:"status"`
	Type          *int64 `json:"type"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type CouponEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Coupon
	Node Coupon `json:"node"`
}

type CouponFilter struct {
	And           []*CouponFilter               `json:"and,omitempty"`
	BillingID     *StringFieldComparison        `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison          `json:"createdAt,omitempty"`
	Customers     *CouponFilterCustomerFilter   `json:"customers,omitempty"`
	Description   *StringFieldComparison        `json:"description,omitempty"`
	EnvironmentID *StringFieldComparison        `json:"environmentId,omitempty"`
	ID            *StringFieldComparison        `json:"id,omitempty"`
	Name          *StringFieldComparison        `json:"name,omitempty"`
	Or            []*CouponFilter               `json:"or,omitempty"`
	RefID         *StringFieldComparison        `json:"refId,omitempty"`
	Status        *CouponStatusFilterComparison `json:"status,omitempty"`
	Type          *CouponTypeFilterComparison   `json:"type,omitempty"`
	UpdatedAt     *DateFieldComparison          `json:"updatedAt,omitempty"`
}

type CouponFilterCustomerFilter struct {
	And                  []*CouponFilterCustomerFilter        `json:"and,omitempty"`
	BillingID            *StringFieldComparison               `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                 `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison               `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison               `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison               `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison               `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                 `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison               `json:"email,omitempty"`
	EnvironmentID        *StringFieldComparison               `json:"environmentId,omitempty"`
	ID                   *StringFieldComparison               `json:"id,omitempty"`
	Name                 *StringFieldComparison               `json:"name,omitempty"`
	Or                   []*CouponFilterCustomerFilter        `json:"or,omitempty"`
	RefID                *StringFieldComparison               `json:"refId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                 `json:"updatedAt,omitempty"`
}

type CouponMaxAggregate struct {
	BillingID     *string       `json:"billingId"`
	CreatedAt     *string       `json:"createdAt"`
	Description   *string       `json:"description"`
	EnvironmentID *string       `json:"environmentId"`
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Status        *CouponStatus `json:"status"`
	Type          *CouponType   `json:"type"`
	UpdatedAt     *string       `json:"updatedAt"`
}

type CouponMinAggregate struct {
	BillingID     *string       `json:"billingId"`
	CreatedAt     *string       `json:"createdAt"`
	Description   *string       `json:"description"`
	EnvironmentID *string       `json:"environmentId"`
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Status        *CouponStatus `json:"status"`
	Type          *CouponType   `json:"type"`
	UpdatedAt     *string       `json:"updatedAt"`
}

type CouponSort struct {
	Direction SortDirection    `json:"direction"`
	Field     CouponSortFields `json:"field"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

type CouponStatusFilterComparison struct {
	Eq       *CouponStatus  `json:"eq,omitempty"`
	Gt       *CouponStatus  `json:"gt,omitempty"`
	Gte      *CouponStatus  `json:"gte,omitempty"`
	ILike    *CouponStatus  `json:"iLike,omitempty"`
	In       []CouponStatus `json:"in,omitempty"`
	Is       *bool          `json:"is,omitempty"`
	IsNot    *bool          `json:"isNot,omitempty"`
	Like     *CouponStatus  `json:"like,omitempty"`
	Lt       *CouponStatus  `json:"lt,omitempty"`
	Lte      *CouponStatus  `json:"lte,omitempty"`
	Neq      *CouponStatus  `json:"neq,omitempty"`
	NotILike *CouponStatus  `json:"notILike,omitempty"`
	NotIn    []CouponStatus `json:"notIn,omitempty"`
	NotLike  *CouponStatus  `json:"notLike,omitempty"`
}

type CouponSumAggregate struct {
	ID *float64 `json:"id"`
}

type CouponTypeFilterComparison struct {
	Eq       *CouponType  `json:"eq,omitempty"`
	Gt       *CouponType  `json:"gt,omitempty"`
	Gte      *CouponType  `json:"gte,omitempty"`
	ILike    *CouponType  `json:"iLike,omitempty"`
	In       []CouponType `json:"in,omitempty"`
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Like     *CouponType  `json:"like,omitempty"`
	Lt       *CouponType  `json:"lt,omitempty"`
	Lte      *CouponType  `json:"lte,omitempty"`
	Neq      *CouponType  `json:"neq,omitempty"`
	NotILike *CouponType  `json:"notILike,omitempty"`
	NotIn    []CouponType `json:"notIn,omitempty"`
	NotLike  *CouponType  `json:"notLike,omitempty"`
}

type CreateCouponInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	Description        *string                `json:"description,omitempty"`
	DiscountValue      float64                `json:"discountValue"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	Name               string                 `json:"name"`
	RefID              string                 `json:"refId"`
	Type               CouponType             `json:"type"`
}

type CreateEnvironment struct {
	Color                     *string                     `json:"color,omitempty"`
	CreatedAt                 *string                     `json:"createdAt,omitempty"`
	Description               *string                     `json:"description,omitempty"`
	DisplayName               *string                     `json:"displayName,omitempty"`
	HardenClientAccessEnabled *bool                       `json:"hardenClientAccessEnabled,omitempty"`
	ID                        *string                     `json:"id,omitempty"`
	ProvisionStatus           *EnvironmentProvisionStatus `json:"provisionStatus,omitempty"`
	Slug                      *string                     `json:"slug,omitempty"`
	Type                      *EnvironmentType            `json:"type,omitempty"`
}

type CreateEnvironmentOptions struct {
	CreateDefaultProduct *bool `json:"createDefaultProduct,omitempty"`
}

type CreateExperimentInput struct {
	ControlGroupName  string                `json:"controlGroupName"`
	Description       *string               `json:"description,omitempty"`
	EnvironmentID     *string               `json:"environmentId,omitempty"`
	Name              string                `json:"name"`
	ProductID         string                `json:"productId"`
	ProductSettings   *ProductSettingsInput `json:"productSettings,omitempty"`
	VariantGroupName  string                `json:"variantGroupName"`
	VariantPercentage float64               `json:"variantPercentage"`
}

type CreateHook struct {
	CreatedAt     *string        `json:"createdAt,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Endpoint      *string        `json:"endpoint,omitempty"`
	EnvironmentID *string        `json:"environmentId,omitempty"`
	EventLogTypes []EventLogType `json:"eventLogTypes,omitempty"`
	ID            *string        `json:"id,omitempty"`
	SecretKey     *string        `json:"secretKey,omitempty"`
	Status        *HookStatus    `json:"status,omitempty"`
}

type CreateIntegrationInput struct {
	AwsMarketplaceCredentials *AwsMarketplaceCredentialsInput `json:"awsMarketplaceCredentials,omitempty"`
	EnvironmentID             string                          `json:"environmentId"`
	HubspotCredentials        *HubspotCredentialsInput        `json:"hubspotCredentials,omitempty"`
	StripeCredentials         *StripeCredentialsInput         `json:"stripeCredentials,omitempty"`
	VendorIdentifier          VendorIdentifier                `json:"vendorIdentifier"`
	ZuoraCredentials          *ZuoraCredentialsInput          `json:"zuoraCredentials,omitempty"`
}

type CreateManyPackageEntitlementsInput struct {
	// Array of records to create
	PackageEntitlements []*PackageEntitlementInput `json:"packageEntitlements"`
}

type CreateManyPromotionalEntitlementsInput struct {
	// Array of records to create
	PromotionalEntitlements []*PromotionalEntitlementInput `json:"promotionalEntitlements"`
}

type CreateMeter struct {
	Aggregation MeterAggregation              `json:"aggregation"`
	Filters     []*MeterFilterDefinitionInput `json:"filters"`
}

type CreateOneEnvironmentInput struct {
	Environment CreateEnvironment         `json:"environment"`
	Options     *CreateEnvironmentOptions `json:"options,omitempty"`
}

type CreateOneFeatureInput struct {
	// The record to create
	Feature FeatureInput `json:"feature"`
}

type CreateOneHookInput struct {
	// The record to create
	Hook CreateHook `json:"hook"`
}

type CreateOneIntegrationInput struct {
	// The record to create
	Integration CreateIntegrationInput `json:"integration"`
}

type CreateOneProductInput struct {
	// The record to create
	Product ProductCreateInput `json:"product"`
}

type CreateOrUpdateAwsMarketplaceProductInput struct {
	AdditionalMetaData    map[string]interface{}    `json:"additionalMetaData,omitempty"`
	AwsDimensionsMapping  []*DimensionsMappingInput `json:"awsDimensionsMapping"`
	AwsProductID          *string                   `json:"awsProductId,omitempty"`
	Description           *string                   `json:"description,omitempty"`
	DisplayName           *string                   `json:"displayName,omitempty"`
	EnvironmentID         *string                   `json:"environmentId,omitempty"`
	MultipleSubscriptions *bool                     `json:"multipleSubscriptions,omitempty"`
	ProductID             *string                   `json:"productId,omitempty"`
	ProductSettings       *ProductSettingsInput     `json:"productSettings,omitempty"`
	RefID                 *string                   `json:"refId,omitempty"`
}

type CursorPaging struct {
	// Paginate after opaque cursor
	After *string `json:"after,omitempty"`
	// Paginate before opaque cursor
	Before *string `json:"before,omitempty"`
	// Paginate first
	First *int64 `json:"first,omitempty"`
	// Paginate last
	Last *int64 `json:"last,omitempty"`
}

type Customer struct {
	AdditionalMetaData                 map[string]interface{}    `json:"additionalMetaData"`
	AwsMarketplaceCustomerID           *string                   `json:"awsMarketplaceCustomerId"`
	BillingCurrency                    *Currency                 `json:"billingCurrency"`
	BillingID                          *string                   `json:"billingId"`
	BillingLinkURL                     *string                   `json:"billingLinkUrl"`
	Coupon                             *Coupon                   `json:"coupon"`
	CreatedAt                          *string                   `json:"createdAt"`
	CrmHubspotCompanyID                *string                   `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL               *string                   `json:"crmHubspotCompanyUrl"`
	CrmID                              *string                   `json:"crmId"`
	CustomerID                         string                    `json:"customerId"`
	DefaultPaymentExpirationMonth      *int64                    `json:"defaultPaymentExpirationMonth"`
	DefaultPaymentExpirationYear       *int64                    `json:"defaultPaymentExpirationYear"`
	DefaultPaymentMethodID             *string                   `json:"defaultPaymentMethodId"`
	DefaultPaymentMethodLast4Digits    *string                   `json:"defaultPaymentMethodLast4Digits"`
	DefaultPaymentMethodType           *PaymentMethodType        `json:"defaultPaymentMethodType"`
	DeletedAt                          *string                   `json:"deletedAt"`
	EligibleForTrial                   []*EligibleForTrial       `json:"eligibleForTrial"`
	Email                              *string                   `json:"email"`
	Environment                        *Environment              `json:"environment"`
	EnvironmentID                      string                    `json:"environmentId"`
	ExcludeFromExperiment              *bool                     `json:"excludeFromExperiment"`
	Experiment                         *Experiment               `json:"experiment"`
	ExperimentInfo                     *ExperimentInfo           `json:"experimentInfo"`
	HasActiveResource                  bool                      `json:"hasActiveResource"`
	HasActiveSubscription              bool                      `json:"hasActiveSubscription"`
	HasPaymentMethod                   bool                      `json:"hasPaymentMethod"`
	ID                                 string                    `json:"id"`
	Name                               *string                   `json:"name"`
	PromotionalEntitlements            []*PromotionalEntitlement `json:"promotionalEntitlements"`
	RefID                              string                    `json:"refId"`
	Statistics                         *CustomerStatistics       `json:"statistics"`
	Subscriptions                      []*CustomerSubscription   `json:"subscriptions"`
	SyncStates                         []*SyncState              `json:"syncStates"`
	TotalActivePromotionalEntitlements float64                   `json:"totalActivePromotionalEntitlements"`
	TotalActiveSubscription            float64                   `json:"totalActiveSubscription"`
	TrialedPlans                       []*TrialedPlan            `json:"trialedPlans"`
	UpdatedAt                          string                    `json:"updatedAt"`
}

type CustomerAggregateGroupBy struct {
	BillingID            *string `json:"billingId"`
	CreatedAt            *string `json:"createdAt"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
	CrmID                *string `json:"crmId"`
	CustomerID           *string `json:"customerId"`
	DeletedAt            *string `json:"deletedAt"`
	Email                *string `json:"email"`
	EnvironmentID        *string `json:"environmentId"`
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	RefID                *string `json:"refId"`
	SearchQuery          *string `json:"searchQuery"`
	UpdatedAt            *string `json:"updatedAt"`
}

type CustomerAggregatedUsage struct {
	CustomerID string  `json:"customerId"`
	Usage      float64 `json:"usage"`
}

type CustomerBillingInfo struct {
	BillingAddress      *Address               `json:"billingAddress,omitempty"`
	Currency            *Currency              `json:"currency,omitempty"`
	CustomerName        *string                `json:"customerName,omitempty"`
	InvoiceCustomFields map[string]interface{} `json:"invoiceCustomFields,omitempty"`
	Language            *string                `json:"language,omitempty"`
	Metadata            map[string]interface{} `json:"metadata,omitempty"`
	PaymentMethodID     *string                `json:"paymentMethodId,omitempty"`
	ShippingAddress     *Address               `json:"shippingAddress,omitempty"`
	TaxIds              []*TaxExempt           `json:"taxIds,omitempty"`
	Timezone            *string                `json:"timezone,omitempty"`
}

type CustomerConnection struct {
	// Array of edges.
	Edges []*CustomerEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerCountAggregate struct {
	BillingID            *int64 `json:"billingId"`
	CreatedAt            *int64 `json:"createdAt"`
	CrmHubspotCompanyID  *int64 `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *int64 `json:"crmHubspotCompanyUrl"`
	CrmID                *int64 `json:"crmId"`
	CustomerID           *int64 `json:"customerId"`
	DeletedAt            *int64 `json:"deletedAt"`
	Email                *int64 `json:"email"`
	EnvironmentID        *int64 `json:"environmentId"`
	ID                   *int64 `json:"id"`
	Name                 *int64 `json:"name"`
	RefID                *int64 `json:"refId"`
	SearchQuery          *int64 `json:"searchQuery"`
	UpdatedAt            *int64 `json:"updatedAt"`
}

type CustomerEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Customer
	Node Customer `json:"node"`
}

type CustomerFilter struct {
	And                     []*CustomerFilter                           `json:"and,omitempty"`
	BillingID               *StringFieldComparison                      `json:"billingId,omitempty"`
	CreatedAt               *DateFieldComparison                        `json:"createdAt,omitempty"`
	CrmHubspotCompanyID     *StringFieldComparison                      `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL    *StringFieldComparison                      `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                   *StringFieldComparison                      `json:"crmId,omitempty"`
	CustomerID              *StringFieldComparison                      `json:"customerId,omitempty"`
	DeletedAt               *DateFieldComparison                        `json:"deletedAt,omitempty"`
	Email                   *StringFieldComparison                      `json:"email,omitempty"`
	EnvironmentID           *StringFieldComparison                      `json:"environmentId,omitempty"`
	ID                      *StringFieldComparison                      `json:"id,omitempty"`
	Name                    *StringFieldComparison                      `json:"name,omitempty"`
	Or                      []*CustomerFilter                           `json:"or,omitempty"`
	PromotionalEntitlements *CustomerFilterPromotionalEntitlementFilter `json:"promotionalEntitlements,omitempty"`
	RefID                   *StringFieldComparison                      `json:"refId,omitempty"`
	SearchQuery             *CustomerSearchQueryFilterComparison        `json:"searchQuery,omitempty"`
	Subscriptions           *CustomerFilterCustomerSubscriptionFilter   `json:"subscriptions,omitempty"`
	UpdatedAt               *DateFieldComparison                        `json:"updatedAt,omitempty"`
}

type CustomerFilterCustomerSubscriptionFilter struct {
	And                       []*CustomerFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingID                 *StringFieldComparison                      `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison   `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                        `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                        `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                      `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                      `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                        `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                        `json:"currentBillingPeriodStart,omitempty"`
	EffectiveEndDate          *DateFieldComparison                        `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                        `json:"endDate,omitempty"`
	EnvironmentID             *StringFieldComparison                      `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison                      `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                      `json:"oldBillingId,omitempty"`
	Or                        []*CustomerFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison          `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                      `json:"refId,omitempty"`
	ResourceID                *StringFieldComparison                      `json:"resourceId,omitempty"`
	StartDate                 *DateFieldComparison                        `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison         `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                      `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                        `json:"trialEndDate,omitempty"`
}

type CustomerFilterPromotionalEntitlementFilter struct {
	And           []*CustomerFilterPromotionalEntitlementFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison                        `json:"environmentId,omitempty"`
	ID            *StringFieldComparison                        `json:"id,omitempty"`
	Or            []*CustomerFilterPromotionalEntitlementFilter `json:"or,omitempty"`
	Status        *PromotionalEntitlementStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
}

type CustomerInput struct {
	AdditionalMetaData       map[string]interface{} `json:"additionalMetaData,omitempty"`
	AwsMarketplaceCustomerID *string                `json:"awsMarketplaceCustomerId,omitempty"`
	BillingID                *string                `json:"billingId,omitempty"`
	BillingInformation       *CustomerBillingInfo   `json:"billingInformation,omitempty"`
	CouponRefID              *string                `json:"couponRefId,omitempty"`
	CreatedAt                *string                `json:"createdAt,omitempty"`
	CrmID                    *string                `json:"crmId,omitempty"`
	CustomerID               *string                `json:"customerId,omitempty"`
	Email                    *string                `json:"email,omitempty"`
	EnvironmentID            *string                `json:"environmentId,omitempty"`
	Name                     *string                `json:"name,omitempty"`
	RefID                    *string                `json:"refId,omitempty"`
	ShouldSyncFree           *bool                  `json:"shouldSyncFree,omitempty"`
}

type CustomerMaxAggregate struct {
	BillingID            *string `json:"billingId"`
	CreatedAt            *string `json:"createdAt"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
	CrmID                *string `json:"crmId"`
	CustomerID           *string `json:"customerId"`
	DeletedAt            *string `json:"deletedAt"`
	Email                *string `json:"email"`
	EnvironmentID        *string `json:"environmentId"`
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	RefID                *string `json:"refId"`
	SearchQuery          *string `json:"searchQuery"`
	UpdatedAt            *string `json:"updatedAt"`
}

type CustomerMinAggregate struct {
	BillingID            *string `json:"billingId"`
	CreatedAt            *string `json:"createdAt"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
	CrmID                *string `json:"crmId"`
	CustomerID           *string `json:"customerId"`
	DeletedAt            *string `json:"deletedAt"`
	Email                *string `json:"email"`
	EnvironmentID        *string `json:"environmentId"`
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	RefID                *string `json:"refId"`
	SearchQuery          *string `json:"searchQuery"`
	UpdatedAt            *string `json:"updatedAt"`
}

type CustomerNoBillingID struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CustomerNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CustomerPortal struct {
	BillingInformation      CustomerPortalBillingInformation        `json:"billingInformation"`
	BillingPortalURL        *string                                 `json:"billingPortalUrl"`
	CanUpgradeSubscription  bool                                    `json:"canUpgradeSubscription"`
	Configuration           *CustomerPortalConfiguration            `json:"configuration"`
	Entitlements            []*Entitlement                          `json:"entitlements"`
	PromotionalEntitlements []*CustomerPortalPromotionalEntitlement `json:"promotionalEntitlements"`
	Resource                *CustomerResource                       `json:"resource"`
	ShowWatermark           bool                                    `json:"showWatermark"`
	Subscriptions           []*CustomerPortalSubscription           `json:"subscriptions"`
}

type CustomerPortalAddon struct {
	AddonID     string  `json:"addonId"`
	Description *string `json:"description"`
	DisplayName string  `json:"displayName"`
	Quantity    int64   `json:"quantity"`
}

type CustomerPortalBillingInformation struct {
	DefaultPaymentExpirationMonth   *int64             `json:"defaultPaymentExpirationMonth"`
	DefaultPaymentExpirationYear    *int64             `json:"defaultPaymentExpirationYear"`
	DefaultPaymentMethodID          *string            `json:"defaultPaymentMethodId"`
	DefaultPaymentMethodLast4Digits *string            `json:"defaultPaymentMethodLast4Digits"`
	DefaultPaymentMethodType        *PaymentMethodType `json:"defaultPaymentMethodType"`
	Email                           *string            `json:"email"`
	Name                            *string            `json:"name"`
}

type CustomerPortalColorsPalette struct {
	BackgroundColor        *string `json:"backgroundColor"`
	BorderColor            *string `json:"borderColor"`
	CurrentPlanBackground  *string `json:"currentPlanBackground"`
	IconsColor             *string `json:"iconsColor"`
	PaywallBackgroundColor *string `json:"paywallBackgroundColor"`
	Primary                *string `json:"primary"`
	TextColor              *string `json:"textColor"`
}

type CustomerPortalColorsPaletteInput struct {
	BackgroundColor        *string `json:"backgroundColor,omitempty"`
	BorderColor            *string `json:"borderColor,omitempty"`
	CurrentPlanBackground  *string `json:"currentPlanBackground,omitempty"`
	IconsColor             *string `json:"iconsColor,omitempty"`
	PaywallBackgroundColor *string `json:"paywallBackgroundColor,omitempty"`
	Primary                *string `json:"primary,omitempty"`
	TextColor              *string `json:"textColor,omitempty"`
}

type CustomerPortalConfiguration struct {
	CustomCSS  *string                      `json:"customCss"`
	Palette    *CustomerPortalColorsPalette `json:"palette"`
	Typography *TypographyConfiguration     `json:"typography"`
}

type CustomerPortalConfigurationInput struct {
	CustomCSS  *string                           `json:"customCss,omitempty"`
	Palette    *CustomerPortalColorsPaletteInput `json:"palette,omitempty"`
	Typography *TypographyConfigurationInput     `json:"typography,omitempty"`
}

type CustomerPortalInput struct {
	CustomerID string  `json:"customerId"`
	ProductID  *string `json:"productId,omitempty"`
	ResourceID *string `json:"resourceId,omitempty"`
}

type CustomerPortalPricingFeature struct {
	Description        *string     `json:"description"`
	DisplayName        string      `json:"displayName"`
	FeatureType        FeatureType `json:"featureType"`
	FeatureUnits       *string     `json:"featureUnits"`
	FeatureUnitsPlural *string     `json:"featureUnitsPlural"`
	ID                 string      `json:"id"`
	MeterType          *MeterType  `json:"meterType"`
	RefID              string      `json:"refId"`
}

type CustomerPortalPromotionalEntitlement struct {
	Description       *string                      `json:"description"`
	DisplayName       string                       `json:"displayName"`
	EndDate           *string                      `json:"endDate"`
	HasUnlimitedUsage *bool                        `json:"hasUnlimitedUsage"`
	Period            PromotionalEntitlementPeriod `json:"period"`
	StartDate         string                       `json:"startDate"`
	UsageLimit        *float64                     `json:"usageLimit"`
}

type CustomerPortalSubscription struct {
	Addons             []*CustomerPortalAddon             `json:"addons"`
	BillingPeriodRange *DateRange                         `json:"billingPeriodRange"`
	PlanName           string                             `json:"planName"`
	Prices             []*CustomerPortalSubscriptionPrice `json:"prices"`
	Pricing            CustomerPortalSubscriptionPricing  `json:"pricing"`
	PricingType        PricingType                        `json:"pricingType"`
	ScheduledUpdates   []*SubscriptionScheduledUpdate     `json:"scheduledUpdates"`
	Status             SubscriptionStatus                 `json:"status"`
	SubscriptionID     string                             `json:"subscriptionId"`
	TotalPrice         *CustomerSubscriptionTotalPrice    `json:"totalPrice"`
	TrialRemainingDays *int64                             `json:"trialRemainingDays"`
}

type CustomerPortalSubscriptionPrice struct {
	BillingModel  *BillingModel                 `json:"billingModel"`
	BillingPeriod *BillingPeriod                `json:"billingPeriod"`
	Feature       *CustomerPortalPricingFeature `json:"feature"`
	Price         *Money                        `json:"price"`
}

type CustomerPortalSubscriptionPricing struct {
	BillingCountryCode      *string                       `json:"billingCountryCode"`
	BillingModel            *BillingModel                 `json:"billingModel"`
	BillingPeriod           *BillingPeriod                `json:"billingPeriod"`
	Feature                 *CustomerPortalPricingFeature `json:"feature"`
	Price                   *Money                        `json:"price"`
	PricingType             PricingType                   `json:"pricingType"`
	UnitQuantity            *int64                        `json:"unitQuantity"`
	UsageBasedEstimatedBill *float64                      `json:"usageBasedEstimatedBill"`
}

type CustomerResource struct {
	CreatedAt     string                  `json:"createdAt"`
	Customer      Customer                `json:"customer"`
	EnvironmentID string                  `json:"environmentId"`
	ResourceID    string                  `json:"resourceId"`
	Subscriptions []*CustomerSubscription `json:"subscriptions"`
}

type CustomerResourceAggregateGroupBy struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ResourceID    *string `json:"resourceId"`
}

type CustomerResourceConnection struct {
	// Array of edges.
	Edges []*CustomerResourceEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerResourceCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ResourceID    *int64 `json:"resourceId"`
}

type CustomerResourceEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the CustomerResource
	Node CustomerResource `json:"node"`
}

type CustomerResourceFilter struct {
	And           []*CustomerResourceFilter                         `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                              `json:"createdAt,omitempty"`
	Customer      *CustomerResourceFilterCustomerFilter             `json:"customer,omitempty"`
	EnvironmentID *StringFieldComparison                            `json:"environmentId,omitempty"`
	Or            []*CustomerResourceFilter                         `json:"or,omitempty"`
	ResourceID    *StringFieldComparison                            `json:"resourceId,omitempty"`
	Subscriptions *CustomerResourceFilterCustomerSubscriptionFilter `json:"subscriptions,omitempty"`
}

type CustomerResourceFilterCustomerFilter struct {
	And                  []*CustomerResourceFilterCustomerFilter `json:"and,omitempty"`
	BillingID            *StringFieldComparison                  `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                    `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                  `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                  `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison                  `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison                  `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                    `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison                  `json:"email,omitempty"`
	EnvironmentID        *StringFieldComparison                  `json:"environmentId,omitempty"`
	ID                   *StringFieldComparison                  `json:"id,omitempty"`
	Name                 *StringFieldComparison                  `json:"name,omitempty"`
	Or                   []*CustomerResourceFilterCustomerFilter `json:"or,omitempty"`
	RefID                *StringFieldComparison                  `json:"refId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison    `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                    `json:"updatedAt,omitempty"`
}

type CustomerResourceFilterCustomerSubscriptionFilter struct {
	And                       []*CustomerResourceFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingID                 *StringFieldComparison                              `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison           `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                              `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                              `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                `json:"currentBillingPeriodStart,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                `json:"endDate,omitempty"`
	EnvironmentID             *StringFieldComparison                              `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison                              `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                              `json:"oldBillingId,omitempty"`
	Or                        []*CustomerResourceFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                  `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                        `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                              `json:"refId,omitempty"`
	ResourceID                *StringFieldComparison                              `json:"resourceId,omitempty"`
	StartDate                 *DateFieldComparison                                `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                 `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                              `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                `json:"trialEndDate,omitempty"`
}

type CustomerResourceMaxAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ResourceID    *string `json:"resourceId"`
}

type CustomerResourceMinAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ResourceID    *string `json:"resourceId"`
}

type CustomerResourceSort struct {
	Direction SortDirection              `json:"direction"`
	Field     CustomerResourceSortFields `json:"field"`
	Nulls     *SortNulls                 `json:"nulls,omitempty"`
}

type CustomerSearchQueryFilterComparison struct {
	ILike *string `json:"iLike,omitempty"`
}

type CustomerSort struct {
	Direction SortDirection      `json:"direction"`
	Field     CustomerSortFields `json:"field"`
	Nulls     *SortNulls         `json:"nulls,omitempty"`
}

type CustomerStatistics struct {
	ActiveSubscriptionsByPricingType []*SubscriptionPricingTypeStatistics `json:"activeSubscriptionsByPricingType"`
}

type CustomerSubscription struct {
	AdditionalMetaData        map[string]interface{}          `json:"additionalMetaData"`
	Addons                    []*SubscriptionAddon            `json:"addons"`
	BillingID                 *string                         `json:"billingId"`
	BillingLinkURL            *string                         `json:"billingLinkUrl"`
	BillingSyncError          *string                         `json:"billingSyncError"`
	CancelReason              *SubscriptionCancelReason       `json:"cancelReason"`
	CancellationDate          *string                         `json:"cancellationDate"`
	Coupon                    *SubscriptionCoupon             `json:"coupon"`
	CreatedAt                 *string                         `json:"createdAt"`
	CrmID                     *string                         `json:"crmId"`
	CrmLinkURL                *string                         `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                         `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                         `json:"currentBillingPeriodStart"`
	Customer                  Customer                        `json:"customer"`
	EffectiveEndDate          *string                         `json:"effectiveEndDate"`
	EndDate                   *string                         `json:"endDate"`
	Environment               Environment                     `json:"environment"`
	EnvironmentID             string                          `json:"environmentId"`
	Experiment                *Experiment                     `json:"experiment"`
	ExperimentInfo            *ExperimentInfo                 `json:"experimentInfo"`
	FutureUpdates             []*SubscriptionFutureUpdate     `json:"futureUpdates"`
	ID                        string                          `json:"id"`
	IsCustomPriceSubscription *bool                           `json:"isCustomPriceSubscription"`
	LatestInvoice             *SubscriptionInvoice            `json:"latestInvoice"`
	OldBillingID              *string                         `json:"oldBillingId"`
	OutdatedPricePackages     []string                        `json:"outdatedPricePackages"`
	PaymentCollection         PaymentCollection               `json:"paymentCollection"`
	Plan                      Plan                            `json:"plan"`
	Prices                    []*SubscriptionPrice            `json:"prices"`
	PricingType               PricingType                     `json:"pricingType"`
	RefID                     string                          `json:"refId"`
	Resource                  *CustomerResource               `json:"resource"`
	ResourceID                *string                         `json:"resourceId"`
	ScheduledUpdates          []*SubscriptionScheduledUpdate  `json:"scheduledUpdates"`
	StartDate                 string                          `json:"startDate"`
	Status                    SubscriptionStatus              `json:"status"`
	SubscriptionEntitlements  []*SubscriptionEntitlement      `json:"subscriptionEntitlements"`
	SubscriptionID            string                          `json:"subscriptionId"`
	SyncStates                []*SyncState                    `json:"syncStates"`
	TotalPrice                *CustomerSubscriptionTotalPrice `json:"totalPrice"`
	TrialEndDate              *string                         `json:"trialEndDate"`
	WasInTrial                *bool                           `json:"wasInTrial"`
}

type CustomerSubscriptionAggregateGroupBy struct {
	BillingID                 *string                   `json:"billingId"`
	CancelReason              *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate          *string                   `json:"cancellationDate"`
	CreatedAt                 *string                   `json:"createdAt"`
	CrmID                     *string                   `json:"crmId"`
	CrmLinkURL                *string                   `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                   `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                   `json:"currentBillingPeriodStart"`
	EffectiveEndDate          *string                   `json:"effectiveEndDate"`
	EndDate                   *string                   `json:"endDate"`
	EnvironmentID             *string                   `json:"environmentId"`
	ID                        *string                   `json:"id"`
	OldBillingID              *string                   `json:"oldBillingId"`
	PaymentCollection         *PaymentCollection        `json:"paymentCollection"`
	PricingType               *PricingType              `json:"pricingType"`
	RefID                     *string                   `json:"refId"`
	ResourceID                *string                   `json:"resourceId"`
	StartDate                 *string                   `json:"startDate"`
	Status                    *SubscriptionStatus       `json:"status"`
	SubscriptionID            *string                   `json:"subscriptionId"`
	TrialEndDate              *string                   `json:"trialEndDate"`
}

type CustomerSubscriptionConnection struct {
	// Array of edges.
	Edges []*CustomerSubscriptionEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerSubscriptionCountAggregate struct {
	BillingID                 *int64 `json:"billingId"`
	CancelReason              *int64 `json:"cancelReason"`
	CancellationDate          *int64 `json:"cancellationDate"`
	CreatedAt                 *int64 `json:"createdAt"`
	CrmID                     *int64 `json:"crmId"`
	CrmLinkURL                *int64 `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *int64 `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *int64 `json:"currentBillingPeriodStart"`
	EffectiveEndDate          *int64 `json:"effectiveEndDate"`
	EndDate                   *int64 `json:"endDate"`
	EnvironmentID             *int64 `json:"environmentId"`
	ID                        *int64 `json:"id"`
	OldBillingID              *int64 `json:"oldBillingId"`
	PaymentCollection         *int64 `json:"paymentCollection"`
	PricingType               *int64 `json:"pricingType"`
	RefID                     *int64 `json:"refId"`
	ResourceID                *int64 `json:"resourceId"`
	StartDate                 *int64 `json:"startDate"`
	Status                    *int64 `json:"status"`
	SubscriptionID            *int64 `json:"subscriptionId"`
	TrialEndDate              *int64 `json:"trialEndDate"`
}

type CustomerSubscriptionEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the CustomerSubscription
	Node CustomerSubscription `json:"node"`
}

type CustomerSubscriptionFilter struct {
	Addons                    *CustomerSubscriptionFilterSubscriptionAddonFilter       `json:"addons,omitempty"`
	And                       []*CustomerSubscriptionFilter                            `json:"and,omitempty"`
	BillingID                 *StringFieldComparison                                   `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison                `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                     `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                     `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                                   `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                                   `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                     `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                     `json:"currentBillingPeriodStart,omitempty"`
	Customer                  *CustomerSubscriptionFilterCustomerFilter                `json:"customer,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                     `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                     `json:"endDate,omitempty"`
	EnvironmentID             *StringFieldComparison                                   `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison                                   `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                                   `json:"oldBillingId,omitempty"`
	Or                        []*CustomerSubscriptionFilter                            `json:"or,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                       `json:"paymentCollection,omitempty"`
	Plan                      *CustomerSubscriptionFilterPlanFilter                    `json:"plan,omitempty"`
	Prices                    *CustomerSubscriptionFilterSubscriptionPriceFilter       `json:"prices,omitempty"`
	PricingType               *PricingTypeFilterComparison                             `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                                   `json:"refId,omitempty"`
	Resource                  *CustomerSubscriptionFilterCustomerResourceFilter        `json:"resource,omitempty"`
	ResourceID                *StringFieldComparison                                   `json:"resourceId,omitempty"`
	StartDate                 *DateFieldComparison                                     `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                      `json:"status,omitempty"`
	SubscriptionEntitlements  *CustomerSubscriptionFilterSubscriptionEntitlementFilter `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID            *StringFieldComparison                                   `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                     `json:"trialEndDate,omitempty"`
}

type CustomerSubscriptionFilterCustomerFilter struct {
	And                  []*CustomerSubscriptionFilterCustomerFilter `json:"and,omitempty"`
	BillingID            *StringFieldComparison                      `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                        `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                      `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                      `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison                      `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison                      `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                        `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison                      `json:"email,omitempty"`
	EnvironmentID        *StringFieldComparison                      `json:"environmentId,omitempty"`
	ID                   *StringFieldComparison                      `json:"id,omitempty"`
	Name                 *StringFieldComparison                      `json:"name,omitempty"`
	Or                   []*CustomerSubscriptionFilterCustomerFilter `json:"or,omitempty"`
	RefID                *StringFieldComparison                      `json:"refId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison        `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                        `json:"updatedAt,omitempty"`
}

type CustomerSubscriptionFilterCustomerResourceFilter struct {
	And           []*CustomerSubscriptionFilterCustomerResourceFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                                `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison                              `json:"environmentId,omitempty"`
	Or            []*CustomerSubscriptionFilterCustomerResourceFilter `json:"or,omitempty"`
	ResourceID    *StringFieldComparison                              `json:"resourceId,omitempty"`
}

type CustomerSubscriptionFilterPlanFilter struct {
	And           []*CustomerSubscriptionFilterPlanFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison                  `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison                    `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                  `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                  `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison                  `json:"environmentId,omitempty"`
	ID            *StringFieldComparison                  `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison                 `json:"isLatest,omitempty"`
	Or            []*CustomerSubscriptionFilterPlanFilter `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison            `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison                  `json:"productId,omitempty"`
	RefID         *StringFieldComparison                  `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison          `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                    `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison                     `json:"versionNumber,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionAddonFilter struct {
	And       []*CustomerSubscriptionFilterSubscriptionAddonFilter `json:"and,omitempty"`
	CreatedAt *DateFieldComparison                                 `json:"createdAt,omitempty"`
	ID        *StringFieldComparison                               `json:"id,omitempty"`
	Or        []*CustomerSubscriptionFilterSubscriptionAddonFilter `json:"or,omitempty"`
	Quantity  *NumberFieldComparison                               `json:"quantity,omitempty"`
	UpdatedAt *DateFieldComparison                                 `json:"updatedAt,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionEntitlementFilter struct {
	And            []*CustomerSubscriptionFilterSubscriptionEntitlementFilter `json:"and,omitempty"`
	CreatedAt      *DateFieldComparison                                       `json:"createdAt,omitempty"`
	EnvironmentID  *StringFieldComparison                                     `json:"environmentId,omitempty"`
	ID             *StringFieldComparison                                     `json:"id,omitempty"`
	Or             []*CustomerSubscriptionFilterSubscriptionEntitlementFilter `json:"or,omitempty"`
	SubscriptionID *StringFieldComparison                                     `json:"subscriptionId,omitempty"`
	UpdatedAt      *DateFieldComparison                                       `json:"updatedAt,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionPriceFilter struct {
	And          []*CustomerSubscriptionFilterSubscriptionPriceFilter `json:"and,omitempty"`
	BillingModel *BillingModelFilterComparison                        `json:"billingModel,omitempty"`
	CreatedAt    *DateFieldComparison                                 `json:"createdAt,omitempty"`
	FeatureID    *StringFieldComparison                               `json:"featureId,omitempty"`
	ID           *StringFieldComparison                               `json:"id,omitempty"`
	Or           []*CustomerSubscriptionFilterSubscriptionPriceFilter `json:"or,omitempty"`
	UpdatedAt    *DateFieldComparison                                 `json:"updatedAt,omitempty"`
	UsageLimit   *NumberFieldComparison                               `json:"usageLimit,omitempty"`
}

type CustomerSubscriptionMaxAggregate struct {
	BillingID                 *string                   `json:"billingId"`
	CancelReason              *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate          *string                   `json:"cancellationDate"`
	CreatedAt                 *string                   `json:"createdAt"`
	CrmID                     *string                   `json:"crmId"`
	CrmLinkURL                *string                   `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                   `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                   `json:"currentBillingPeriodStart"`
	EffectiveEndDate          *string                   `json:"effectiveEndDate"`
	EndDate                   *string                   `json:"endDate"`
	EnvironmentID             *string                   `json:"environmentId"`
	ID                        *string                   `json:"id"`
	OldBillingID              *string                   `json:"oldBillingId"`
	PaymentCollection         *PaymentCollection        `json:"paymentCollection"`
	PricingType               *PricingType              `json:"pricingType"`
	RefID                     *string                   `json:"refId"`
	ResourceID                *string                   `json:"resourceId"`
	StartDate                 *string                   `json:"startDate"`
	Status                    *SubscriptionStatus       `json:"status"`
	SubscriptionID            *string                   `json:"subscriptionId"`
	TrialEndDate              *string                   `json:"trialEndDate"`
}

type CustomerSubscriptionMinAggregate struct {
	BillingID                 *string                   `json:"billingId"`
	CancelReason              *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate          *string                   `json:"cancellationDate"`
	CreatedAt                 *string                   `json:"createdAt"`
	CrmID                     *string                   `json:"crmId"`
	CrmLinkURL                *string                   `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                   `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                   `json:"currentBillingPeriodStart"`
	EffectiveEndDate          *string                   `json:"effectiveEndDate"`
	EndDate                   *string                   `json:"endDate"`
	EnvironmentID             *string                   `json:"environmentId"`
	ID                        *string                   `json:"id"`
	OldBillingID              *string                   `json:"oldBillingId"`
	PaymentCollection         *PaymentCollection        `json:"paymentCollection"`
	PricingType               *PricingType              `json:"pricingType"`
	RefID                     *string                   `json:"refId"`
	ResourceID                *string                   `json:"resourceId"`
	StartDate                 *string                   `json:"startDate"`
	Status                    *SubscriptionStatus       `json:"status"`
	SubscriptionID            *string                   `json:"subscriptionId"`
	TrialEndDate              *string                   `json:"trialEndDate"`
}

type CustomerSubscriptionSort struct {
	Direction SortDirection                  `json:"direction"`
	Field     CustomerSubscriptionSortFields `json:"field"`
	Nulls     *SortNulls                     `json:"nulls,omitempty"`
}

type CustomerSubscriptionTotalPrice struct {
	AddonsTotal Money `json:"addonsTotal"`
	SubTotal    Money `json:"subTotal"`
	Total       Money `json:"total"`
}

type DateFieldComparison struct {
	Between    *DateFieldComparisonBetween `json:"between,omitempty"`
	Eq         *string                     `json:"eq,omitempty"`
	Gt         *string                     `json:"gt,omitempty"`
	Gte        *string                     `json:"gte,omitempty"`
	In         []string                    `json:"in,omitempty"`
	Is         *bool                       `json:"is,omitempty"`
	IsNot      *bool                       `json:"isNot,omitempty"`
	Lt         *string                     `json:"lt,omitempty"`
	Lte        *string                     `json:"lte,omitempty"`
	Neq        *string                     `json:"neq,omitempty"`
	NotBetween *DateFieldComparisonBetween `json:"notBetween,omitempty"`
	NotIn      []string                    `json:"notIn,omitempty"`
}

type DateFieldComparisonBetween struct {
	Lower string `json:"lower"`
	Upper string `json:"upper"`
}

type DateRange struct {
	End   *string `json:"end"`
	Start *string `json:"start"`
}

type DefaultTrialConfig struct {
	Duration float64          `json:"duration"`
	Units    TrialPeriodUnits `json:"units"`
}

type DefaultTrialConfigChange struct {
	After      *DefaultTrialConfig `json:"after"`
	Before     *DefaultTrialConfig `json:"before"`
	ChangeType *ChangeType         `json:"changeType"`
}

type DefaultTrialConfigInputDto struct {
	Duration *float64          `json:"duration,omitempty"`
	Units    *TrialPeriodUnits `json:"units,omitempty"`
}

type DeleteFeatureInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	ID            string  `json:"id"`
}

type DeleteOneAddonInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneHookInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneIntegrationInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePackageEntitlementInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePriceInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneProductInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePromotionalEntitlementInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DetachCustomerPaymentMethodInput struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type DimensionsMappingInput struct {
	Key       string `json:"key"`
	PlanName  string `json:"planName"`
	PlanRefID string `json:"planRefId"`
}

type DiscardPackageDraftInput struct {
	EnvironmentID string `json:"environmentId"`
	RefID         string `json:"refId"`
}

type DoesFeatureExist struct {
	EnvironmentID string `json:"environmentId"`
	RefID         string `json:"refId"`
}

type DowngradeChangeVariables struct {
	AddonRefIds        *string            `json:"addonRefIds"`
	BillableFeatures   []*BillableFeature `json:"billableFeatures"`
	BillingPeriod      *BillingPeriod     `json:"billingPeriod"`
	DowngradePlanRefID string             `json:"downgradePlanRefId"`
}

func (DowngradeChangeVariables) IsScheduleVariables() {}

// Input type for dumpEnvironmentForMergeComparison query.
type DumpEnvironmentForForMergeComparisonInput struct {
	// The slug of the environment to copy to.
	DestinationEnvironmentSlug string `json:"destinationEnvironmentSlug"`
	// The slug of the environment to copy from.
	SourceEnvironmentSlug string `json:"sourceEnvironmentSlug"`
}

type DumpEnvironmentForMergeComparison struct {
	PostMergeDump map[string]interface{} `json:"postMergeDump"`
	PreMergeDump  map[string]interface{} `json:"preMergeDump"`
}

// Input type for dumpEnvironmentProductCatalog mutation.
type DumpEnvironmentProductCatalogInput struct {
	// The slug of the environment to dump.
	EnvironmentSlug string `json:"environmentSlug"`
}

type DuplicateProductInput struct {
	Description     *string `json:"description,omitempty"`
	DisplayName     *string `json:"displayName,omitempty"`
	EnvironmentID   string  `json:"environmentId"`
	RefID           string  `json:"refId"`
	SourceProductID string  `json:"sourceProductId"`
}

type DuplicatedEntityNotAllowedError struct {
	Code              string `json:"code"`
	EntityName        string `json:"entityName"`
	Identifier        string `json:"identifier"`
	IsValidationError bool   `json:"isValidationError"`
}

type EditAllowedOnDraftPackageOnlyError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type EligibleForTrial struct {
	Eligible     bool    `json:"eligible"`
	ProductID    *string `json:"productId"`
	ProductRefID *string `json:"productRefId"`
}

type Entitlement struct {
	AccessDeniedReason       *AccessDeniedReason      `json:"accessDeniedReason"`
	CurrentUsage             *float64                 `json:"currentUsage"`
	CustomerID               *string                  `json:"customerId"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
	EntitlementUpdatedAt     *string                  `json:"entitlementUpdatedAt"`
	Feature                  *EntitlementFeature      `json:"feature"`
	HasSoftLimit             bool                     `json:"hasSoftLimit"`
	HasUnlimitedUsage        bool                     `json:"hasUnlimitedUsage"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	IsGranted                bool                     `json:"isGranted"`
	MeterID                  *string                  `json:"meterId"`
	NextResetDate            *string                  `json:"nextResetDate"`
	RequestedUsage           *float64                 `json:"requestedUsage"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	ResourceID               *string                  `json:"resourceId"`
	UsageLimit               *float64                 `json:"usageLimit"`
	UsageUpdatedAt           *string                  `json:"usageUpdatedAt"`
}

type EntitlementCheckRequested struct {
	CustomerID             string                 `json:"customerId"`
	EntitlementCheckResult EntitlementCheckResult `json:"entitlementCheckResult"`
	EnvironmentID          *string                `json:"environmentId,omitempty"`
	FeatureID              string                 `json:"featureId"`
	RequestedUsage         *float64               `json:"requestedUsage,omitempty"`
	ResourceID             *string                `json:"resourceId,omitempty"`
}

type EntitlementCheckResult struct {
	AccessDeniedReason              *AccessDeniedReason            `json:"accessDeniedReason,omitempty"`
	CurrentUsage                    *float64                       `json:"currentUsage,omitempty"`
	HasAccess                       bool                           `json:"hasAccess"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	NextResetDate                   *string                        `json:"nextResetDate,omitempty"`
	RequestedUsage                  *float64                       `json:"requestedUsage,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type EntitlementFeature struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	Description        *string                `json:"description"`
	DisplayName        string                 `json:"displayName"`
	FeatureStatus      FeatureStatus          `json:"featureStatus"`
	FeatureType        FeatureType            `json:"featureType"`
	FeatureUnits       *string                `json:"featureUnits"`
	FeatureUnitsPlural *string                `json:"featureUnitsPlural"`
	ID                 string                 `json:"id"`
	MeterType          *MeterType             `json:"meterType"`
	RefID              string                 `json:"refId"`
}

type EntitlementLimitExceededError struct {
	Code              string `json:"code"`
	Feature           string `json:"feature"`
	IsValidationError bool   `json:"isValidationError"`
}

type EntitlementOptions struct {
	RequestedUsage *float64 `json:"requestedUsage,omitempty"`
	ShouldTrack    *bool    `json:"shouldTrack,omitempty"`
}

type EntitlementSummary struct {
	AddonQuantity                 *float64                `json:"addonQuantity"`
	FeaturePackageEntitlement     *PackageEntitlement     `json:"featurePackageEntitlement"`
	FeaturePromotionalEntitlement *PromotionalEntitlement `json:"featurePromotionalEntitlement"`
	IsEffectiveEntitlement        bool                    `json:"isEffectiveEntitlement"`
	Plan                          *Plan                   `json:"plan"`
	PriceEntitlement              *PriceEntitlement       `json:"priceEntitlement"`
	Subscription                  *CustomerSubscription   `json:"subscription"`
}

type EntitlementWithSummary struct {
	AccessDeniedReason       *AccessDeniedReason      `json:"accessDeniedReason"`
	CurrentUsage             *float64                 `json:"currentUsage"`
	CustomerID               *string                  `json:"customerId"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
	EntitlementUpdatedAt     *string                  `json:"entitlementUpdatedAt"`
	Feature                  *EntitlementFeature      `json:"feature"`
	HasSoftLimit             bool                     `json:"hasSoftLimit"`
	HasUnlimitedUsage        bool                     `json:"hasUnlimitedUsage"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	IsGranted                bool                     `json:"isGranted"`
	MeterID                  *string                  `json:"meterId"`
	NextResetDate            *string                  `json:"nextResetDate"`
	RequestedUsage           *float64                 `json:"requestedUsage"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	ResourceID               *string                  `json:"resourceId"`
	Summaries                []*EntitlementSummary    `json:"summaries"`
	UsageLimit               *float64                 `json:"usageLimit"`
	UsageUpdatedAt           *string                  `json:"usageUpdatedAt"`
}

type EntitlementsUpdated struct {
	AccountID     string         `json:"accountId"`
	CustomerID    string         `json:"customerId"`
	Entitlements  []*Entitlement `json:"entitlements"`
	EnvironmentID string         `json:"environmentId"`
	ResourceID    *string        `json:"resourceId"`
}

type Environment struct {
	Account                   *Account                    `json:"account"`
	APIKeys                   []*APIKey                   `json:"apiKeys"`
	Color                     *string                     `json:"color"`
	CreatedAt                 *string                     `json:"createdAt"`
	Description               *string                     `json:"description"`
	DisplayName               string                      `json:"displayName"`
	HardenClientAccessEnabled bool                        `json:"hardenClientAccessEnabled"`
	ID                        string                      `json:"id"`
	IsSandbox                 bool                        `json:"isSandbox"`
	PermanentDeletionDate     *string                     `json:"permanentDeletionDate"`
	ProvisionStatus           *EnvironmentProvisionStatus `json:"provisionStatus"`
	SigningToken              string                      `json:"signingToken"`
	Slug                      string                      `json:"slug"`
	Type                      EnvironmentType             `json:"type"`
}

type EnvironmentAggregateGroupBy struct {
	CreatedAt             *string `json:"createdAt"`
	DisplayName           *string `json:"displayName"`
	ID                    *string `json:"id"`
	PermanentDeletionDate *string `json:"permanentDeletionDate"`
	Slug                  *string `json:"slug"`
}

type EnvironmentConnection struct {
	// Array of edges.
	Edges []*EnvironmentEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type EnvironmentCountAggregate struct {
	CreatedAt             *int64 `json:"createdAt"`
	DisplayName           *int64 `json:"displayName"`
	ID                    *int64 `json:"id"`
	PermanentDeletionDate *int64 `json:"permanentDeletionDate"`
	Slug                  *int64 `json:"slug"`
}

type EnvironmentEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Environment
	Node Environment `json:"node"`
}

type EnvironmentFilter struct {
	And                   []*EnvironmentFilter   `json:"and,omitempty"`
	CreatedAt             *DateFieldComparison   `json:"createdAt,omitempty"`
	DisplayName           *StringFieldComparison `json:"displayName,omitempty"`
	ID                    *StringFieldComparison `json:"id,omitempty"`
	Or                    []*EnvironmentFilter   `json:"or,omitempty"`
	PermanentDeletionDate *DateFieldComparison   `json:"permanentDeletionDate,omitempty"`
	Slug                  *StringFieldComparison `json:"slug,omitempty"`
}

type EnvironmentInput struct {
	Color                     *string                     `json:"color,omitempty"`
	Description               *string                     `json:"description,omitempty"`
	DisplayName               *string                     `json:"displayName,omitempty"`
	HardenClientAccessEnabled *bool                       `json:"hardenClientAccessEnabled,omitempty"`
	ProvisionStatus           *EnvironmentProvisionStatus `json:"provisionStatus,omitempty"`
}

type EnvironmentMaxAggregate struct {
	CreatedAt             *string `json:"createdAt"`
	DisplayName           *string `json:"displayName"`
	ID                    *string `json:"id"`
	PermanentDeletionDate *string `json:"permanentDeletionDate"`
	Slug                  *string `json:"slug"`
}

type EnvironmentMinAggregate struct {
	CreatedAt             *string `json:"createdAt"`
	DisplayName           *string `json:"displayName"`
	ID                    *string `json:"id"`
	PermanentDeletionDate *string `json:"permanentDeletionDate"`
	Slug                  *string `json:"slug"`
}

type EnvironmentMissingError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type EnvironmentSort struct {
	Direction SortDirection         `json:"direction"`
	Field     EnvironmentSortFields `json:"field"`
	Nulls     *SortNulls            `json:"nulls,omitempty"`
}

type EstimateSubscriptionInput struct {
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	BillableFeatures   []*BillableFeatureInput   `json:"billableFeatures,omitempty"`
	BillingCountryCode *string                   `json:"billingCountryCode,omitempty"`
	BillingInformation *SubscriptionBillingInfo  `json:"billingInformation,omitempty"`
	BillingPeriod      *BillingPeriod            `json:"billingPeriod,omitempty"`
	CustomerID         string                    `json:"customerId"`
	EnvironmentID      *string                   `json:"environmentId,omitempty"`
	PlanID             string                    `json:"planId"`
	PriceUnitAmount    *float64                  `json:"priceUnitAmount,omitempty"`
	PromotionCode      *string                   `json:"promotionCode,omitempty"`
	ResourceID         *string                   `json:"resourceId,omitempty"`
	SkipTrial          *bool                     `json:"skipTrial,omitempty"`
	StartDate          *string                   `json:"startDate,omitempty"`
	UnitQuantity       *float64                  `json:"unitQuantity,omitempty"`
}

type EstimateSubscriptionUpdateInput struct {
	Addons           []*SubscriptionAddonInput `json:"addons,omitempty"`
	BillableFeatures []*BillableFeatureInput   `json:"billableFeatures,omitempty"`
	EnvironmentID    *string                   `json:"environmentId,omitempty"`
	PromotionCode    *string                   `json:"promotionCode,omitempty"`
	SubscriptionID   string                    `json:"subscriptionId"`
	UnitQuantity     *float64                  `json:"unitQuantity,omitempty"`
}

type EventLog struct {
	Description      *string      `json:"description"`
	Environment      *Environment `json:"environment"`
	EnvironmentID    string       `json:"environmentId"`
	EventLogType     EventLogType `json:"eventLogType"`
	ID               string       `json:"id"`
	WebhookEndpoints []string     `json:"webhookEndpoints"`
}

type EventLogAggregateGroupBy struct {
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type EventLogCountAggregate struct {
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
}

type EventLogEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the EventLog
	Node EventLog `json:"node"`
}

type EventLogMaxAggregate struct {
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type EventLogMinAggregate struct {
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type EventsFields struct {
	Fields map[string]interface{} `json:"fields"`
}

type EventsFieldsInput struct {
	EnvironmentID string                        `json:"environmentId"`
	Filters       []*MeterFilterDefinitionInput `json:"filters,omitempty"`
}

type Experiment struct {
	ControlGroupName       string           `json:"controlGroupName"`
	CreatedAt              string           `json:"createdAt"`
	Customers              *Customer        `json:"customers"`
	Description            *string          `json:"description"`
	Environment            *Environment     `json:"environment"`
	EnvironmentID          string           `json:"environmentId"`
	ID                     string           `json:"id"`
	InitialProductSettings *ProductSettings `json:"initialProductSettings"`
	Name                   string           `json:"name"`
	Product                *Product         `json:"product"`
	ProductID              string           `json:"productId"`
	ProductSettings        ProductSettings  `json:"productSettings"`
	RefID                  string           `json:"refId"`
	StartedAt              *string          `json:"startedAt"`
	Status                 ExperimentStatus `json:"status"`
	StoppedAt              *string          `json:"stoppedAt"`
	UpdatedAt              string           `json:"updatedAt"`
	VariantGroupName       string           `json:"variantGroupName"`
	VariantPercentage      float64          `json:"variantPercentage"`
}

type ExperimentAggregateGroupBy struct {
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	ProductID     *string           `json:"productId"`
	RefID         *string           `json:"refId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentAvgAggregate struct {
	ID *float64 `json:"id"`
}

type ExperimentConnection struct {
	// Array of edges.
	Edges []*ExperimentEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type ExperimentCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Name          *int64 `json:"name"`
	ProductID     *int64 `json:"productId"`
	RefID         *int64 `json:"refId"`
	Status        *int64 `json:"status"`
}

type ExperimentEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Experiment
	Node Experiment `json:"node"`
}

type ExperimentFilter struct {
	And           []*ExperimentFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison              `json:"createdAt,omitempty"`
	Customers     *ExperimentFilterCustomerFilter   `json:"customers,omitempty"`
	EnvironmentID *StringFieldComparison            `json:"environmentId,omitempty"`
	ID            *StringFieldComparison            `json:"id,omitempty"`
	Name          *StringFieldComparison            `json:"name,omitempty"`
	Or            []*ExperimentFilter               `json:"or,omitempty"`
	ProductID     *StringFieldComparison            `json:"productId,omitempty"`
	RefID         *StringFieldComparison            `json:"refId,omitempty"`
	Status        *ExperimentStatusFilterComparison `json:"status,omitempty"`
}

type ExperimentFilterCustomerFilter struct {
	And                  []*ExperimentFilterCustomerFilter    `json:"and,omitempty"`
	BillingID            *StringFieldComparison               `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                 `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison               `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison               `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison               `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison               `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                 `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison               `json:"email,omitempty"`
	EnvironmentID        *StringFieldComparison               `json:"environmentId,omitempty"`
	ID                   *StringFieldComparison               `json:"id,omitempty"`
	Name                 *StringFieldComparison               `json:"name,omitempty"`
	Or                   []*ExperimentFilterCustomerFilter    `json:"or,omitempty"`
	RefID                *StringFieldComparison               `json:"refId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                 `json:"updatedAt,omitempty"`
}

type ExperimentMaxAggregate struct {
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	ProductID     *string           `json:"productId"`
	RefID         *string           `json:"refId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentMinAggregate struct {
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	ProductID     *string           `json:"productId"`
	RefID         *string           `json:"refId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentSort struct {
	Direction SortDirection        `json:"direction"`
	Field     ExperimentSortFields `json:"field"`
	Nulls     *SortNulls           `json:"nulls,omitempty"`
}

type ExperimentStats struct {
	ControlPaidSubscriptions float64 `json:"controlPaidSubscriptions"`
	ControlSubscriptions     float64 `json:"controlSubscriptions"`
	VariantPaidSubscriptions float64 `json:"variantPaidSubscriptions"`
	VariantSubscriptions     float64 `json:"variantSubscriptions"`
}

type ExperimentStatsQuery struct {
	EnvironmentID   *string `json:"environmentId,omitempty"`
	ExperimentRefID string  `json:"experimentRefId"`
}

type ExperimentStatusFilterComparison struct {
	Eq       *ExperimentStatus  `json:"eq,omitempty"`
	Gt       *ExperimentStatus  `json:"gt,omitempty"`
	Gte      *ExperimentStatus  `json:"gte,omitempty"`
	ILike    *ExperimentStatus  `json:"iLike,omitempty"`
	In       []ExperimentStatus `json:"in,omitempty"`
	Is       *bool              `json:"is,omitempty"`
	IsNot    *bool              `json:"isNot,omitempty"`
	Like     *ExperimentStatus  `json:"like,omitempty"`
	Lt       *ExperimentStatus  `json:"lt,omitempty"`
	Lte      *ExperimentStatus  `json:"lte,omitempty"`
	Neq      *ExperimentStatus  `json:"neq,omitempty"`
	NotILike *ExperimentStatus  `json:"notILike,omitempty"`
	NotIn    []ExperimentStatus `json:"notIn,omitempty"`
	NotLike  *ExperimentStatus  `json:"notLike,omitempty"`
}

type ExperimentSumAggregate struct {
	ID *float64 `json:"id"`
}

type FailedToImportCustomerError struct {
	BillingID         string `json:"billingId"`
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type Feature struct {
	Account            *Account               `json:"account"`
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	CreatedAt          *string                `json:"createdAt"`
	Description        *string                `json:"description"`
	DisplayName        string                 `json:"displayName"`
	Environment        *Environment           `json:"environment"`
	EnvironmentID      string                 `json:"environmentId"`
	FeatureStatus      FeatureStatus          `json:"featureStatus"`
	FeatureType        FeatureType            `json:"featureType"`
	FeatureUnits       *string                `json:"featureUnits"`
	FeatureUnitsPlural *string                `json:"featureUnitsPlural"`
	HasEntitlements    *bool                  `json:"hasEntitlements"`
	HasMeter           *bool                  `json:"hasMeter"`
	ID                 string                 `json:"id"`
	Meter              *Meter                 `json:"meter"`
	MeterType          *MeterType             `json:"meterType"`
	RefID              string                 `json:"refId"`
	UpdatedAt          string                 `json:"updatedAt"`
}

type FeatureAggregateGroupBy struct {
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	FeatureType   *FeatureType   `json:"featureType"`
	ID            *string        `json:"id"`
	MeterType     *MeterType     `json:"meterType"`
	RefID         *string        `json:"refId"`
	UpdatedAt     *string        `json:"updatedAt"`
}

type FeatureAssociatedLatestPackages struct {
	EnvironmentID string `json:"environmentId"`
	FeatureID     string `json:"featureId"`
}

type FeatureConnection struct {
	// Array of edges.
	Edges []*FeatureEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type FeatureCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	DisplayName   *int64 `json:"displayName"`
	EnvironmentID *int64 `json:"environmentId"`
	FeatureStatus *int64 `json:"featureStatus"`
	FeatureType   *int64 `json:"featureType"`
	ID            *int64 `json:"id"`
	MeterType     *int64 `json:"meterType"`
	RefID         *int64 `json:"refId"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type FeatureEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Feature
	Node Feature `json:"node"`
}

type FeatureFilter struct {
	And           []*FeatureFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison   `json:"featureType,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison     `json:"meterType,omitempty"`
	Or            []*FeatureFilter               `json:"or,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
}

type FeatureInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	Description        *string                `json:"description,omitempty"`
	DisplayName        string                 `json:"displayName"`
	EnvironmentID      string                 `json:"environmentId"`
	FeatureStatus      *FeatureStatus         `json:"featureStatus,omitempty"`
	FeatureType        FeatureType            `json:"featureType"`
	FeatureUnits       *string                `json:"featureUnits,omitempty"`
	FeatureUnitsPlural *string                `json:"featureUnitsPlural,omitempty"`
	Meter              *CreateMeter           `json:"meter,omitempty"`
	MeterType          *MeterType             `json:"meterType,omitempty"`
	RefID              string                 `json:"refId"`
}

type FeatureMaxAggregate struct {
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	FeatureType   *FeatureType   `json:"featureType"`
	ID            *string        `json:"id"`
	MeterType     *MeterType     `json:"meterType"`
	RefID         *string        `json:"refId"`
	UpdatedAt     *string        `json:"updatedAt"`
}

type FeatureMinAggregate struct {
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	FeatureType   *FeatureType   `json:"featureType"`
	ID            *string        `json:"id"`
	MeterType     *MeterType     `json:"meterType"`
	RefID         *string        `json:"refId"`
	UpdatedAt     *string        `json:"updatedAt"`
}

type FeatureNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type FeatureSort struct {
	Direction SortDirection     `json:"direction"`
	Field     FeatureSortFields `json:"field"`
	Nulls     *SortNulls        `json:"nulls,omitempty"`
}

type FeatureStatusFilterComparison struct {
	Eq       *FeatureStatus  `json:"eq,omitempty"`
	Gt       *FeatureStatus  `json:"gt,omitempty"`
	Gte      *FeatureStatus  `json:"gte,omitempty"`
	ILike    *FeatureStatus  `json:"iLike,omitempty"`
	In       []FeatureStatus `json:"in,omitempty"`
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Like     *FeatureStatus  `json:"like,omitempty"`
	Lt       *FeatureStatus  `json:"lt,omitempty"`
	Lte      *FeatureStatus  `json:"lte,omitempty"`
	Neq      *FeatureStatus  `json:"neq,omitempty"`
	NotILike *FeatureStatus  `json:"notILike,omitempty"`
	NotIn    []FeatureStatus `json:"notIn,omitempty"`
	NotLike  *FeatureStatus  `json:"notLike,omitempty"`
}

type FeatureTypeFilterComparison struct {
	Eq       *FeatureType  `json:"eq,omitempty"`
	Gt       *FeatureType  `json:"gt,omitempty"`
	Gte      *FeatureType  `json:"gte,omitempty"`
	ILike    *FeatureType  `json:"iLike,omitempty"`
	In       []FeatureType `json:"in,omitempty"`
	Is       *bool         `json:"is,omitempty"`
	IsNot    *bool         `json:"isNot,omitempty"`
	Like     *FeatureType  `json:"like,omitempty"`
	Lt       *FeatureType  `json:"lt,omitempty"`
	Lte      *FeatureType  `json:"lte,omitempty"`
	Neq      *FeatureType  `json:"neq,omitempty"`
	NotILike *FeatureType  `json:"notILike,omitempty"`
	NotIn    []FeatureType `json:"notIn,omitempty"`
	NotLike  *FeatureType  `json:"notLike,omitempty"`
}

type FetchEntitlementQuery struct {
	CustomerID    string              `json:"customerId"`
	EnvironmentID *string             `json:"environmentId,omitempty"`
	FeatureID     string              `json:"featureId"`
	Options       *EntitlementOptions `json:"options,omitempty"`
	ResourceID    *string             `json:"resourceId,omitempty"`
}

type FetchEntitlementsQuery struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
	ResourceID    *string `json:"resourceId,omitempty"`
}

type FontVariant struct {
	FontSize   *float64    `json:"fontSize"`
	FontWeight *FontWeight `json:"fontWeight"`
}

type FontVariantInput struct {
	FontSize   *float64    `json:"fontSize,omitempty"`
	FontWeight *FontWeight `json:"fontWeight,omitempty"`
}

type GetActiveSubscriptionsInput struct {
	CustomerID    string   `json:"customerId"`
	EnvironmentID *string  `json:"environmentId,omitempty"`
	ResourceID    *string  `json:"resourceId,omitempty"`
	ResourceIds   []string `json:"resourceIds,omitempty"`
}

type GetAwsExternalIDResult struct {
	ExternalID string `json:"externalId"`
}

type GetCustomerByRefIDInput struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type GetPackageByRefIDInput struct {
	EnvironmentID string   `json:"environmentId"`
	RefID         string   `json:"refId"`
	VersionNumber *float64 `json:"versionNumber,omitempty"`
}

type GetPaywallInput struct {
	BillingCountryCode      *string     `json:"billingCountryCode,omitempty"`
	Context                 *WidgetType `json:"context,omitempty"`
	CustomerID              *string     `json:"customerId,omitempty"`
	EnvironmentID           *string     `json:"environmentId,omitempty"`
	FetchAllCountriesPrices *bool       `json:"fetchAllCountriesPrices,omitempty"`
	IncludeHiddenPlans      *bool       `json:"includeHiddenPlans,omitempty"`
	ProductID               *string     `json:"productId,omitempty"`
	ResourceID              *string     `json:"resourceId,omitempty"`
}

type GetWidgetConfigurationInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type GrantPromotionalEntitlementInput struct {
	CustomEndDate                   *string                        `json:"customEndDate,omitempty"`
	FeatureID                       string                         `json:"featureId"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	IsVisible                       *bool                          `json:"isVisible,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	Period                          PromotionalEntitlementPeriod   `json:"period"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type GrantPromotionalEntitlementsInput struct {
	CustomerID              string                              `json:"customerId"`
	EnvironmentID           *string                             `json:"environmentId,omitempty"`
	PromotionalEntitlements []*GrantPromotionalEntitlementInput `json:"promotionalEntitlements"`
}

type HiddenFromWidgetsChange struct {
	After      []WidgetType `json:"after"`
	Before     []WidgetType `json:"before"`
	ChangeType *ChangeType  `json:"changeType"`
}

type Hook struct {
	Account       *Account       `json:"account"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	Endpoint      string         `json:"endpoint"`
	Environment   *Environment   `json:"environment"`
	EnvironmentID string         `json:"environmentId"`
	EventLogTypes []EventLogType `json:"eventLogTypes"`
	ID            string         `json:"id"`
	SecretKey     *string        `json:"secretKey"`
	Status        HookStatus     `json:"status"`
}

type HookAggregateGroupBy struct {
	CreatedAt     *string     `json:"createdAt"`
	Endpoint      *string     `json:"endpoint"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *HookStatus `json:"status"`
}

type HookConnection struct {
	// Array of edges.
	Edges []*HookEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type HookCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	Endpoint      *int64 `json:"endpoint"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
}

type HookDeleteResponse struct {
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	Endpoint      *string        `json:"endpoint"`
	EnvironmentID *string        `json:"environmentId"`
	EventLogTypes []EventLogType `json:"eventLogTypes"`
	ID            *string        `json:"id"`
	SecretKey     *string        `json:"secretKey"`
	Status        *HookStatus    `json:"status"`
}

type HookEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Hook
	Node Hook `json:"node"`
}

type HookFilter struct {
	And           []*HookFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison        `json:"createdAt,omitempty"`
	Endpoint      *StringFieldComparison      `json:"endpoint,omitempty"`
	EnvironmentID *StringFieldComparison      `json:"environmentId,omitempty"`
	ID            *StringFieldComparison      `json:"id,omitempty"`
	Or            []*HookFilter               `json:"or,omitempty"`
	Status        *HookStatusFilterComparison `json:"status,omitempty"`
}

type HookMaxAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	Endpoint      *string     `json:"endpoint"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *HookStatus `json:"status"`
}

type HookMinAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	Endpoint      *string     `json:"endpoint"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *HookStatus `json:"status"`
}

type HookSort struct {
	Direction SortDirection  `json:"direction"`
	Field     HookSortFields `json:"field"`
	Nulls     *SortNulls     `json:"nulls,omitempty"`
}

type HookStatusFilterComparison struct {
	Eq       *HookStatus  `json:"eq,omitempty"`
	Gt       *HookStatus  `json:"gt,omitempty"`
	Gte      *HookStatus  `json:"gte,omitempty"`
	ILike    *HookStatus  `json:"iLike,omitempty"`
	In       []HookStatus `json:"in,omitempty"`
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Like     *HookStatus  `json:"like,omitempty"`
	Lt       *HookStatus  `json:"lt,omitempty"`
	Lte      *HookStatus  `json:"lte,omitempty"`
	Neq      *HookStatus  `json:"neq,omitempty"`
	NotILike *HookStatus  `json:"notILike,omitempty"`
	NotIn    []HookStatus `json:"notIn,omitempty"`
	NotLike  *HookStatus  `json:"notLike,omitempty"`
}

type HubspotCredentials struct {
	HubDomain string `json:"hubDomain"`
}

func (HubspotCredentials) IsCredentials() {}

type HubspotCredentialsInput struct {
	AuthorizationCode string  `json:"authorizationCode"`
	RefreshToken      *string `json:"refreshToken,omitempty"`
}

type IdentityForbiddenError struct {
	AccessedField        string `json:"accessedField"`
	Code                 string `json:"code"`
	CurrentIdentityType  string `json:"currentIdentityType"`
	IsValidationError    bool   `json:"isValidationError"`
	RequiredIdentityType string `json:"requiredIdentityType"`
}

type ImmediateSubscriptionPreviewInvoice struct {
	Credits           *SubscriptionPreviewCredits    `json:"credits"`
	Discount          *Money                         `json:"discount"`
	DiscountDetails   *SubscriptionPreviewDiscount   `json:"discountDetails"`
	Proration         *SubscriptionPreviewProrations `json:"proration"`
	SubTotal          Money                          `json:"subTotal"`
	Tax               *Money                         `json:"tax"`
	TaxDetails        *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total             Money                          `json:"total"`
	TotalExcludingTax Money                          `json:"totalExcludingTax"`
}

type ImportAlreadyInProgressError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type ImportCustomerBulk struct {
	Customers     []*ImportCustomerInput `json:"customers"`
	EnvironmentID *string                `json:"environmentId,omitempty"`
}

type ImportCustomerInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	CustomerID         *string                `json:"customerId,omitempty"`
	Email              *string                `json:"email,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	Name               *string                `json:"name,omitempty"`
	PaymentMethodID    *string                `json:"paymentMethodId,omitempty"`
	RefID              *string                `json:"refId,omitempty"`
}

type ImportIntegrationCatalogInput struct {
	BillingModel            *BillingModel       `json:"billingModel,omitempty"`
	EntitySelectionMode     EntitySelectionMode `json:"entitySelectionMode"`
	EnvironmentID           string              `json:"environmentId"`
	FeatureUnitName         *string             `json:"featureUnitName,omitempty"`
	FeatureUnitPluralName   *string             `json:"featureUnitPluralName,omitempty"`
	PlansSelectionBlacklist []string            `json:"plansSelectionBlacklist,omitempty"`
	PlansSelectionWhitelist []string            `json:"plansSelectionWhitelist,omitempty"`
	ProductID               string              `json:"productId"`
	SelectedAddonBillingIds []string            `json:"selectedAddonBillingIds"`
	VendorIdentifier        VendorIdentifier    `json:"vendorIdentifier"`
}

type ImportIntegrationCustomersInput struct {
	CustomersSelectionBlacklist []string            `json:"customersSelectionBlacklist,omitempty"`
	CustomersSelectionWhitelist []string            `json:"customersSelectionWhitelist,omitempty"`
	EntitySelectionMode         EntitySelectionMode `json:"entitySelectionMode"`
	EnvironmentID               string              `json:"environmentId"`
	ProductID                   string              `json:"productId"`
	VendorIdentifier            VendorIdentifier    `json:"vendorIdentifier"`
}

type ImportIntegrationTask struct {
	CreatedAt          *string               `json:"createdAt"`
	CustomersCount     int64                 `json:"customersCount"`
	EndDate            *string               `json:"endDate"`
	EnvironmentID      string                `json:"environmentId"`
	ID                 string                `json:"id"`
	ImportErrors       []*ImportSubTaskError `json:"importErrors"`
	ProductsCount      int64                 `json:"productsCount"`
	Progress           int64                 `json:"progress"`
	StartDate          string                `json:"startDate"`
	Status             TaskStatus            `json:"status"`
	TaskType           TaskType              `json:"taskType"`
	TotalSubtasksCount int64                 `json:"totalSubtasksCount"`
}

type ImportIntegrationTaskAggregateGroupBy struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type ImportIntegrationTaskConnection struct {
	// Array of edges.
	Edges []*ImportIntegrationTaskEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type ImportIntegrationTaskCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
	TaskType      *int64 `json:"taskType"`
}

type ImportIntegrationTaskEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the ImportIntegrationTask
	Node ImportIntegrationTask `json:"node"`
}

type ImportIntegrationTaskFilter struct {
	And           []*ImportIntegrationTaskFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	Or            []*ImportIntegrationTaskFilter `json:"or,omitempty"`
	Status        *TaskStatusFilterComparison    `json:"status,omitempty"`
	TaskType      *TaskTypeFilterComparison      `json:"taskType,omitempty"`
}

type ImportIntegrationTaskMaxAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type ImportIntegrationTaskMinAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type ImportIntegrationTaskSort struct {
	Direction SortDirection                   `json:"direction"`
	Field     ImportIntegrationTaskSortFields `json:"field"`
	Nulls     *SortNulls                      `json:"nulls,omitempty"`
}

type ImportSubTaskError struct {
	Error string `json:"error"`
	ID    string `json:"id"`
}

type ImportSubscriptionInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	BillingPeriod      *BillingPeriod         `json:"billingPeriod,omitempty"`
	CustomerID         string                 `json:"customerId"`
	PlanID             string                 `json:"planId"`
	ResourceID         *string                `json:"resourceId,omitempty"`
	StartDate          *string                `json:"startDate,omitempty"`
	UnitQuantity       *float64               `json:"unitQuantity,omitempty"`
}

type ImportSubscriptionsBulk struct {
	EnvironmentID *string                    `json:"environmentId,omitempty"`
	Subscriptions []*ImportSubscriptionInput `json:"subscriptions"`
}

type InitAddStripeCustomerPaymentMethod struct {
	PaymentIntentClientSecret string `json:"paymentIntentClientSecret"`
}

type InitAddStripeCustomerPaymentMethodInput struct {
	CustomerRefID string  `json:"customerRefId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type InitStripePaymentMethodError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type IntFieldComparison struct {
	Between    *IntFieldComparisonBetween `json:"between,omitempty"`
	Eq         *int64                     `json:"eq,omitempty"`
	Gt         *int64                     `json:"gt,omitempty"`
	Gte        *int64                     `json:"gte,omitempty"`
	In         []int64                    `json:"in,omitempty"`
	Is         *bool                      `json:"is,omitempty"`
	IsNot      *bool                      `json:"isNot,omitempty"`
	Lt         *int64                     `json:"lt,omitempty"`
	Lte        *int64                     `json:"lte,omitempty"`
	Neq        *int64                     `json:"neq,omitempty"`
	NotBetween *IntFieldComparisonBetween `json:"notBetween,omitempty"`
	NotIn      []int64                    `json:"notIn,omitempty"`
}

type IntFieldComparisonBetween struct {
	Lower int64 `json:"lower"`
	Upper int64 `json:"upper"`
}

type Integration struct {
	Account          *Account         `json:"account"`
	CreatedAt        *string          `json:"createdAt"`
	Credentials      Credentials      `json:"credentials"`
	Environment      *Environment     `json:"environment"`
	EnvironmentID    string           `json:"environmentId"`
	ID               string           `json:"id"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationAggregateGroupBy struct {
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	ID               *string           `json:"id"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationConnection struct {
	// Array of edges.
	Edges []*IntegrationEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type IntegrationCountAggregate struct {
	CreatedAt        *int64 `json:"createdAt"`
	EnvironmentID    *int64 `json:"environmentId"`
	ID               *int64 `json:"id"`
	VendorIdentifier *int64 `json:"vendorIdentifier"`
}

type IntegrationDeleteResponse struct {
	CreatedAt        *string           `json:"createdAt"`
	Credentials      Credentials       `json:"credentials"`
	EnvironmentID    *string           `json:"environmentId"`
	ID               *string           `json:"id"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Integration
	Node Integration `json:"node"`
}

type IntegrationFilter struct {
	And              []*IntegrationFilter              `json:"and,omitempty"`
	CreatedAt        *DateFieldComparison              `json:"createdAt,omitempty"`
	EnvironmentID    *StringFieldComparison            `json:"environmentId,omitempty"`
	ID               *StringFieldComparison            `json:"id,omitempty"`
	Or               []*IntegrationFilter              `json:"or,omitempty"`
	VendorIdentifier *VendorIdentifierFilterComparison `json:"vendorIdentifier,omitempty"`
}

type IntegrationMaxAggregate struct {
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	ID               *string           `json:"id"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationMinAggregate struct {
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	ID               *string           `json:"id"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
}

type IntegrationSort struct {
	Direction SortDirection         `json:"direction"`
	Field     IntegrationSortFields `json:"field"`
	Nulls     *SortNulls            `json:"nulls,omitempty"`
}

type InvalidArgumentError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidCancellationDate struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type InvalidEntitlementResetPeriodError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidMemberDeleteError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidSubscriptionStatus struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvoiceLine struct {
	Amount      float64 `json:"amount"`
	Currency    string  `json:"currency"`
	Description *string `json:"description"`
	Proration   bool    `json:"proration"`
	Quantity    *int64  `json:"quantity"`
}

type ListAwsProductDimensionsDto struct {
	Dimensions []*AwsDimension `json:"dimensions"`
}

type ListAwsProductDimensionsInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	ProductID     string  `json:"productId"`
}

type ListAwsProductsInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type ListAwsProductsResult struct {
	Products []*AwsProduct `json:"products"`
}

type Member struct {
	Account                Account      `json:"account"`
	CreatedAt              *string      `json:"createdAt"`
	CubejsToken            *string      `json:"cubejsToken"`
	CustomerToken          *string      `json:"customerToken"`
	Email                  string       `json:"email"`
	HideGettingStartedPage *bool        `json:"hideGettingStartedPage"`
	ID                     string       `json:"id"`
	MemberStatus           MemberStatus `json:"memberStatus"`
	ServiceAPIKey          *string      `json:"serviceApiKey"`
	User                   *User        `json:"user"`
}

type MemberAggregateGroupBy struct {
	CreatedAt *string `json:"createdAt"`
	ID        *string `json:"id"`
}

type MemberConnection struct {
	// Array of edges.
	Edges []*MemberEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type MemberCountAggregate struct {
	CreatedAt *int64 `json:"createdAt"`
	ID        *int64 `json:"id"`
}

type MemberEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Member
	Node Member `json:"node"`
}

type MemberFilter struct {
	And       []*MemberFilter        `json:"and,omitempty"`
	CreatedAt *DateFieldComparison   `json:"createdAt,omitempty"`
	ID        *StringFieldComparison `json:"id,omitempty"`
	Or        []*MemberFilter        `json:"or,omitempty"`
}

type MemberInvitationError struct {
	Code   string `json:"code"`
	Reason string `json:"reason"`
}

type MemberMaxAggregate struct {
	CreatedAt *string `json:"createdAt"`
	ID        *string `json:"id"`
}

type MemberMinAggregate struct {
	CreatedAt *string `json:"createdAt"`
	ID        *string `json:"id"`
}

type MemberNotFoundError struct {
	Code string `json:"code"`
}

type MemberSort struct {
	Direction SortDirection    `json:"direction"`
	Field     MemberSortFields `json:"field"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

type MembersInviteResponse struct {
	FailedInvites  []string `json:"failedInvites"`
	SkippedInvites []string `json:"skippedInvites"`
	SuccessInvites []string `json:"successInvites"`
}

type MergeEnvironment struct {
	EnvironmentSlug string   `json:"environmentSlug"`
	TaskIds         []string `json:"taskIds"`
}

// Input type for mergeEnvironment mutation.
type MergeEnvironmentInput struct {
	// The name of the new environment. Only relevant when `destinationEnvironmentSlug` is not passed.
	DestinationEnvironmentName *string `json:"destinationEnvironmentName,omitempty"`
	// The slug of the environment to merge into. Not passing this will create a new environment and requires passing `destinationEnvironmentName`.
	DestinationEnvironmentSlug *string `json:"destinationEnvironmentSlug,omitempty"`
	// How to migrate customers to newer plan version of updated plans. Default is not to migrate existing customers.
	MigrationType *PublishMigrationType `json:"migrationType,omitempty"`
	// The slug of the environment to copy from. If missing `sourceTemplate` will be used.
	SourceEnvironmentSlug *string `json:"sourceEnvironmentSlug,omitempty"`
	// The product catalog template to apply. Only relevant when `sourceEnvironmentSlug` is not passed.
	SourceTemplate map[string]interface{} `json:"sourceTemplate,omitempty"`
}

type Meter struct {
	Aggregation   Aggregation              `json:"aggregation"`
	CreatedAt     string                   `json:"createdAt"`
	EnvironmentID string                   `json:"environmentId"`
	Filters       []*MeterFilterDefinition `json:"filters"`
	ID            string                   `json:"id"`
	UpdatedAt     string                   `json:"updatedAt"`
}

type MeterAggregation struct {
	Field    *string             `json:"field,omitempty"`
	Function AggregationFunction `json:"function"`
}

type MeterCondition struct {
	Field     string             `json:"field"`
	Operation ConditionOperation `json:"operation"`
	Value     *string            `json:"value"`
}

type MeterConditionInput struct {
	Field     string             `json:"field"`
	Operation ConditionOperation `json:"operation"`
	Value     *string            `json:"value,omitempty"`
}

type MeterFilterDefinition struct {
	Conditions []*MeterCondition `json:"conditions"`
}

type MeterFilterDefinitionInput struct {
	Conditions []*MeterConditionInput `json:"conditions"`
}

type MeterTypeFilterComparison struct {
	Eq       *MeterType  `json:"eq,omitempty"`
	Gt       *MeterType  `json:"gt,omitempty"`
	Gte      *MeterType  `json:"gte,omitempty"`
	ILike    *MeterType  `json:"iLike,omitempty"`
	In       []MeterType `json:"in,omitempty"`
	Is       *bool       `json:"is,omitempty"`
	IsNot    *bool       `json:"isNot,omitempty"`
	Like     *MeterType  `json:"like,omitempty"`
	Lt       *MeterType  `json:"lt,omitempty"`
	Lte      *MeterType  `json:"lte,omitempty"`
	Neq      *MeterType  `json:"neq,omitempty"`
	NotILike *MeterType  `json:"notILike,omitempty"`
	NotIn    []MeterType `json:"notIn,omitempty"`
	NotLike  *MeterType  `json:"notLike,omitempty"`
}

type MeteringNotAvailableForFeatureTypeError struct {
	Code              string `json:"code"`
	FeatureType       string `json:"featureType"`
	IsValidationError bool   `json:"isValidationError"`
}

type MockPaywall struct {
	Configuration *PaywallConfiguration `json:"configuration"`
	Plans         []*PaywallPlan        `json:"plans"`
}

type Money struct {
	Amount   float64  `json:"amount"`
	Currency Currency `json:"currency"`
}

type MoneyInputDto struct {
	Amount   float64   `json:"amount"`
	Currency *Currency `json:"currency,omitempty"`
}

type MonthlyResetPeriodConfig struct {
	MonthlyAccordingTo *MonthlyAccordingTo `json:"monthlyAccordingTo"`
}

func (MonthlyResetPeriodConfig) IsResetPeriodConfiguration() {}

type MonthlyResetPeriodConfigInput struct {
	AccordingTo MonthlyAccordingTo `json:"accordingTo"`
}

type NumberFieldComparison struct {
	Between    *NumberFieldComparisonBetween `json:"between,omitempty"`
	Eq         *float64                      `json:"eq,omitempty"`
	Gt         *float64                      `json:"gt,omitempty"`
	Gte        *float64                      `json:"gte,omitempty"`
	In         []float64                     `json:"in,omitempty"`
	Is         *bool                         `json:"is,omitempty"`
	IsNot      *bool                         `json:"isNot,omitempty"`
	Lt         *float64                      `json:"lt,omitempty"`
	Lte        *float64                      `json:"lte,omitempty"`
	Neq        *float64                      `json:"neq,omitempty"`
	NotBetween *NumberFieldComparisonBetween `json:"notBetween,omitempty"`
	NotIn      []float64                     `json:"notIn,omitempty"`
}

type NumberFieldComparisonBetween struct {
	Lower float64 `json:"lower"`
	Upper float64 `json:"upper"`
}

type OverageEntitlementCreateInput struct {
	Description                     *string                        `json:"description,omitempty"`
	DisplayNameOverride             *string                        `json:"displayNameOverride,omitempty"`
	FeatureID                       string                         `json:"featureId"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	HiddenFromWidgets               []WidgetType                   `json:"hiddenFromWidgets,omitempty"`
	IsCustom                        *bool                          `json:"isCustom,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	Order                           *float64                       `json:"order,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type OveragePricingModelCreateInput struct {
	BillingModel BillingModel                   `json:"billingModel"`
	Entitlement  *OverageEntitlementCreateInput `json:"entitlement,omitempty"`
	FeatureID    *string                        `json:"featureId,omitempty"`
	PricePeriods []*PricePeriodInput            `json:"pricePeriods"`
}

type PackageAlreadyPublishedError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PackageChanges struct {
	AdditionalMetaData *AdditionalMetaDataChange    `json:"additionalMetaData"`
	BasePlan           *BasePlanChange              `json:"basePlan"`
	CompatibleAddons   []*PlanCompatibleAddonChange `json:"compatibleAddons"`
	DefaultTrialConfig *DefaultTrialConfigChange    `json:"defaultTrialConfig"`
	Description        *StringChangeDto             `json:"description"`
	DisplayName        *StringChangeDto             `json:"displayName"`
	Entitlements       []*PackageEntitlementChange  `json:"entitlements"`
	HiddenFromWidgets  *HiddenFromWidgetsChange     `json:"hiddenFromWidgets"`
	OveragePrices      []*PackagePriceChange        `json:"overagePrices"`
	Prices             []*PackagePriceChange        `json:"prices"`
	PricingType        *PricingTypeChange           `json:"pricingType"`
	TotalChanges       int64                        `json:"totalChanges"`
}

type PackageDto struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	BillingID          *string                `json:"billingId"`
	BillingLinkURL     *string                `json:"billingLinkUrl"`
	CreatedAt          *string                `json:"createdAt"`
	Description        *string                `json:"description"`
	DisplayName        string                 `json:"displayName"`
	DraftDetails       *PackageDraftDetails   `json:"draftDetails"`
	DraftSummary       *PackageDraftSummary   `json:"draftSummary"`
	Entitlements       []*PackageEntitlement  `json:"entitlements"`
	EnvironmentID      string                 `json:"environmentId"`
	HiddenFromWidgets  []WidgetType           `json:"hiddenFromWidgets"`
	ID                 string                 `json:"id"`
	IsLatest           *bool                  `json:"isLatest"`
	OveragePrices      []*Price               `json:"overagePrices"`
	Prices             []*Price               `json:"prices"`
	PricingType        *PricingType           `json:"pricingType"`
	ProductID          *string                `json:"productId"`
	RefID              string                 `json:"refId"`
	Status             PackageStatus          `json:"status"`
	SyncStates         []*SyncState           `json:"syncStates"`
	Type               string                 `json:"type"`
	UpdatedAt          *string                `json:"updatedAt"`
	VersionNumber      int64                  `json:"versionNumber"`
}

type PackageDTOFilter struct {
	And           []*PackageDTOFilter            `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*PackageDTOFilter            `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PackageDTOSort struct {
	Direction SortDirection        `json:"direction"`
	Field     PackageDTOSortFields `json:"field"`
	Nulls     *SortNulls           `json:"nulls,omitempty"`
}

type PackageDraftDetails struct {
	AffectedChildPlans  []*Plan         `json:"affectedChildPlans"`
	Changes             *PackageChanges `json:"changes"`
	ChildPlansWithDraft []*Plan         `json:"childPlansWithDraft"`
	CustomersAffected   *int64          `json:"customersAffected"`
	UpdatedAt           string          `json:"updatedAt"`
	UpdatedBy           *string         `json:"updatedBy"`
	Version             int64           `json:"version"`
}

type PackageDraftSummary struct {
	UpdatedAt string  `json:"updatedAt"`
	UpdatedBy *string `json:"updatedBy"`
	Version   int64   `json:"version"`
}

type PackageEntitlement struct {
	CreatedAt                *string                  `json:"createdAt"`
	Description              *string                  `json:"description"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
	EnvironmentID            string                   `json:"environmentId"`
	Feature                  Feature                  `json:"feature"`
	FeatureID                string                   `json:"featureId"`
	HasUnlimitedUsage        *bool                    `json:"hasUnlimitedUsage"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	ID                       string                   `json:"id"`
	IsCustom                 *bool                    `json:"isCustom"`
	Meter                    *Meter                   `json:"meter"`
	Order                    *float64                 `json:"order"`
	Package                  *PackageDto              `json:"package"`
	PackageID                string                   `json:"packageId"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	UpdatedAt                *string                  `json:"updatedAt"`
	UsageLimit               *float64                 `json:"usageLimit"`
}

type PackageEntitlementAggregateGroupBy struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	UpdatedAt     *string `json:"updatedAt"`
}

type PackageEntitlementChange struct {
	After      *PackageEntitlement `json:"after"`
	Before     *PackageEntitlement `json:"before"`
	ChangeType *ChangeType         `json:"changeType"`
}

type PackageEntitlementConnection struct {
	// Array of edges.
	Edges []*PackageEntitlementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PackageEntitlementCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	PackageID     *int64 `json:"packageId"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type PackageEntitlementDeleteResponse struct {
	CreatedAt                *string                  `json:"createdAt"`
	Description              *string                  `json:"description"`
	DisplayNameOverride      *string                  `json:"displayNameOverride"`
	EnvironmentID            *string                  `json:"environmentId"`
	FeatureID                *string                  `json:"featureId"`
	HasUnlimitedUsage        *bool                    `json:"hasUnlimitedUsage"`
	HiddenFromWidgets        []WidgetType             `json:"hiddenFromWidgets"`
	ID                       *string                  `json:"id"`
	IsCustom                 *bool                    `json:"isCustom"`
	Order                    *float64                 `json:"order"`
	PackageID                *string                  `json:"packageId"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	UpdatedAt                *string                  `json:"updatedAt"`
	UsageLimit               *float64                 `json:"usageLimit"`
}

type PackageEntitlementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the PackageEntitlement
	Node PackageEntitlement `json:"node"`
}

type PackageEntitlementFilter struct {
	And           []*PackageEntitlementFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                      `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison                    `json:"environmentId,omitempty"`
	Feature       *PackageEntitlementFilterFeatureFilter    `json:"feature,omitempty"`
	ID            *StringFieldComparison                    `json:"id,omitempty"`
	Or            []*PackageEntitlementFilter               `json:"or,omitempty"`
	Package       *PackageEntitlementFilterPackageDTOFilter `json:"package,omitempty"`
	PackageID     *StringFieldComparison                    `json:"packageId,omitempty"`
	UpdatedAt     *DateFieldComparison                      `json:"updatedAt,omitempty"`
}

type PackageEntitlementFilterFeatureFilter struct {
	And           []*PackageEntitlementFilterFeatureFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                     `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                   `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                   `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison                   `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison           `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison             `json:"featureType,omitempty"`
	ID            *StringFieldComparison                   `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison               `json:"meterType,omitempty"`
	Or            []*PackageEntitlementFilterFeatureFilter `json:"or,omitempty"`
	RefID         *StringFieldComparison                   `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison                     `json:"updatedAt,omitempty"`
}

type PackageEntitlementFilterPackageDTOFilter struct {
	And           []*PackageEntitlementFilterPackageDTOFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison                      `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison                        `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                      `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                      `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison                      `json:"environmentId,omitempty"`
	ID            *StringFieldComparison                      `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison                     `json:"isLatest,omitempty"`
	Or            []*PackageEntitlementFilterPackageDTOFilter `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison                `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison                      `json:"productId,omitempty"`
	RefID         *StringFieldComparison                      `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison              `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                        `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison                         `json:"versionNumber,omitempty"`
}

type PackageEntitlementInput struct {
	Description                     *string                        `json:"description,omitempty"`
	DisplayNameOverride             *string                        `json:"displayNameOverride,omitempty"`
	EnvironmentID                   string                         `json:"environmentId"`
	FeatureID                       string                         `json:"featureId"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	HiddenFromWidgets               []WidgetType                   `json:"hiddenFromWidgets,omitempty"`
	IsCustom                        *bool                          `json:"isCustom,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	Order                           *float64                       `json:"order,omitempty"`
	PackageID                       string                         `json:"packageId"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type PackageEntitlementMaxAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	UpdatedAt     *string `json:"updatedAt"`
}

type PackageEntitlementMinAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	UpdatedAt     *string `json:"updatedAt"`
}

type PackageEntitlementSort struct {
	Direction SortDirection                `json:"direction"`
	Field     PackageEntitlementSortFields `json:"field"`
	Nulls     *SortNulls                   `json:"nulls,omitempty"`
}

type PackageEntitlementUpdateInput struct {
	Description                     *string                        `json:"description,omitempty"`
	DisplayNameOverride             *string                        `json:"displayNameOverride,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	HiddenFromWidgets               []WidgetType                   `json:"hiddenFromWidgets,omitempty"`
	IsCustom                        *bool                          `json:"isCustom,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	Order                           *float64                       `json:"order,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type PackagePrice struct {
	PackageID   string      `json:"packageId"`
	PricingType PricingType `json:"pricingType"`
}

type PackagePriceChange struct {
	After      *Price      `json:"after"`
	Before     *Price      `json:"before"`
	ChangeType *ChangeType `json:"changeType"`
}

type PackagePricingInput struct {
	EnvironmentID        string                            `json:"environmentId"`
	OveragePricingModels []*OveragePricingModelCreateInput `json:"overagePricingModels,omitempty"`
	PackageID            string                            `json:"packageId"`
	PricingModel         *PricingModelCreateInput          `json:"pricingModel,omitempty"`
	PricingModels        []*PricingModelCreateInput        `json:"pricingModels,omitempty"`
	PricingType          PricingType                       `json:"pricingType"`
	SkipPatchVolumeBulk  *bool                             `json:"skipPatchVolumeBulk,omitempty"`
}

type PackagePricingTypeNotSetError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type PackagePublishInput struct {
	ID            string               `json:"id"`
	MigrationType PublishMigrationType `json:"migrationType"`
}

type PackagePublished struct {
	AccountID      string               `json:"accountId"`
	EnvironmentID  string               `json:"environmentId"`
	MigrationType  PublishMigrationType `json:"migrationType"`
	PackageRefID   string               `json:"packageRefId"`
	PackageType    string               `json:"packageType"`
	PackageVersion int64                `json:"packageVersion"`
}

type PackageStatusFilterComparison struct {
	Eq       *PackageStatus  `json:"eq,omitempty"`
	Gt       *PackageStatus  `json:"gt,omitempty"`
	Gte      *PackageStatus  `json:"gte,omitempty"`
	ILike    *PackageStatus  `json:"iLike,omitempty"`
	In       []PackageStatus `json:"in,omitempty"`
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Like     *PackageStatus  `json:"like,omitempty"`
	Lt       *PackageStatus  `json:"lt,omitempty"`
	Lte      *PackageStatus  `json:"lte,omitempty"`
	Neq      *PackageStatus  `json:"neq,omitempty"`
	NotILike *PackageStatus  `json:"notILike,omitempty"`
	NotIn    []PackageStatus `json:"notIn,omitempty"`
	NotLike  *PackageStatus  `json:"notLike,omitempty"`
}

type PageInfo struct {
	// The cursor of the last returned record.
	EndCursor *string `json:"endCursor"`
	// true if paging forward and there are more records.
	HasNextPage *bool `json:"hasNextPage"`
	// true if paging backwards and there are more records.
	HasPreviousPage *bool `json:"hasPreviousPage"`
	// The cursor of the first returned record.
	StartCursor *string `json:"startCursor"`
}

type PaymentCollectionFilterComparison struct {
	Eq       *PaymentCollection  `json:"eq,omitempty"`
	Gt       *PaymentCollection  `json:"gt,omitempty"`
	Gte      *PaymentCollection  `json:"gte,omitempty"`
	ILike    *PaymentCollection  `json:"iLike,omitempty"`
	In       []PaymentCollection `json:"in,omitempty"`
	Is       *bool               `json:"is,omitempty"`
	IsNot    *bool               `json:"isNot,omitempty"`
	Like     *PaymentCollection  `json:"like,omitempty"`
	Lt       *PaymentCollection  `json:"lt,omitempty"`
	Lte      *PaymentCollection  `json:"lte,omitempty"`
	Neq      *PaymentCollection  `json:"neq,omitempty"`
	NotILike *PaymentCollection  `json:"notILike,omitempty"`
	NotIn    []PaymentCollection `json:"notIn,omitempty"`
	NotLike  *PaymentCollection  `json:"notLike,omitempty"`
}

type Paywall struct {
	ActiveSubscriptions          []*CustomerSubscription `json:"activeSubscriptions"`
	Configuration                *PaywallConfiguration   `json:"configuration"`
	Currency                     PaywallCurrency         `json:"currency"`
	Customer                     *Customer               `json:"customer"`
	PaywallCalculatedPricePoints []*PaywallPricePoint    `json:"paywallCalculatedPricePoints"`
	Plans                        []*Plan                 `json:"plans"`
	Resource                     *CustomerResource       `json:"resource"`
}

type PaywallAddon struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	BillingID          *string                `json:"billingId"`
	Description        *string                `json:"description"`
	DisplayName        string                 `json:"displayName"`
	Entitlements       []*Entitlement         `json:"entitlements"`
	Prices             []*PaywallPrice        `json:"prices"`
	PricingType        *PricingType           `json:"pricingType"`
	RefID              string                 `json:"refId"`
}

type PaywallBasePlan struct {
	DisplayName string `json:"displayName"`
	RefID       string `json:"refId"`
}

type PaywallColorsPalette struct {
	BackgroundColor       *string `json:"backgroundColor"`
	BorderColor           *string `json:"borderColor"`
	CurrentPlanBackground *string `json:"currentPlanBackground"`
	Primary               *string `json:"primary"`
	TextColor             *string `json:"textColor"`
}

type PaywallColorsPaletteInput struct {
	BackgroundColor       *string `json:"backgroundColor,omitempty"`
	BorderColor           *string `json:"borderColor,omitempty"`
	CurrentPlanBackground *string `json:"currentPlanBackground,omitempty"`
	Primary               *string `json:"primary,omitempty"`
	TextColor             *string `json:"textColor,omitempty"`
}

type PaywallConfiguration struct {
	CustomCSS  *string                     `json:"customCss"`
	Layout     *PaywallLayoutConfiguration `json:"layout"`
	Palette    *PaywallColorsPalette       `json:"palette"`
	Typography *TypographyConfiguration    `json:"typography"`
}

type PaywallConfigurationInput struct {
	CustomCSS  *string                          `json:"customCss,omitempty"`
	Layout     *PaywallLayoutConfigurationInput `json:"layout,omitempty"`
	Palette    *PaywallColorsPaletteInput       `json:"palette,omitempty"`
	Typography *TypographyConfigurationInput    `json:"typography,omitempty"`
}

type PaywallCurrency struct {
	Code   Currency `json:"code"`
	Symbol string   `json:"symbol"`
}

type PaywallLayoutConfiguration struct {
	Alignment   *Alignment `json:"alignment"`
	PlanMargin  *float64   `json:"planMargin"`
	PlanPadding *float64   `json:"planPadding"`
	PlanWidth   *float64   `json:"planWidth"`
}

type PaywallLayoutConfigurationInput struct {
	Alignment   *Alignment `json:"alignment,omitempty"`
	PlanMargin  *float64   `json:"planMargin,omitempty"`
	PlanPadding *float64   `json:"planPadding,omitempty"`
	PlanWidth   *float64   `json:"planWidth,omitempty"`
}

type PaywallPlan struct {
	AdditionalMetaData    map[string]interface{} `json:"additionalMetaData"`
	BasePlan              *PaywallBasePlan       `json:"basePlan"`
	BillingID             *string                `json:"billingId"`
	CompatibleAddons      []*PaywallAddon        `json:"compatibleAddons"`
	DefaultTrialConfig    *DefaultTrialConfig    `json:"defaultTrialConfig"`
	Description           *string                `json:"description"`
	DisplayName           string                 `json:"displayName"`
	Entitlements          []*Entitlement         `json:"entitlements"`
	InheritedEntitlements []*Entitlement         `json:"inheritedEntitlements"`
	Prices                []*PaywallPrice        `json:"prices"`
	PricingType           *PricingType           `json:"pricingType"`
	Product               PaywallProduct         `json:"product"`
	RefID                 string                 `json:"refId"`
}

type PaywallPrice struct {
	BillingCountryCode *string             `json:"billingCountryCode"`
	BillingID          *string             `json:"billingId"`
	BillingModel       BillingModel        `json:"billingModel"`
	BillingPeriod      BillingPeriod       `json:"billingPeriod"`
	Feature            *EntitlementFeature `json:"feature"`
	FeatureID          *string             `json:"featureId"`
	MaxUnitQuantity    *float64            `json:"maxUnitQuantity"`
	MinUnitQuantity    *float64            `json:"minUnitQuantity"`
	Price              *Money              `json:"price"`
	Tiers              []*PriceTier        `json:"tiers"`
	TiersMode          *TiersMode          `json:"tiersMode"`
}

type PaywallPricePoint struct {
	AdditionalChargesMayApply *bool         `json:"additionalChargesMayApply"`
	Amount                    float64       `json:"amount"`
	BillingCountryCode        *string       `json:"billingCountryCode"`
	BillingPeriod             BillingPeriod `json:"billingPeriod"`
	Currency                  Currency      `json:"currency"`
	Feature                   *Feature      `json:"feature"`
	PlanID                    string        `json:"planId"`
}

type PaywallProduct struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	Description        *string                `json:"description"`
	DisplayName        *string                `json:"displayName"`
	RefID              string                 `json:"refId"`
}

type Plan struct {
	AdditionalMetaData          map[string]interface{} `json:"additionalMetaData"`
	AwsMarketplacePlanDimension *string                `json:"awsMarketplacePlanDimension"`
	BasePlan                    *Plan                  `json:"basePlan"`
	BillingID                   *string                `json:"billingId"`
	BillingLinkURL              *string                `json:"billingLinkUrl"`
	CompatibleAddons            []*Addon               `json:"compatibleAddons"`
	CreatedAt                   *string                `json:"createdAt"`
	DefaultTrialConfig          *DefaultTrialConfig    `json:"defaultTrialConfig"`
	Description                 *string                `json:"description"`
	DisplayName                 string                 `json:"displayName"`
	DraftDetails                *PackageDraftDetails   `json:"draftDetails"`
	DraftSummary                *PackageDraftSummary   `json:"draftSummary"`
	Entitlements                []*PackageEntitlement  `json:"entitlements"`
	Environment                 Environment            `json:"environment"`
	EnvironmentID               string                 `json:"environmentId"`
	HiddenFromWidgets           []WidgetType           `json:"hiddenFromWidgets"`
	ID                          string                 `json:"id"`
	InheritedEntitlements       []*PackageEntitlement  `json:"inheritedEntitlements"`
	IsLatest                    *bool                  `json:"isLatest"`
	IsParent                    bool                   `json:"isParent"`
	OveragePrices               []*Price               `json:"overagePrices"`
	Prices                      []*Price               `json:"prices"`
	PricingType                 *PricingType           `json:"pricingType"`
	Product                     Product                `json:"product"`
	ProductID                   *string                `json:"productId"`
	RefID                       string                 `json:"refId"`
	Status                      PackageStatus          `json:"status"`
	SyncStates                  []*SyncState           `json:"syncStates"`
	Type                        string                 `json:"type"`
	UpdatedAt                   *string                `json:"updatedAt"`
	VersionNumber               int64                  `json:"versionNumber"`
}

type PlanAggregateGroupBy struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	IsLatest      *bool          `json:"isLatest"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type PlanCompatibleAddonChange struct {
	After      *Addon      `json:"after"`
	Before     *Addon      `json:"before"`
	ChangeType *ChangeType `json:"changeType"`
}

type PlanConnection struct {
	// Array of edges.
	Edges []*PlanEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PlanCountAggregate struct {
	BillingID     *int64 `json:"billingId"`
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	DisplayName   *int64 `json:"displayName"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	IsLatest      *int64 `json:"isLatest"`
	PricingType   *int64 `json:"pricingType"`
	ProductID     *int64 `json:"productId"`
	RefID         *int64 `json:"refId"`
	Status        *int64 `json:"status"`
	UpdatedAt     *int64 `json:"updatedAt"`
	VersionNumber *int64 `json:"versionNumber"`
}

type PlanCreateInput struct {
	AdditionalMetaData          map[string]interface{} `json:"additionalMetaData,omitempty"`
	AwsMarketplacePlanDimension *string                `json:"awsMarketplacePlanDimension,omitempty"`
	BillingID                   *string                `json:"billingId,omitempty"`
	Description                 *string                `json:"description,omitempty"`
	DisplayName                 string                 `json:"displayName"`
	EnvironmentID               *string                `json:"environmentId,omitempty"`
	HiddenFromWidgets           []WidgetType           `json:"hiddenFromWidgets,omitempty"`
	ParentPlanID                *string                `json:"parentPlanId,omitempty"`
	PricingType                 *PricingType           `json:"pricingType,omitempty"`
	ProductID                   string                 `json:"productId"`
	RefID                       *string                `json:"refId,omitempty"`
	Status                      *PackageStatus         `json:"status,omitempty"`
}

type PlanEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Plan
	Node Plan `json:"node"`
}

type PlanFilter struct {
	And              []*PlanFilter                  `json:"and,omitempty"`
	BillingID        *StringFieldComparison         `json:"billingId,omitempty"`
	CompatibleAddons *PlanFilterAddonFilter         `json:"compatibleAddons,omitempty"`
	CreatedAt        *DateFieldComparison           `json:"createdAt,omitempty"`
	Description      *StringFieldComparison         `json:"description,omitempty"`
	DisplayName      *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID    *StringFieldComparison         `json:"environmentId,omitempty"`
	ID               *StringFieldComparison         `json:"id,omitempty"`
	IsLatest         *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or               []*PlanFilter                  `json:"or,omitempty"`
	PricingType      *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	Product          *PlanFilterProductFilter       `json:"product,omitempty"`
	ProductID        *StringFieldComparison         `json:"productId,omitempty"`
	RefID            *StringFieldComparison         `json:"refId,omitempty"`
	Status           *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt        *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber    *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PlanFilterAddonFilter struct {
	And           []*PlanFilterAddonFilter       `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*PlanFilterAddonFilter       `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PlanFilterProductFilter struct {
	And                       []*PlanFilterProductFilter `json:"and,omitempty"`
	AwsMarketplaceProductCode *StringFieldComparison     `json:"awsMarketplaceProductCode,omitempty"`
	AwsMarketplaceProductID   *StringFieldComparison     `json:"awsMarketplaceProductId,omitempty"`
	CreatedAt                 *DateFieldComparison       `json:"createdAt,omitempty"`
	Description               *StringFieldComparison     `json:"description,omitempty"`
	DisplayName               *StringFieldComparison     `json:"displayName,omitempty"`
	EnvironmentID             *StringFieldComparison     `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison     `json:"id,omitempty"`
	IsDefaultProduct          *BooleanFieldComparison    `json:"isDefaultProduct,omitempty"`
	Or                        []*PlanFilterProductFilter `json:"or,omitempty"`
	RefID                     *StringFieldComparison     `json:"refId,omitempty"`
	UpdatedAt                 *DateFieldComparison       `json:"updatedAt,omitempty"`
}

type PlanMaxAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanMinAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type PlanSort struct {
	Direction SortDirection  `json:"direction"`
	Field     PlanSortFields `json:"field"`
	Nulls     *SortNulls     `json:"nulls,omitempty"`
}

type PlanSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type PlanUpdateInput struct {
	AdditionalMetaData map[string]interface{}      `json:"additionalMetaData,omitempty"`
	BillingID          *string                     `json:"billingId,omitempty"`
	DefaultTrialConfig *DefaultTrialConfigInputDto `json:"defaultTrialConfig,omitempty"`
	Description        *string                     `json:"description,omitempty"`
	DisplayName        *string                     `json:"displayName,omitempty"`
	HiddenFromWidgets  []WidgetType                `json:"hiddenFromWidgets,omitempty"`
	ID                 string                      `json:"id"`
	ParentPlanID       *string                     `json:"parentPlanId,omitempty"`
	Status             *PackageStatus              `json:"status,omitempty"`
}

type PreviewSubscriptionInput struct {
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	BillableFeatures   []*BillableFeatureInput   `json:"billableFeatures,omitempty"`
	BillingCountryCode *string                   `json:"billingCountryCode,omitempty"`
	BillingInformation *SubscriptionBillingInfo  `json:"billingInformation,omitempty"`
	BillingPeriod      *BillingPeriod            `json:"billingPeriod,omitempty"`
	CustomerID         string                    `json:"customerId"`
	EnvironmentID      *string                   `json:"environmentId,omitempty"`
	PlanID             string                    `json:"planId"`
	PromotionCode      *string                   `json:"promotionCode,omitempty"`
	ResourceID         *string                   `json:"resourceId,omitempty"`
	StartDate          *string                   `json:"startDate,omitempty"`
	UnitQuantity       *float64                  `json:"unitQuantity,omitempty"`
}

type Price struct {
	BillingCountryCode  *string       `json:"billingCountryCode"`
	BillingID           *string       `json:"billingId"`
	BillingModel        BillingModel  `json:"billingModel"`
	BillingPeriod       BillingPeriod `json:"billingPeriod"`
	CreatedAt           *string       `json:"createdAt"`
	CrmID               *string       `json:"crmId"`
	CrmLinkURL          *string       `json:"crmLinkUrl"`
	Feature             *Feature      `json:"feature"`
	FeatureID           *string       `json:"featureId"`
	ID                  string        `json:"id"`
	MaxUnitQuantity     *float64      `json:"maxUnitQuantity"`
	MinUnitQuantity     *float64      `json:"minUnitQuantity"`
	Package             PackageDto    `json:"package"`
	PackageID           *string       `json:"packageId"`
	Price               *Money        `json:"price"`
	Tiers               []*PriceTier  `json:"tiers"`
	TiersMode           *TiersMode    `json:"tiersMode"`
	UsedInSubscriptions *bool         `json:"usedInSubscriptions"`
}

type PriceAggregateGroupBy struct {
	BillingID     *string        `json:"billingId"`
	BillingModel  *BillingModel  `json:"billingModel"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	CreatedAt     *string        `json:"createdAt"`
	ID            *string        `json:"id"`
	TiersMode     *TiersMode     `json:"tiersMode"`
}

type PriceCountAggregate struct {
	BillingID     *int64 `json:"billingId"`
	BillingModel  *int64 `json:"billingModel"`
	BillingPeriod *int64 `json:"billingPeriod"`
	CreatedAt     *int64 `json:"createdAt"`
	ID            *int64 `json:"id"`
	TiersMode     *int64 `json:"tiersMode"`
}

type PriceDeleteResponse struct {
	BillingCountryCode  *string        `json:"billingCountryCode"`
	BillingID           *string        `json:"billingId"`
	BillingModel        *BillingModel  `json:"billingModel"`
	BillingPeriod       *BillingPeriod `json:"billingPeriod"`
	CreatedAt           *string        `json:"createdAt"`
	CrmID               *string        `json:"crmId"`
	CrmLinkURL          *string        `json:"crmLinkUrl"`
	Feature             *Feature       `json:"feature"`
	FeatureID           *string        `json:"featureId"`
	ID                  *string        `json:"id"`
	MaxUnitQuantity     *float64       `json:"maxUnitQuantity"`
	MinUnitQuantity     *float64       `json:"minUnitQuantity"`
	PackageID           *string        `json:"packageId"`
	Price               *Money         `json:"price"`
	Tiers               []*PriceTier   `json:"tiers"`
	TiersMode           *TiersMode     `json:"tiersMode"`
	UsedInSubscriptions *bool          `json:"usedInSubscriptions"`
}

type PriceEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Price
	Node Price `json:"node"`
}

type PriceEntitlement struct {
	Description              *string                  `json:"description"`
	Feature                  Feature                  `json:"feature"`
	FeatureID                string                   `json:"featureId"`
	HasSoftLimit             bool                     `json:"hasSoftLimit"`
	HasUnlimitedUsage        *bool                    `json:"hasUnlimitedUsage"`
	Package                  PackageDto               `json:"package"`
	PackageID                string                   `json:"packageId"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	UpdatedAt                *string                  `json:"updatedAt"`
	UsageLimit               *float64                 `json:"usageLimit"`
}

type PriceFilter struct {
	And           []*PriceFilter                 `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	BillingModel  *BillingModelFilterComparison  `json:"billingModel,omitempty"`
	BillingPeriod *BillingPeriodFilterComparison `json:"billingPeriod,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	Or            []*PriceFilter                 `json:"or,omitempty"`
	Package       *PriceFilterPackageDTOFilter   `json:"package,omitempty"`
	TiersMode     *TiersModeFilterComparison     `json:"tiersMode,omitempty"`
}

type PriceFilterPackageDTOFilter struct {
	And           []*PriceFilterPackageDTOFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ID            *StringFieldComparison         `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*PriceFilterPackageDTOFilter `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PriceMaxAggregate struct {
	BillingID     *string        `json:"billingId"`
	BillingModel  *BillingModel  `json:"billingModel"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	CreatedAt     *string        `json:"createdAt"`
	ID            *string        `json:"id"`
	TiersMode     *TiersMode     `json:"tiersMode"`
}

type PriceMinAggregate struct {
	BillingID     *string        `json:"billingId"`
	BillingModel  *BillingModel  `json:"billingModel"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	CreatedAt     *string        `json:"createdAt"`
	ID            *string        `json:"id"`
	TiersMode     *TiersMode     `json:"tiersMode"`
}

type PriceNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PricePeriodInput struct {
	BillingCountryCode *string           `json:"billingCountryCode,omitempty"`
	BillingPeriod      BillingPeriod     `json:"billingPeriod"`
	Price              *MoneyInputDto    `json:"price,omitempty"`
	Tiers              []*PriceTierInput `json:"tiers,omitempty"`
}

type PriceSort struct {
	Direction SortDirection   `json:"direction"`
	Field     PriceSortFields `json:"field"`
	Nulls     *SortNulls      `json:"nulls,omitempty"`
}

type PriceTier struct {
	FlatPrice *Money   `json:"flatPrice"`
	UnitPrice *Money   `json:"unitPrice"`
	UpTo      *float64 `json:"upTo"`
}

type PriceTierInput struct {
	FlatPrice *MoneyInputDto `json:"flatPrice,omitempty"`
	UnitPrice *MoneyInputDto `json:"unitPrice,omitempty"`
	UpTo      *float64       `json:"upTo,omitempty"`
}

type PricingModelCreateInput struct {
	BillingModel    BillingModel        `json:"billingModel"`
	FeatureID       *string             `json:"featureId,omitempty"`
	MaxUnitQuantity *float64            `json:"maxUnitQuantity,omitempty"`
	MinUnitQuantity *float64            `json:"minUnitQuantity,omitempty"`
	PricePeriods    []*PricePeriodInput `json:"pricePeriods"`
	TiersMode       *TiersMode          `json:"tiersMode,omitempty"`
}

type PricingTypeChange struct {
	After      *PricingType `json:"after"`
	Before     *PricingType `json:"before"`
	ChangeType *ChangeType  `json:"changeType"`
}

type PricingTypeFilterComparison struct {
	Eq       *PricingType  `json:"eq,omitempty"`
	Gt       *PricingType  `json:"gt,omitempty"`
	Gte      *PricingType  `json:"gte,omitempty"`
	ILike    *PricingType  `json:"iLike,omitempty"`
	In       []PricingType `json:"in,omitempty"`
	Is       *bool         `json:"is,omitempty"`
	IsNot    *bool         `json:"isNot,omitempty"`
	Like     *PricingType  `json:"like,omitempty"`
	Lt       *PricingType  `json:"lt,omitempty"`
	Lte      *PricingType  `json:"lte,omitempty"`
	Neq      *PricingType  `json:"neq,omitempty"`
	NotILike *PricingType  `json:"notILike,omitempty"`
	NotIn    []PricingType `json:"notIn,omitempty"`
	NotLike  *PricingType  `json:"notLike,omitempty"`
}

type Product struct {
	AdditionalMetaData        map[string]interface{} `json:"additionalMetaData"`
	Addons                    []*Addon               `json:"addons"`
	AwsMarketplaceProductCode *string                `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string                `json:"awsMarketplaceProductId"`
	CreatedAt                 string                 `json:"createdAt"`
	Description               *string                `json:"description"`
	DisplayName               *string                `json:"displayName"`
	DowngradePlan             *Plan                  `json:"downgradePlan"`
	Environment               *Environment           `json:"environment"`
	EnvironmentID             string                 `json:"environmentId"`
	HasSubscriptions          bool                   `json:"hasSubscriptions"`
	ID                        string                 `json:"id"`
	IsDefaultProduct          bool                   `json:"isDefaultProduct"`
	MultipleSubscriptions     bool                   `json:"multipleSubscriptions"`
	Plans                     []*Plan                `json:"plans"`
	ProductSettings           ProductSettings        `json:"productSettings"`
	RefID                     string                 `json:"refId"`
	SubscriptionStartPlan     *Plan                  `json:"subscriptionStartPlan"`
	UpdatedAt                 string                 `json:"updatedAt"`
}

type ProductAggregateGroupBy struct {
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string `json:"awsMarketplaceProductId"`
	CreatedAt                 *string `json:"createdAt"`
	Description               *string `json:"description"`
	DisplayName               *string `json:"displayName"`
	EnvironmentID             *string `json:"environmentId"`
	ID                        *string `json:"id"`
	IsDefaultProduct          *bool   `json:"isDefaultProduct"`
	RefID                     *string `json:"refId"`
	UpdatedAt                 *string `json:"updatedAt"`
}

type ProductCatalogDump struct {
	Dump map[string]interface{} `json:"dump"`
}

type ProductConnection struct {
	// Array of edges.
	Edges []*ProductEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type ProductCountAggregate struct {
	AwsMarketplaceProductCode *int64 `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *int64 `json:"awsMarketplaceProductId"`
	CreatedAt                 *int64 `json:"createdAt"`
	Description               *int64 `json:"description"`
	DisplayName               *int64 `json:"displayName"`
	EnvironmentID             *int64 `json:"environmentId"`
	ID                        *int64 `json:"id"`
	IsDefaultProduct          *int64 `json:"isDefaultProduct"`
	RefID                     *int64 `json:"refId"`
	UpdatedAt                 *int64 `json:"updatedAt"`
}

type ProductCreateInput struct {
	AdditionalMetaData    map[string]interface{} `json:"additionalMetaData,omitempty"`
	Description           *string                `json:"description,omitempty"`
	DisplayName           *string                `json:"displayName,omitempty"`
	EnvironmentID         string                 `json:"environmentId"`
	MultipleSubscriptions *bool                  `json:"multipleSubscriptions,omitempty"`
	RefID                 string                 `json:"refId"`
}

type ProductDeleteResponse struct {
	AdditionalMetaData        map[string]interface{} `json:"additionalMetaData"`
	Addons                    []*Addon               `json:"addons"`
	AwsMarketplaceProductCode *string                `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string                `json:"awsMarketplaceProductId"`
	CreatedAt                 *string                `json:"createdAt"`
	Description               *string                `json:"description"`
	DisplayName               *string                `json:"displayName"`
	EnvironmentID             *string                `json:"environmentId"`
	ID                        *string                `json:"id"`
	IsDefaultProduct          *bool                  `json:"isDefaultProduct"`
	MultipleSubscriptions     *bool                  `json:"multipleSubscriptions"`
	Plans                     []*Plan                `json:"plans"`
	ProductSettings           *ProductSettings       `json:"productSettings"`
	RefID                     *string                `json:"refId"`
	UpdatedAt                 *string                `json:"updatedAt"`
}

type ProductEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Product
	Node Product `json:"node"`
}

type ProductFilter struct {
	And                       []*ProductFilter        `json:"and,omitempty"`
	AwsMarketplaceProductCode *StringFieldComparison  `json:"awsMarketplaceProductCode,omitempty"`
	AwsMarketplaceProductID   *StringFieldComparison  `json:"awsMarketplaceProductId,omitempty"`
	CreatedAt                 *DateFieldComparison    `json:"createdAt,omitempty"`
	Description               *StringFieldComparison  `json:"description,omitempty"`
	DisplayName               *StringFieldComparison  `json:"displayName,omitempty"`
	EnvironmentID             *StringFieldComparison  `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison  `json:"id,omitempty"`
	IsDefaultProduct          *BooleanFieldComparison `json:"isDefaultProduct,omitempty"`
	Or                        []*ProductFilter        `json:"or,omitempty"`
	RefID                     *StringFieldComparison  `json:"refId,omitempty"`
	UpdatedAt                 *DateFieldComparison    `json:"updatedAt,omitempty"`
}

type ProductMaxAggregate struct {
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string `json:"awsMarketplaceProductId"`
	CreatedAt                 *string `json:"createdAt"`
	Description               *string `json:"description"`
	DisplayName               *string `json:"displayName"`
	EnvironmentID             *string `json:"environmentId"`
	ID                        *string `json:"id"`
	RefID                     *string `json:"refId"`
	UpdatedAt                 *string `json:"updatedAt"`
}

type ProductMinAggregate struct {
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string `json:"awsMarketplaceProductId"`
	CreatedAt                 *string `json:"createdAt"`
	Description               *string `json:"description"`
	DisplayName               *string `json:"displayName"`
	EnvironmentID             *string `json:"environmentId"`
	ID                        *string `json:"id"`
	RefID                     *string `json:"refId"`
	UpdatedAt                 *string `json:"updatedAt"`
}

type ProductSettings struct {
	DowngradePlan                *Plan                        `json:"downgradePlan"`
	DowngradePlanID              *string                      `json:"downgradePlanId"`
	SubscriptionCancellationTime SubscriptionCancellationTime `json:"subscriptionCancellationTime"`
	SubscriptionEndSetup         SubscriptionEndSetup         `json:"subscriptionEndSetup"`
	SubscriptionStartPlan        *Plan                        `json:"subscriptionStartPlan"`
	SubscriptionStartPlanID      *string                      `json:"subscriptionStartPlanId"`
	SubscriptionStartSetup       SubscriptionStartSetup       `json:"subscriptionStartSetup"`
}

type ProductSettingsInput struct {
	DowngradeAtEndOfBillingPeriod *string                      `json:"downgradeAtEndOfBillingPeriod,omitempty"`
	DowngradePlanID               *string                      `json:"downgradePlanId,omitempty"`
	SubscriptionCancellationTime  SubscriptionCancellationTime `json:"subscriptionCancellationTime"`
	SubscriptionEndSetup          SubscriptionEndSetup         `json:"subscriptionEndSetup"`
	SubscriptionStartPlanID       *string                      `json:"subscriptionStartPlanId,omitempty"`
	SubscriptionStartSetup        SubscriptionStartSetup       `json:"subscriptionStartSetup"`
}

type ProductSort struct {
	Direction SortDirection     `json:"direction"`
	Field     ProductSortFields `json:"field"`
	Nulls     *SortNulls        `json:"nulls,omitempty"`
}

type ProductUpdateInput struct {
	AdditionalMetaData    map[string]interface{} `json:"additionalMetaData,omitempty"`
	Description           *string                `json:"description,omitempty"`
	DisplayName           *string                `json:"displayName,omitempty"`
	MultipleSubscriptions *bool                  `json:"multipleSubscriptions,omitempty"`
	ProductSettings       *ProductSettingsInput  `json:"productSettings,omitempty"`
}

type PromotionCodeCustomerNotFirstPurchase struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeMaxRedemptionsReached struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeMinimumAmountNotReached struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeNotActive struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeNotForCustomer struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeNotFound struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionalEntitlement struct {
	CreatedAt                *string                      `json:"createdAt"`
	Customer                 Customer                     `json:"customer"`
	Description              *string                      `json:"description"`
	EndDate                  *string                      `json:"endDate"`
	EnvironmentID            string                       `json:"environmentId"`
	Feature                  Feature                      `json:"feature"`
	FeatureID                string                       `json:"featureId"`
	HasSoftLimit             bool                         `json:"hasSoftLimit"`
	HasUnlimitedUsage        *bool                        `json:"hasUnlimitedUsage"`
	ID                       string                       `json:"id"`
	IsVisible                bool                         `json:"isVisible"`
	Meter                    *Meter                       `json:"meter"`
	Period                   PromotionalEntitlementPeriod `json:"period"`
	ResetPeriod              *EntitlementResetPeriod      `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration     `json:"resetPeriodConfiguration"`
	StartDate                string                       `json:"startDate"`
	Status                   PromotionalEntitlementStatus `json:"status"`
	Unlimited                *bool                        `json:"unlimited"`
	UpdatedAt                *string                      `json:"updatedAt"`
	UsageLimit               *float64                     `json:"usageLimit"`
}

type PromotionalEntitlementAggregateGroupBy struct {
	CreatedAt     *string                       `json:"createdAt"`
	EnvironmentID *string                       `json:"environmentId"`
	ID            *string                       `json:"id"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	UpdatedAt     *string                       `json:"updatedAt"`
}

type PromotionalEntitlementConnection struct {
	// Array of edges.
	Edges []*PromotionalEntitlementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PromotionalEntitlementCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type PromotionalEntitlementDeleteResponse struct {
	CreatedAt                *string                       `json:"createdAt"`
	Description              *string                       `json:"description"`
	EndDate                  *string                       `json:"endDate"`
	EnvironmentID            *string                       `json:"environmentId"`
	FeatureID                *string                       `json:"featureId"`
	HasSoftLimit             *bool                         `json:"hasSoftLimit"`
	HasUnlimitedUsage        *bool                         `json:"hasUnlimitedUsage"`
	ID                       *string                       `json:"id"`
	IsVisible                *bool                         `json:"isVisible"`
	Period                   *PromotionalEntitlementPeriod `json:"period"`
	ResetPeriod              *EntitlementResetPeriod       `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration      `json:"resetPeriodConfiguration"`
	StartDate                *string                       `json:"startDate"`
	Status                   *PromotionalEntitlementStatus `json:"status"`
	Unlimited                *bool                         `json:"unlimited"`
	UpdatedAt                *string                       `json:"updatedAt"`
	UsageLimit               *float64                      `json:"usageLimit"`
}

type PromotionalEntitlementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the PromotionalEntitlement
	Node PromotionalEntitlement `json:"node"`
}

type PromotionalEntitlementFilter struct {
	And           []*PromotionalEntitlementFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison                        `json:"environmentId,omitempty"`
	ID            *StringFieldComparison                        `json:"id,omitempty"`
	Or            []*PromotionalEntitlementFilter               `json:"or,omitempty"`
	Status        *PromotionalEntitlementStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
}

type PromotionalEntitlementInput struct {
	CustomerID                      string                         `json:"customerId"`
	Description                     *string                        `json:"description,omitempty"`
	EndDate                         *string                        `json:"endDate,omitempty"`
	EnvironmentID                   string                         `json:"environmentId"`
	FeatureID                       string                         `json:"featureId"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	IsVisible                       bool                           `json:"isVisible"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	Period                          PromotionalEntitlementPeriod   `json:"period"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type PromotionalEntitlementMaxAggregate struct {
	CreatedAt     *string                       `json:"createdAt"`
	EnvironmentID *string                       `json:"environmentId"`
	ID            *string                       `json:"id"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	UpdatedAt     *string                       `json:"updatedAt"`
}

type PromotionalEntitlementMinAggregate struct {
	CreatedAt     *string                       `json:"createdAt"`
	EnvironmentID *string                       `json:"environmentId"`
	ID            *string                       `json:"id"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	UpdatedAt     *string                       `json:"updatedAt"`
}

type PromotionalEntitlementSort struct {
	Direction SortDirection                    `json:"direction"`
	Field     PromotionalEntitlementSortFields `json:"field"`
	Nulls     *SortNulls                       `json:"nulls,omitempty"`
}

type PromotionalEntitlementStatusFilterComparison struct {
	Eq       *PromotionalEntitlementStatus  `json:"eq,omitempty"`
	Gt       *PromotionalEntitlementStatus  `json:"gt,omitempty"`
	Gte      *PromotionalEntitlementStatus  `json:"gte,omitempty"`
	ILike    *PromotionalEntitlementStatus  `json:"iLike,omitempty"`
	In       []PromotionalEntitlementStatus `json:"in,omitempty"`
	Is       *bool                          `json:"is,omitempty"`
	IsNot    *bool                          `json:"isNot,omitempty"`
	Like     *PromotionalEntitlementStatus  `json:"like,omitempty"`
	Lt       *PromotionalEntitlementStatus  `json:"lt,omitempty"`
	Lte      *PromotionalEntitlementStatus  `json:"lte,omitempty"`
	Neq      *PromotionalEntitlementStatus  `json:"neq,omitempty"`
	NotILike *PromotionalEntitlementStatus  `json:"notILike,omitempty"`
	NotIn    []PromotionalEntitlementStatus `json:"notIn,omitempty"`
	NotLike  *PromotionalEntitlementStatus  `json:"notLike,omitempty"`
}

type PromotionalEntitlementUpdateInput struct {
	Description                     *string                        `json:"description,omitempty"`
	EndDate                         *string                        `json:"endDate,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	IsVisible                       bool                           `json:"isVisible"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	Period                          PromotionalEntitlementPeriod   `json:"period"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
}

type ProvisionCustomerInput struct {
	AdditionalMetaData       map[string]interface{}              `json:"additionalMetaData,omitempty"`
	AwsMarketplaceCustomerID *string                             `json:"awsMarketplaceCustomerId,omitempty"`
	BillingID                *string                             `json:"billingId,omitempty"`
	BillingInformation       *CustomerBillingInfo                `json:"billingInformation,omitempty"`
	CouponRefID              *string                             `json:"couponRefId,omitempty"`
	CreatedAt                *string                             `json:"createdAt,omitempty"`
	CrmID                    *string                             `json:"crmId,omitempty"`
	CustomerID               *string                             `json:"customerId,omitempty"`
	Email                    *string                             `json:"email,omitempty"`
	EnvironmentID            *string                             `json:"environmentId,omitempty"`
	ExcludeFromExperiment    *bool                               `json:"excludeFromExperiment,omitempty"`
	Name                     *string                             `json:"name,omitempty"`
	RefID                    *string                             `json:"refId,omitempty"`
	ShouldSyncFree           *bool                               `json:"shouldSyncFree,omitempty"`
	SubscriptionParams       *ProvisionCustomerSubscriptionInput `json:"subscriptionParams,omitempty"`
}

type ProvisionCustomerSubscriptionInput struct {
	AdditionalMetaData         map[string]interface{}           `json:"additionalMetaData,omitempty"`
	Addons                     []*SubscriptionAddonInput        `json:"addons,omitempty"`
	AwaitPaymentConfirmation   *bool                            `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures           []*BillableFeatureInput          `json:"billableFeatures,omitempty"`
	BillingCountryCode         *string                          `json:"billingCountryCode,omitempty"`
	BillingID                  *string                          `json:"billingId,omitempty"`
	BillingInformation         *SubscriptionBillingInfo         `json:"billingInformation,omitempty"`
	BillingPeriod              *BillingPeriod                   `json:"billingPeriod,omitempty"`
	PlanID                     string                           `json:"planId"`
	PriceUnitAmount            *float64                         `json:"priceUnitAmount,omitempty"`
	PromotionCode              *string                          `json:"promotionCode,omitempty"`
	RefID                      *string                          `json:"refId,omitempty"`
	ResourceID                 *string                          `json:"resourceId,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID             *string                          `json:"subscriptionId,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

type ProvisionSandboxInput struct {
	BillingModel BillingModel `json:"billingModel"`
	DisplayName  string       `json:"displayName"`
}

type ProvisionSubscription struct {
	AdditionalMetaData         map[string]interface{}           `json:"additionalMetaData,omitempty"`
	Addons                     []*SubscriptionAddonInput        `json:"addons,omitempty"`
	AwaitPaymentConfirmation   *bool                            `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures           []*BillableFeatureInput          `json:"billableFeatures,omitempty"`
	BillingCountryCode         *string                          `json:"billingCountryCode,omitempty"`
	BillingID                  *string                          `json:"billingId,omitempty"`
	BillingInformation         *SubscriptionBillingInfo         `json:"billingInformation,omitempty"`
	BillingPeriod              *BillingPeriod                   `json:"billingPeriod,omitempty"`
	CheckoutOptions            *CheckoutOptions                 `json:"checkoutOptions,omitempty"`
	CustomerID                 string                           `json:"customerId"`
	PlanID                     string                           `json:"planId"`
	PriceUnitAmount            *float64                         `json:"priceUnitAmount,omitempty"`
	PromotionCode              *string                          `json:"promotionCode,omitempty"`
	RefID                      *string                          `json:"refId,omitempty"`
	ResourceID                 *string                          `json:"resourceId,omitempty"`
	SkipTrial                  *bool                            `json:"skipTrial,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID             *string                          `json:"subscriptionId,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

type ProvisionSubscriptionInput struct {
	AdditionalMetaData         map[string]interface{}           `json:"additionalMetaData,omitempty"`
	Addons                     []*SubscriptionAddonInput        `json:"addons,omitempty"`
	AwaitPaymentConfirmation   *bool                            `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures           []*BillableFeatureInput          `json:"billableFeatures,omitempty"`
	BillingCountryCode         *string                          `json:"billingCountryCode,omitempty"`
	BillingID                  *string                          `json:"billingId,omitempty"`
	BillingInformation         *SubscriptionBillingInfo         `json:"billingInformation,omitempty"`
	BillingPeriod              *BillingPeriod                   `json:"billingPeriod,omitempty"`
	CheckoutOptions            *CheckoutOptions                 `json:"checkoutOptions,omitempty"`
	CustomerID                 string                           `json:"customerId"`
	PlanID                     string                           `json:"planId"`
	PriceUnitAmount            *float64                         `json:"priceUnitAmount,omitempty"`
	PromotionCode              *string                          `json:"promotionCode,omitempty"`
	RefID                      *string                          `json:"refId,omitempty"`
	ResourceID                 *string                          `json:"resourceId,omitempty"`
	SkipTrial                  *bool                            `json:"skipTrial,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID             *string                          `json:"subscriptionId,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

type ProvisionSubscriptionResult struct {
	CheckoutBillingID *string                     `json:"checkoutBillingId"`
	CheckoutURL       *string                     `json:"checkoutUrl"`
	Entitlements      []*Entitlement              `json:"entitlements"`
	ID                string                      `json:"id"`
	IsScheduled       *bool                       `json:"isScheduled"`
	Status            ProvisionSubscriptionStatus `json:"status"`
	Subscription      *CustomerSubscription       `json:"subscription"`
}

type ProvisionedCustomer struct {
	Customer                     Customer                     `json:"customer"`
	Entitlements                 []*Entitlement               `json:"entitlements"`
	Subscription                 *CustomerSubscription        `json:"subscription"`
	SubscriptionDecisionStrategy SubscriptionDecisionStrategy `json:"subscriptionDecisionStrategy"`
	SubscriptionStrategyDecision SubscriptionDecisionStrategy `json:"subscriptionStrategyDecision"`
}

type PublishPackageResult struct {
	TaskID *string `json:"taskId"`
}

type RecalculateEntitlementsInput struct {
	CustomerIds     []string `json:"customerIds,omitempty"`
	EnvironmentID   string   `json:"environmentId"`
	ForAllCustomers *bool    `json:"forAllCustomers,omitempty"`
}

type RecalculateEntitlementsResult struct {
	TaskID string `json:"taskId"`
}

type RemoveBasePlanFromPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveCompatibleAddonsFromPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type RemoveCouponFromCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveCouponFromCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveExperimentFromCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveExperimentFromCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type ReportUsageBaseInput struct {
	CreatedAt      *string              `json:"createdAt,omitempty"`
	CustomerID     string               `json:"customerId"`
	FeatureID      string               `json:"featureId"`
	ResourceID     *string              `json:"resourceId,omitempty"`
	UpdateBehavior *UsageUpdateBehavior `json:"updateBehavior,omitempty"`
	Value          float64              `json:"value"`
}

type ReportUsageBulkInput struct {
	EnvironmentID *string                 `json:"environmentId,omitempty"`
	Usages        []*ReportUsageBaseInput `json:"usages"`
}

type ReportUsageInput struct {
	CreatedAt      *string              `json:"createdAt,omitempty"`
	CustomerID     string               `json:"customerId"`
	EnvironmentID  *string              `json:"environmentId,omitempty"`
	FeatureID      string               `json:"featureId"`
	ResourceID     *string              `json:"resourceId,omitempty"`
	UpdateBehavior *UsageUpdateBehavior `json:"updateBehavior,omitempty"`
	Value          float64              `json:"value"`
}

type ResyncIntegrationInput struct {
	EnvironmentID    string           `json:"environmentId"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

type ResyncIntegrationResult struct {
	TaskID string `json:"taskId"`
}

type RevokePromotionalEntitlementInput struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
	FeatureID     string  `json:"featureId"`
}

type SdkConfiguration struct {
	IsWidgetWatermarkEnabled *bool   `json:"isWidgetWatermarkEnabled"`
	SentryDsn                *string `json:"sentryDsn"`
}

type SetBasePlanOnPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetCompatibleAddonsOnPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type SetCouponOnCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetCouponOnCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetExperimentOnCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetExperimentOnCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type StartExperimentInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	RefID         string  `json:"refId"`
}

type StopExperimentInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
	RefID         string  `json:"refId"`
}

type StringChangeDto struct {
	After      *string     `json:"after"`
	Before     *string     `json:"before"`
	ChangeType *ChangeType `json:"changeType"`
}

type StringFieldComparison struct {
	Eq       *string  `json:"eq,omitempty"`
	Gt       *string  `json:"gt,omitempty"`
	Gte      *string  `json:"gte,omitempty"`
	ILike    *string  `json:"iLike,omitempty"`
	In       []string `json:"in,omitempty"`
	Is       *bool    `json:"is,omitempty"`
	IsNot    *bool    `json:"isNot,omitempty"`
	Like     *string  `json:"like,omitempty"`
	Lt       *string  `json:"lt,omitempty"`
	Lte      *string  `json:"lte,omitempty"`
	Neq      *string  `json:"neq,omitempty"`
	NotILike *string  `json:"notILike,omitempty"`
	NotIn    []string `json:"notIn,omitempty"`
	NotLike  *string  `json:"notLike,omitempty"`
}

type StripeCredentials struct {
	AccountDisplayName string `json:"accountDisplayName"`
	AccountID          string `json:"accountId"`
	IsTestMode         bool   `json:"isTestMode"`
}

func (StripeCredentials) IsCredentials() {}

type StripeCredentialsInput struct {
	AccountID         *string `json:"accountId,omitempty"`
	AuthorizationCode string  `json:"authorizationCode"`
	IsTestMode        bool    `json:"isTestMode"`
}

type StripeCustomer struct {
	CreatedAt            string  `json:"createdAt"`
	Email                string  `json:"email"`
	EnvironmentID        *string `json:"environmentId"`
	ID                   string  `json:"id"`
	IsSynced             bool    `json:"isSynced"`
	Name                 string  `json:"name"`
	SubscriptionPlanName *string `json:"subscriptionPlanName"`
	SubscriptionsCount   float64 `json:"subscriptionsCount"`
}

type StripeCustomerIsDeleted struct {
	BillingID         string `json:"billingId"`
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type StripeCustomerSearchInput struct {
	CustomerName  *string `json:"customerName,omitempty"`
	EnvironmentID string  `json:"environmentId"`
	NextPage      *string `json:"nextPage,omitempty"`
}

type StripeCustomerSearchResult struct {
	Customers  []*StripeCustomer `json:"customers"`
	NextPage   *string           `json:"nextPage"`
	TotalCount int64             `json:"totalCount"`
}

type StripeProduct struct {
	EnvironmentID         *string               `json:"environmentId"`
	ID                    string                `json:"id"`
	IsSynced              bool                  `json:"isSynced"`
	Name                  string                `json:"name"`
	NotSupportedForImport bool                  `json:"notSupportedForImport"`
	Prices                []*StripeProductPrice `json:"prices"`
	UpdatedAt             string                `json:"updatedAt"`
}

type StripeProductPrice struct {
	Amount        float64        `json:"amount"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
}

type StripeProductSearchInput struct {
	EnvironmentID string  `json:"environmentId"`
	NextPage      *string `json:"nextPage,omitempty"`
	ProductName   *string `json:"productName,omitempty"`
}

type StripeProductSearchResult struct {
	NextPage                 *string          `json:"nextPage"`
	Products                 []*StripeProduct `json:"products"`
	TotalCount               int64            `json:"totalCount"`
	UsageBasedProductPresent *bool            `json:"usageBasedProductPresent"`
}

type StripeSubscription struct {
	ID string `json:"id"`
}

type StripeSubscriptionSearchInput struct {
	EnvironmentID string  `json:"environmentId"`
	NextPage      *string `json:"nextPage,omitempty"`
}

type StripeSubscriptionSearchResult struct {
	NextPage      *string               `json:"nextPage"`
	Subscriptions []*StripeSubscription `json:"subscriptions"`
	TotalCount    int64                 `json:"totalCount"`
}

type SubscriptionAddon struct {
	Addon        Addon                `json:"addon"`
	CreatedAt    *string              `json:"createdAt"`
	ID           string               `json:"id"`
	Price        *Price               `json:"price"`
	Quantity     float64              `json:"quantity"`
	Subscription CustomerSubscription `json:"subscription"`
	UpdatedAt    string               `json:"updatedAt"`
}

type SubscriptionAddonAggregateGroupBy struct {
	CreatedAt *string  `json:"createdAt"`
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
}

type SubscriptionAddonAvgAggregate struct {
	Quantity *float64 `json:"quantity"`
}

type SubscriptionAddonCountAggregate struct {
	CreatedAt *int64 `json:"createdAt"`
	ID        *int64 `json:"id"`
	Quantity  *int64 `json:"quantity"`
	UpdatedAt *int64 `json:"updatedAt"`
}

type SubscriptionAddonEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionAddon
	Node SubscriptionAddon `json:"node"`
}

type SubscriptionAddonFilter struct {
	Addon        *SubscriptionAddonFilterAddonFilter                `json:"addon,omitempty"`
	And          []*SubscriptionAddonFilter                         `json:"and,omitempty"`
	CreatedAt    *DateFieldComparison                               `json:"createdAt,omitempty"`
	ID           *StringFieldComparison                             `json:"id,omitempty"`
	Or           []*SubscriptionAddonFilter                         `json:"or,omitempty"`
	Price        *SubscriptionAddonFilterPriceFilter                `json:"price,omitempty"`
	Quantity     *NumberFieldComparison                             `json:"quantity,omitempty"`
	Subscription *SubscriptionAddonFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
	UpdatedAt    *DateFieldComparison                               `json:"updatedAt,omitempty"`
}

type SubscriptionAddonFilterAddonFilter struct {
	And           []*SubscriptionAddonFilterAddonFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison                `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison                `json:"environmentId,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison               `json:"isLatest,omitempty"`
	Or            []*SubscriptionAddonFilterAddonFilter `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison          `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison                `json:"productId,omitempty"`
	RefID         *StringFieldComparison                `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison        `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                  `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison                   `json:"versionNumber,omitempty"`
}

type SubscriptionAddonFilterCustomerSubscriptionFilter struct {
	And                       []*SubscriptionAddonFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingID                 *StringFieldComparison                               `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison            `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                 `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                 `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                               `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                               `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                 `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                 `json:"currentBillingPeriodStart,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                 `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                 `json:"endDate,omitempty"`
	EnvironmentID             *StringFieldComparison                               `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison                               `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                               `json:"oldBillingId,omitempty"`
	Or                        []*SubscriptionAddonFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                   `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                         `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                               `json:"refId,omitempty"`
	ResourceID                *StringFieldComparison                               `json:"resourceId,omitempty"`
	StartDate                 *DateFieldComparison                                 `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                  `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                               `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                 `json:"trialEndDate,omitempty"`
}

type SubscriptionAddonFilterPriceFilter struct {
	And           []*SubscriptionAddonFilterPriceFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison                `json:"billingId,omitempty"`
	BillingModel  *BillingModelFilterComparison         `json:"billingModel,omitempty"`
	BillingPeriod *BillingPeriodFilterComparison        `json:"billingPeriod,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	Or            []*SubscriptionAddonFilterPriceFilter `json:"or,omitempty"`
	TiersMode     *TiersModeFilterComparison            `json:"tiersMode,omitempty"`
}

type SubscriptionAddonInput struct {
	AddonID  string `json:"addonId"`
	Quantity *int64 `json:"quantity,omitempty"`
}

type SubscriptionAddonMaxAggregate struct {
	CreatedAt *string  `json:"createdAt"`
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
}

type SubscriptionAddonMinAggregate struct {
	CreatedAt *string  `json:"createdAt"`
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
}

type SubscriptionAddonSort struct {
	Direction SortDirection               `json:"direction"`
	Field     SubscriptionAddonSortFields `json:"field"`
	Nulls     *SortNulls                  `json:"nulls,omitempty"`
}

type SubscriptionAddonSumAggregate struct {
	Quantity *float64 `json:"quantity"`
}

type SubscriptionAlreadyCanceledOrExpired struct {
	Code              string             `json:"code"`
	IsValidationError bool               `json:"isValidationError"`
	RefID             string             `json:"refId"`
	Status            SubscriptionStatus `json:"status"`
}

type SubscriptionBillingInfo struct {
	BillingAddress          *BillingAddress        `json:"billingAddress,omitempty"`
	ChargeOnBehalfOfAccount *string                `json:"chargeOnBehalfOfAccount,omitempty"`
	CouponID                *string                `json:"couponId,omitempty"`
	IsBackdated             *bool                  `json:"isBackdated,omitempty"`
	IsInvoicePaid           *bool                  `json:"isInvoicePaid,omitempty"`
	Metadata                map[string]interface{} `json:"metadata,omitempty"`
	TaxPercentage           *float64               `json:"taxPercentage,omitempty"`
	TaxRateIds              []string               `json:"taxRateIds,omitempty"`
}

type SubscriptionCancelReasonFilterComparison struct {
	Eq       *SubscriptionCancelReason  `json:"eq,omitempty"`
	Gt       *SubscriptionCancelReason  `json:"gt,omitempty"`
	Gte      *SubscriptionCancelReason  `json:"gte,omitempty"`
	ILike    *SubscriptionCancelReason  `json:"iLike,omitempty"`
	In       []SubscriptionCancelReason `json:"in,omitempty"`
	Is       *bool                      `json:"is,omitempty"`
	IsNot    *bool                      `json:"isNot,omitempty"`
	Like     *SubscriptionCancelReason  `json:"like,omitempty"`
	Lt       *SubscriptionCancelReason  `json:"lt,omitempty"`
	Lte      *SubscriptionCancelReason  `json:"lte,omitempty"`
	Neq      *SubscriptionCancelReason  `json:"neq,omitempty"`
	NotILike *SubscriptionCancelReason  `json:"notILike,omitempty"`
	NotIn    []SubscriptionCancelReason `json:"notIn,omitempty"`
	NotLike  *SubscriptionCancelReason  `json:"notLike,omitempty"`
}

type SubscriptionCancellationInput struct {
	EndDate                        *string                         `json:"endDate,omitempty"`
	EnvironmentID                  *string                         `json:"environmentId,omitempty"`
	SubscriptionCancellationAction *SubscriptionCancellationAction `json:"subscriptionCancellationAction,omitempty"`
	SubscriptionCancellationTime   *SubscriptionCancellationTime   `json:"subscriptionCancellationTime,omitempty"`
	SubscriptionRefID              string                          `json:"subscriptionRefId"`
}

type SubscriptionCoupon struct {
	DiscountValue float64    `json:"discountValue"`
	EnvironmentID string     `json:"environmentId"`
	ID            string     `json:"id"`
	Name          string     `json:"name"`
	RefID         string     `json:"refId"`
	Type          CouponType `json:"type"`
}

type SubscriptionEntitlement struct {
	CreatedAt                *string                  `json:"createdAt"`
	Description              *string                  `json:"description"`
	EnvironmentID            string                   `json:"environmentId"`
	Feature                  Feature                  `json:"feature"`
	FeatureID                string                   `json:"featureId"`
	HasUnlimitedUsage        *bool                    `json:"hasUnlimitedUsage"`
	ID                       string                   `json:"id"`
	Meter                    *Meter                   `json:"meter"`
	ResetPeriod              *EntitlementResetPeriod  `json:"resetPeriod"`
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	Subscription             CustomerSubscription     `json:"subscription"`
	SubscriptionID           string                   `json:"subscriptionId"`
	UpdatedAt                *string                  `json:"updatedAt"`
	UsageLimit               *float64                 `json:"usageLimit"`
}

type SubscriptionEntitlementAggregateGroupBy struct {
	CreatedAt      *string `json:"createdAt"`
	EnvironmentID  *string `json:"environmentId"`
	ID             *string `json:"id"`
	SubscriptionID *string `json:"subscriptionId"`
	UpdatedAt      *string `json:"updatedAt"`
}

type SubscriptionEntitlementConnection struct {
	// Array of edges.
	Edges []*SubscriptionEntitlementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type SubscriptionEntitlementCountAggregate struct {
	CreatedAt      *int64 `json:"createdAt"`
	EnvironmentID  *int64 `json:"environmentId"`
	ID             *int64 `json:"id"`
	SubscriptionID *int64 `json:"subscriptionId"`
	UpdatedAt      *int64 `json:"updatedAt"`
}

type SubscriptionEntitlementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionEntitlement
	Node SubscriptionEntitlement `json:"node"`
}

type SubscriptionEntitlementFilter struct {
	And            []*SubscriptionEntitlementFilter                         `json:"and,omitempty"`
	CreatedAt      *DateFieldComparison                                     `json:"createdAt,omitempty"`
	EnvironmentID  *StringFieldComparison                                   `json:"environmentId,omitempty"`
	Feature        *SubscriptionEntitlementFilterFeatureFilter              `json:"feature,omitempty"`
	ID             *StringFieldComparison                                   `json:"id,omitempty"`
	Or             []*SubscriptionEntitlementFilter                         `json:"or,omitempty"`
	Subscription   *SubscriptionEntitlementFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
	SubscriptionID *StringFieldComparison                                   `json:"subscriptionId,omitempty"`
	UpdatedAt      *DateFieldComparison                                     `json:"updatedAt,omitempty"`
}

type SubscriptionEntitlementFilterCustomerSubscriptionFilter struct {
	And                       []*SubscriptionEntitlementFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingID                 *StringFieldComparison                                     `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison                  `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                       `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                       `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                                     `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                                     `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                       `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                       `json:"currentBillingPeriodStart,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                       `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                       `json:"endDate,omitempty"`
	EnvironmentID             *StringFieldComparison                                     `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison                                     `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                                     `json:"oldBillingId,omitempty"`
	Or                        []*SubscriptionEntitlementFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                         `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                               `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                                     `json:"refId,omitempty"`
	ResourceID                *StringFieldComparison                                     `json:"resourceId,omitempty"`
	StartDate                 *DateFieldComparison                                       `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                        `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                                     `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                       `json:"trialEndDate,omitempty"`
}

type SubscriptionEntitlementFilterFeatureFilter struct {
	And           []*SubscriptionEntitlementFilterFeatureFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                        `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                        `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison                        `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison                `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison                  `json:"featureType,omitempty"`
	ID            *StringFieldComparison                        `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison                    `json:"meterType,omitempty"`
	Or            []*SubscriptionEntitlementFilterFeatureFilter `json:"or,omitempty"`
	RefID         *StringFieldComparison                        `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
}

type SubscriptionEntitlementInput struct {
	Description                     *string                        `json:"description,omitempty"`
	FeatureID                       string                         `json:"featureId"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type SubscriptionEntitlementMaxAggregate struct {
	CreatedAt      *string `json:"createdAt"`
	EnvironmentID  *string `json:"environmentId"`
	ID             *string `json:"id"`
	SubscriptionID *string `json:"subscriptionId"`
	UpdatedAt      *string `json:"updatedAt"`
}

type SubscriptionEntitlementMinAggregate struct {
	CreatedAt      *string `json:"createdAt"`
	EnvironmentID  *string `json:"environmentId"`
	ID             *string `json:"id"`
	SubscriptionID *string `json:"subscriptionId"`
	UpdatedAt      *string `json:"updatedAt"`
}

type SubscriptionEntitlementSort struct {
	Direction SortDirection                     `json:"direction"`
	Field     SubscriptionEntitlementSortFields `json:"field"`
	Nulls     *SortNulls                        `json:"nulls,omitempty"`
}

type SubscriptionFutureUpdate struct {
	BillingID                *string                    `json:"billingId"`
	CreatedAt                *string                    `json:"createdAt"`
	ScheduleStatus           SubscriptionScheduleStatus `json:"scheduleStatus"`
	ScheduleVariables        ScheduleVariables          `json:"scheduleVariables"`
	ScheduledExecutionTime   string                     `json:"scheduledExecutionTime"`
	SubscriptionScheduleType SubscriptionScheduleType   `json:"subscriptionScheduleType"`
	TargetPackage            *PackageDto                `json:"targetPackage"`
}

type SubscriptionInput struct {
	AdditionalMetaData        map[string]interface{}          `json:"additionalMetaData,omitempty"`
	Addons                    []*SubscriptionAddonInput       `json:"addons,omitempty"`
	AwaitPaymentConfirmation  *bool                           `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures          []*BillableFeatureInput         `json:"billableFeatures,omitempty"`
	BillingCountryCode        *string                         `json:"billingCountryCode,omitempty"`
	BillingID                 *string                         `json:"billingId,omitempty"`
	BillingInformation        *SubscriptionBillingInfo        `json:"billingInformation,omitempty"`
	BillingPeriod             *BillingPeriod                  `json:"billingPeriod,omitempty"`
	CrmID                     *string                         `json:"crmId,omitempty"`
	CustomerID                string                          `json:"customerId"`
	EndDate                   *string                         `json:"endDate,omitempty"`
	EnvironmentID             *string                         `json:"environmentId,omitempty"`
	IsCustomPriceSubscription *bool                           `json:"isCustomPriceSubscription,omitempty"`
	IsOverridingTrialConfig   *bool                           `json:"isOverridingTrialConfig,omitempty"`
	IsTrial                   *bool                           `json:"isTrial,omitempty"`
	PlanID                    string                          `json:"planId"`
	PriceUnitAmount           *float64                        `json:"priceUnitAmount,omitempty"`
	PromotionCode             *string                         `json:"promotionCode,omitempty"`
	RefID                     *string                         `json:"refId,omitempty"`
	ResourceID                *string                         `json:"resourceId,omitempty"`
	StartDate                 *string                         `json:"startDate,omitempty"`
	SubscriptionEntitlements  []*SubscriptionEntitlementInput `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID            *string                         `json:"subscriptionId,omitempty"`
	UnitQuantity              *float64                        `json:"unitQuantity,omitempty"`
}

type SubscriptionInvoice struct {
	AmountDue            *float64                  `json:"amountDue"`
	AppliedBalance       *float64                  `json:"appliedBalance"`
	BillingID            string                    `json:"billingId"`
	CreatedAt            string                    `json:"createdAt"`
	Currency             *string                   `json:"currency"`
	EndingBalance        *float64                  `json:"endingBalance"`
	ErrorMessage         *string                   `json:"errorMessage"`
	Lines                []*InvoiceLine            `json:"lines"`
	PaymentSecret        *string                   `json:"paymentSecret"`
	PaymentURL           *string                   `json:"paymentUrl"`
	PDFURL               *string                   `json:"pdfUrl"`
	RequiresAction       bool                      `json:"requiresAction"`
	StartingBalance      *float64                  `json:"startingBalance"`
	Status               SubscriptionInvoiceStatus `json:"status"`
	SubTotal             *float64                  `json:"subTotal"`
	SubTotalExcludingTax *float64                  `json:"subTotalExcludingTax"`
	Tax                  *float64                  `json:"tax"`
	Total                *float64                  `json:"total"`
	TotalExcludingTax    *float64                  `json:"totalExcludingTax"`
	UpdatedAt            string                    `json:"updatedAt"`
}

type SubscriptionMigrationInput struct {
	EnvironmentID             *string                    `json:"environmentId,omitempty"`
	SubscriptionID            string                     `json:"subscriptionId"`
	SubscriptionMigrationTime *SubscriptionMigrationTime `json:"subscriptionMigrationTime,omitempty"`
}

type SubscriptionMigrationTask struct {
	AffectedCustomersCount *int64        `json:"affectedCustomersCount"`
	CreatedAt              *string       `json:"createdAt"`
	EndDate                *string       `json:"endDate"`
	EnvironmentID          string        `json:"environmentId"`
	ID                     string        `json:"id"`
	InitiatedPackageID     *string       `json:"initiatedPackageId"`
	MigratedCustomersCount *int64        `json:"migratedCustomersCount"`
	Packages               []*PackageDto `json:"packages"`
	Progress               int64         `json:"progress"`
	StartDate              string        `json:"startDate"`
	Status                 TaskStatus    `json:"status"`
	TaskType               TaskType      `json:"taskType"`
}

type SubscriptionMigrationTaskAggregateGroupBy struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type SubscriptionMigrationTaskConnection struct {
	// Array of edges.
	Edges []*SubscriptionMigrationTaskEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type SubscriptionMigrationTaskCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
	TaskType      *int64 `json:"taskType"`
}

type SubscriptionMigrationTaskEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionMigrationTask
	Node SubscriptionMigrationTask `json:"node"`
}

type SubscriptionMigrationTaskFilter struct {
	And           []*SubscriptionMigrationTaskFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison               `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison             `json:"environmentId,omitempty"`
	ID            *StringFieldComparison             `json:"id,omitempty"`
	Or            []*SubscriptionMigrationTaskFilter `json:"or,omitempty"`
	Status        *TaskStatusFilterComparison        `json:"status,omitempty"`
	TaskType      *TaskTypeFilterComparison          `json:"taskType,omitempty"`
}

type SubscriptionMigrationTaskMaxAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type SubscriptionMigrationTaskMinAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type SubscriptionMigrationTaskSort struct {
	Direction SortDirection                       `json:"direction"`
	Field     SubscriptionMigrationTaskSortFields `json:"field"`
	Nulls     *SortNulls                          `json:"nulls,omitempty"`
}

type SubscriptionMustHaveSinglePlanError struct {
	Code              string   `json:"code"`
	IsValidationError bool     `json:"isValidationError"`
	RefIds            []string `json:"refIds"`
}

type SubscriptionPreview struct {
	BillingPeriodRange  DateRange                      `json:"billingPeriodRange"`
	Credits             *SubscriptionPreviewCredits    `json:"credits"`
	Discount            *SubscriptionPreviewDiscount   `json:"discount"`
	DiscountAmount      *Money                         `json:"discountAmount"`
	HasScheduledUpdates *bool                          `json:"hasScheduledUpdates"`
	IsPlanDowngrade     *bool                          `json:"isPlanDowngrade"`
	Proration           *SubscriptionPreviewProrations `json:"proration"`
	SubTotal            Money                          `json:"subTotal"`
	Subscription        *SubscriptionPricePreviewDto   `json:"subscription"`
	Tax                 *Money                         `json:"tax"`
	TaxDetails          *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total               Money                          `json:"total"`
	TotalExcludingTax   Money                          `json:"totalExcludingTax"`
}

type SubscriptionPreviewCredits struct {
	Initial   Money `json:"initial"`
	Remaining Money `json:"remaining"`
	Used      Money `json:"used"`
}

type SubscriptionPreviewDiscount struct {
	DurationInMonths *float64             `json:"durationInMonths"`
	DurationType     DiscountDurationType `json:"durationType"`
	Type             DiscountType         `json:"type"`
	Value            float64              `json:"value"`
}

type SubscriptionPreviewInvoice struct {
	Discount          *Money                         `json:"discount"`
	DiscountDetails   *SubscriptionPreviewDiscount   `json:"discountDetails"`
	SubTotal          Money                          `json:"subTotal"`
	Tax               *Money                         `json:"tax"`
	TaxDetails        *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total             Money                          `json:"total"`
	TotalExcludingTax Money                          `json:"totalExcludingTax"`
}

type SubscriptionPreviewProrations struct {
	Credit        Money  `json:"credit"`
	Debit         Money  `json:"debit"`
	HasProrations *bool  `json:"hasProrations"`
	NetAmount     Money  `json:"netAmount"`
	ProrationDate string `json:"prorationDate"`
}

type SubscriptionPreviewTaxDetails struct {
	DisplayName string  `json:"displayName"`
	Inclusive   bool    `json:"inclusive"`
	Percentage  float64 `json:"percentage"`
}

type SubscriptionPreviewV2 struct {
	BillingPeriodRange  DateRange                           `json:"billingPeriodRange"`
	HasScheduledUpdates *bool                               `json:"hasScheduledUpdates"`
	ImmediateInvoice    ImmediateSubscriptionPreviewInvoice `json:"immediateInvoice"`
	IsPlanDowngrade     *bool                               `json:"isPlanDowngrade"`
	RecurringInvoice    *SubscriptionPreviewInvoice         `json:"recurringInvoice"`
}

type SubscriptionPrice struct {
	BillingModel *BillingModel        `json:"billingModel"`
	CreatedAt    *string              `json:"createdAt"`
	FeatureID    *string              `json:"featureId"`
	ID           string               `json:"id"`
	Price        *Price               `json:"price"`
	Subscription CustomerSubscription `json:"subscription"`
	UpdatedAt    string               `json:"updatedAt"`
	UsageLimit   *float64             `json:"usageLimit"`
}

type SubscriptionPriceAggregateGroupBy struct {
	BillingModel *BillingModel `json:"billingModel"`
	CreatedAt    *string       `json:"createdAt"`
	FeatureID    *string       `json:"featureId"`
	ID           *string       `json:"id"`
	UpdatedAt    *string       `json:"updatedAt"`
	UsageLimit   *float64      `json:"usageLimit"`
}

type SubscriptionPriceAvgAggregate struct {
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPriceCountAggregate struct {
	BillingModel *int64 `json:"billingModel"`
	CreatedAt    *int64 `json:"createdAt"`
	FeatureID    *int64 `json:"featureId"`
	ID           *int64 `json:"id"`
	UpdatedAt    *int64 `json:"updatedAt"`
	UsageLimit   *int64 `json:"usageLimit"`
}

type SubscriptionPriceEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionPrice
	Node SubscriptionPrice `json:"node"`
}

type SubscriptionPriceFilter struct {
	And          []*SubscriptionPriceFilter                         `json:"and,omitempty"`
	BillingModel *BillingModelFilterComparison                      `json:"billingModel,omitempty"`
	CreatedAt    *DateFieldComparison                               `json:"createdAt,omitempty"`
	FeatureID    *StringFieldComparison                             `json:"featureId,omitempty"`
	ID           *StringFieldComparison                             `json:"id,omitempty"`
	Or           []*SubscriptionPriceFilter                         `json:"or,omitempty"`
	Price        *SubscriptionPriceFilterPriceFilter                `json:"price,omitempty"`
	Subscription *SubscriptionPriceFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
	UpdatedAt    *DateFieldComparison                               `json:"updatedAt,omitempty"`
	UsageLimit   *NumberFieldComparison                             `json:"usageLimit,omitempty"`
}

type SubscriptionPriceFilterCustomerSubscriptionFilter struct {
	And                       []*SubscriptionPriceFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingID                 *StringFieldComparison                               `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison            `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                 `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                 `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                               `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                               `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                 `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                 `json:"currentBillingPeriodStart,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                 `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                 `json:"endDate,omitempty"`
	EnvironmentID             *StringFieldComparison                               `json:"environmentId,omitempty"`
	ID                        *StringFieldComparison                               `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                               `json:"oldBillingId,omitempty"`
	Or                        []*SubscriptionPriceFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                   `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                         `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                               `json:"refId,omitempty"`
	ResourceID                *StringFieldComparison                               `json:"resourceId,omitempty"`
	StartDate                 *DateFieldComparison                                 `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                  `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                               `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                 `json:"trialEndDate,omitempty"`
}

type SubscriptionPriceFilterPriceFilter struct {
	And           []*SubscriptionPriceFilterPriceFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison                `json:"billingId,omitempty"`
	BillingModel  *BillingModelFilterComparison         `json:"billingModel,omitempty"`
	BillingPeriod *BillingPeriodFilterComparison        `json:"billingPeriod,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	Or            []*SubscriptionPriceFilterPriceFilter `json:"or,omitempty"`
	TiersMode     *TiersModeFilterComparison            `json:"tiersMode,omitempty"`
}

type SubscriptionPriceMaxAggregate struct {
	BillingModel *BillingModel `json:"billingModel"`
	CreatedAt    *string       `json:"createdAt"`
	FeatureID    *string       `json:"featureId"`
	ID           *string       `json:"id"`
	UpdatedAt    *string       `json:"updatedAt"`
	UsageLimit   *float64      `json:"usageLimit"`
}

type SubscriptionPriceMinAggregate struct {
	BillingModel *BillingModel `json:"billingModel"`
	CreatedAt    *string       `json:"createdAt"`
	FeatureID    *string       `json:"featureId"`
	ID           *string       `json:"id"`
	UpdatedAt    *string       `json:"updatedAt"`
	UsageLimit   *float64      `json:"usageLimit"`
}

type SubscriptionPricePreviewDto struct {
	Discount          *SubscriptionPreviewDiscount   `json:"discount"`
	DiscountAmount    *Money                         `json:"discountAmount"`
	SubTotal          Money                          `json:"subTotal"`
	Tax               Money                          `json:"tax"`
	TaxDetails        *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total             Money                          `json:"total"`
	TotalExcludingTax Money                          `json:"totalExcludingTax"`
}

type SubscriptionPriceSort struct {
	Direction SortDirection               `json:"direction"`
	Field     SubscriptionPriceSortFields `json:"field"`
	Nulls     *SortNulls                  `json:"nulls,omitempty"`
}

type SubscriptionPriceSumAggregate struct {
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPricingTypeStatistics struct {
	PricingType PricingType `json:"pricingType"`
	TotalCount  float64     `json:"totalCount"`
}

type SubscriptionScheduledUpdate struct {
	BillingID                *string                    `json:"billingId"`
	CreatedAt                *string                    `json:"createdAt"`
	ScheduleStatus           SubscriptionScheduleStatus `json:"scheduleStatus"`
	ScheduleVariables        ScheduleVariables          `json:"scheduleVariables"`
	ScheduledExecutionTime   string                     `json:"scheduledExecutionTime"`
	SubscriptionScheduleType SubscriptionScheduleType   `json:"subscriptionScheduleType"`
	TargetPackage            *PackageDto                `json:"targetPackage"`
}

type SubscriptionStatusFilterComparison struct {
	Eq       *SubscriptionStatus  `json:"eq,omitempty"`
	Gt       *SubscriptionStatus  `json:"gt,omitempty"`
	Gte      *SubscriptionStatus  `json:"gte,omitempty"`
	ILike    *SubscriptionStatus  `json:"iLike,omitempty"`
	In       []SubscriptionStatus `json:"in,omitempty"`
	Is       *bool                `json:"is,omitempty"`
	IsNot    *bool                `json:"isNot,omitempty"`
	Like     *SubscriptionStatus  `json:"like,omitempty"`
	Lt       *SubscriptionStatus  `json:"lt,omitempty"`
	Lte      *SubscriptionStatus  `json:"lte,omitempty"`
	Neq      *SubscriptionStatus  `json:"neq,omitempty"`
	NotILike *SubscriptionStatus  `json:"notILike,omitempty"`
	NotIn    []SubscriptionStatus `json:"notIn,omitempty"`
	NotLike  *SubscriptionStatus  `json:"notLike,omitempty"`
}

type SubscriptionUpdateScheduleCancellationInput struct {
	EnvironmentID  *string                     `json:"environmentId,omitempty"`
	Status         *SubscriptionScheduleStatus `json:"status,omitempty"`
	SubscriptionID string                      `json:"subscriptionId"`
}

type SyncState struct {
	Error            *string          `json:"error"`
	Status           SyncStatus       `json:"status"`
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

type SyncTaxRatesInput struct {
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type TaskStatusFilterComparison struct {
	Eq       *TaskStatus  `json:"eq,omitempty"`
	Gt       *TaskStatus  `json:"gt,omitempty"`
	Gte      *TaskStatus  `json:"gte,omitempty"`
	ILike    *TaskStatus  `json:"iLike,omitempty"`
	In       []TaskStatus `json:"in,omitempty"`
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Like     *TaskStatus  `json:"like,omitempty"`
	Lt       *TaskStatus  `json:"lt,omitempty"`
	Lte      *TaskStatus  `json:"lte,omitempty"`
	Neq      *TaskStatus  `json:"neq,omitempty"`
	NotILike *TaskStatus  `json:"notILike,omitempty"`
	NotIn    []TaskStatus `json:"notIn,omitempty"`
	NotLike  *TaskStatus  `json:"notLike,omitempty"`
}

type TaskTypeFilterComparison struct {
	Eq       *TaskType  `json:"eq,omitempty"`
	Gt       *TaskType  `json:"gt,omitempty"`
	Gte      *TaskType  `json:"gte,omitempty"`
	ILike    *TaskType  `json:"iLike,omitempty"`
	In       []TaskType `json:"in,omitempty"`
	Is       *bool      `json:"is,omitempty"`
	IsNot    *bool      `json:"isNot,omitempty"`
	Like     *TaskType  `json:"like,omitempty"`
	Lt       *TaskType  `json:"lt,omitempty"`
	Lte      *TaskType  `json:"lte,omitempty"`
	Neq      *TaskType  `json:"neq,omitempty"`
	NotILike *TaskType  `json:"notILike,omitempty"`
	NotIn    []TaskType `json:"notIn,omitempty"`
	NotLike  *TaskType  `json:"notLike,omitempty"`
}

type TaxExempt struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

type TestHook struct {
	TestHookEventType string `json:"testHookEventType"`
	TestHookPayload   string `json:"testHookPayload"`
}

type TestHookInput struct {
	EndpointURL   string       `json:"endpointUrl"`
	EnvironmentID string       `json:"environmentId"`
	HookEventType EventLogType `json:"hookEventType"`
}

type TestHookResult struct {
	ResponsePayload    string   `json:"responsePayload"`
	ResponseStatusCode *float64 `json:"responseStatusCode"`
	ResponseStatusText *string  `json:"responseStatusText"`
	ResponseSuccess    bool     `json:"responseSuccess"`
}

type TiersModeFilterComparison struct {
	Eq       *TiersMode  `json:"eq,omitempty"`
	Gt       *TiersMode  `json:"gt,omitempty"`
	Gte      *TiersMode  `json:"gte,omitempty"`
	ILike    *TiersMode  `json:"iLike,omitempty"`
	In       []TiersMode `json:"in,omitempty"`
	Is       *bool       `json:"is,omitempty"`
	IsNot    *bool       `json:"isNot,omitempty"`
	Like     *TiersMode  `json:"like,omitempty"`
	Lt       *TiersMode  `json:"lt,omitempty"`
	Lte      *TiersMode  `json:"lte,omitempty"`
	Neq      *TiersMode  `json:"neq,omitempty"`
	NotILike *TiersMode  `json:"notILike,omitempty"`
	NotIn    []TiersMode `json:"notIn,omitempty"`
	NotLike  *TiersMode  `json:"notLike,omitempty"`
}

type TransferSubscriptionInput struct {
	CustomerID            string `json:"customerId"`
	DestinationResourceID string `json:"destinationResourceId"`
	SourceResourceID      string `json:"sourceResourceId"`
}

type TrialMinDateError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type TrialMustBeCancelledImmediately struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type TrialOverrideConfigurationInput struct {
	IsTrial      bool    `json:"isTrial"`
	TrialEndDate *string `json:"trialEndDate,omitempty"`
}

type TrialedPlan struct {
	PlanID       *string `json:"planId"`
	PlanRefID    *string `json:"planRefId"`
	ProductID    *string `json:"productId"`
	ProductRefID *string `json:"productRefId"`
}

type TriggerSubscriptionMigrationInput struct {
	EnvironmentID string  `json:"environmentId"`
	RefID         string  `json:"refId"`
	VersionNumber float64 `json:"versionNumber"`
}

type TriggerSubscriptionMigrationResult struct {
	TaskID *string `json:"taskId"`
}

type TypographyConfiguration struct {
	Body       *FontVariant `json:"body"`
	FontFamily *string      `json:"fontFamily"`
	H1         *FontVariant `json:"h1"`
	H2         *FontVariant `json:"h2"`
	H3         *FontVariant `json:"h3"`
}

type TypographyConfigurationInput struct {
	Body       *FontVariantInput `json:"body,omitempty"`
	FontFamily *string           `json:"fontFamily,omitempty"`
	H1         *FontVariantInput `json:"h1,omitempty"`
	H2         *FontVariantInput `json:"h2,omitempty"`
	H3         *FontVariantInput `json:"h3,omitempty"`
}

type UnPublishedPackageError struct {
	Code                   string   `json:"code"`
	IsValidationError      bool     `json:"isValidationError"`
	NonPublishedPackageIds []string `json:"nonPublishedPackageIds"`
	PackageType            string   `json:"packageType"`
}

type UnarchiveCustomerInput struct {
	CustomerID    string  `json:"customerId"`
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type UnarchiveEnvironmentInput struct {
	ID   *string `json:"id,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

type UncompatibleSubscriptionAddonError struct {
	Code                string   `json:"code"`
	IsValidationError   bool     `json:"isValidationError"`
	NonCompatibleAddons []string `json:"nonCompatibleAddons"`
	PlanDisplayName     string   `json:"planDisplayName"`
}

type UnitAmountChangeVariables struct {
	FeatureID     *string  `json:"featureId"`
	NewUnitAmount *float64 `json:"newUnitAmount"`
}

func (UnitAmountChangeVariables) IsScheduleVariables() {}

type UnsupportedFeatureTypeError struct {
	Code        string `json:"code"`
	FeatureType string `json:"featureType"`
}

type UnsupportedVendorIdentifierError struct {
	Code             string `json:"code"`
	VendorIdentifier string `json:"vendorIdentifier"`
}

type UpdateAccountInput struct {
	DisplayName                   string             `json:"displayName"`
	ID                            *string            `json:"id,omitempty"`
	SubscriptionBillingAnchor     *BillingAnchor     `json:"subscriptionBillingAnchor,omitempty"`
	SubscriptionProrationBehavior *ProrationBehavior `json:"subscriptionProrationBehavior,omitempty"`
	Timezone                      *string            `json:"timezone,omitempty"`
}

type UpdateCouponInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	Description        *string                `json:"description,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	Name               string                 `json:"name"`
	RefID              string                 `json:"refId"`
}

type UpdateCustomerInput struct {
	AdditionalMetaData       map[string]interface{} `json:"additionalMetaData,omitempty"`
	AwsMarketplaceCustomerID *string                `json:"awsMarketplaceCustomerId,omitempty"`
	BillingID                *string                `json:"billingId,omitempty"`
	BillingInformation       *CustomerBillingInfo   `json:"billingInformation,omitempty"`
	CouponRefID              *string                `json:"couponRefId,omitempty"`
	CrmID                    *string                `json:"crmId,omitempty"`
	CustomerID               *string                `json:"customerId,omitempty"`
	Email                    *string                `json:"email,omitempty"`
	EnvironmentID            *string                `json:"environmentId,omitempty"`
	Name                     *string                `json:"name,omitempty"`
	RefID                    *string                `json:"refId,omitempty"`
	ShouldWaitSync           *bool                  `json:"shouldWaitSync,omitempty"`
}

type UpdateEntitlementsOrderDto struct {
	ID    string   `json:"id"`
	Order *float64 `json:"order"`
}

type UpdateExperimentInput struct {
	ControlGroupName  *string               `json:"controlGroupName,omitempty"`
	Description       *string               `json:"description,omitempty"`
	EnvironmentID     *string               `json:"environmentId,omitempty"`
	Name              *string               `json:"name,omitempty"`
	ProductID         *string               `json:"productId,omitempty"`
	ProductSettings   *ProductSettingsInput `json:"productSettings,omitempty"`
	RefID             string                `json:"refId"`
	VariantGroupName  *string               `json:"variantGroupName,omitempty"`
	VariantPercentage *float64              `json:"variantPercentage,omitempty"`
}

type UpdateFeature struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	CreatedAt          *string                `json:"createdAt,omitempty"`
	Description        *string                `json:"description,omitempty"`
	DisplayName        *string                `json:"displayName,omitempty"`
	EnvironmentID      *string                `json:"environmentId,omitempty"`
	FeatureStatus      *FeatureStatus         `json:"featureStatus,omitempty"`
	FeatureType        *FeatureType           `json:"featureType,omitempty"`
	FeatureUnits       *string                `json:"featureUnits,omitempty"`
	FeatureUnitsPlural *string                `json:"featureUnitsPlural,omitempty"`
	ID                 *string                `json:"id,omitempty"`
	MeterType          *MeterType             `json:"meterType,omitempty"`
	RefID              *string                `json:"refId,omitempty"`
	UpdatedAt          *string                `json:"updatedAt,omitempty"`
}

type UpdateFeatureInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	Description        *string                `json:"description,omitempty"`
	DisplayName        *string                `json:"displayName,omitempty"`
	EnvironmentID      string                 `json:"environmentId"`
	FeatureUnits       *string                `json:"featureUnits,omitempty"`
	FeatureUnitsPlural *string                `json:"featureUnitsPlural,omitempty"`
	Meter              *CreateMeter           `json:"meter,omitempty"`
	RefID              string                 `json:"refId"`
}

type UpdateHook struct {
	CreatedAt     *string        `json:"createdAt,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Endpoint      *string        `json:"endpoint,omitempty"`
	EnvironmentID *string        `json:"environmentId,omitempty"`
	EventLogTypes []EventLogType `json:"eventLogTypes,omitempty"`
	ID            *string        `json:"id,omitempty"`
	SecretKey     *string        `json:"secretKey,omitempty"`
	Status        *HookStatus    `json:"status,omitempty"`
}

type UpdateIntegrationInput struct {
	StripeCredentials *StripeCredentialsInput `json:"stripeCredentials,omitempty"`
	VendorIdentifier  VendorIdentifier        `json:"vendorIdentifier"`
	ZuoraCredentials  *ZuoraCredentialsInput  `json:"zuoraCredentials,omitempty"`
}

type UpdateOneEnvironmentInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update EnvironmentInput `json:"update"`
}

type UpdateOneFeatureInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateFeature `json:"update"`
}

type UpdateOneHookInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateHook `json:"update"`
}

type UpdateOneIntegrationInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateIntegrationInput `json:"update"`
}

type UpdateOnePackageEntitlementInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update PackageEntitlementUpdateInput `json:"update"`
}

type UpdateOneProductInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update ProductUpdateInput `json:"update"`
}

type UpdateOnePromotionalEntitlementInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update PromotionalEntitlementUpdateInput `json:"update"`
}

type UpdatePackageEntitlementOrderInput struct {
	Entitlements  []*UpdatePackageEntitlementOrderItemInput `json:"entitlements"`
	EnvironmentID *string                                   `json:"environmentId,omitempty"`
	PackageID     string                                    `json:"packageId"`
}

type UpdatePackageEntitlementOrderItemInput struct {
	ID    string   `json:"id"`
	Order *float64 `json:"order,omitempty"`
}

type UpdateSubscriptionEntitlementInput struct {
	FeatureID                       *string                        `json:"featureId,omitempty"`
	HasUnlimitedUsage               *bool                          `json:"hasUnlimitedUsage,omitempty"`
	ID                              *string                        `json:"id,omitempty"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	UsageLimit                      *float64                       `json:"usageLimit,omitempty"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type UpdateSubscriptionInput struct {
	AdditionalMetaData       map[string]interface{}                `json:"additionalMetaData,omitempty"`
	Addons                   []*SubscriptionAddonInput             `json:"addons,omitempty"`
	AwaitPaymentConfirmation *bool                                 `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures         []*BillableFeatureInput               `json:"billableFeatures,omitempty"`
	BillingInformation       *SubscriptionBillingInfo              `json:"billingInformation,omitempty"`
	BillingPeriod            *BillingPeriod                        `json:"billingPeriod,omitempty"`
	EnvironmentID            *string                               `json:"environmentId,omitempty"`
	PromotionCode            *string                               `json:"promotionCode,omitempty"`
	RefID                    *string                               `json:"refId,omitempty"`
	SubscriptionEntitlements []*UpdateSubscriptionEntitlementInput `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID           *string                               `json:"subscriptionId,omitempty"`
	TrialEndDate             *string                               `json:"trialEndDate,omitempty"`
	UnitQuantity             *float64                              `json:"unitQuantity,omitempty"`
}

type UpdateUserInput struct {
	Department *Department `json:"department,omitempty"`
	Name       string      `json:"name"`
}

type UsageEvent struct {
	CustomerID string                 `json:"customerId"`
	Dimensions map[string]interface{} `json:"dimensions"`
	EventName  string                 `json:"eventName"`
	ID         string                 `json:"id"`
	ResourceID *string                `json:"resourceId"`
	Timestamp  string                 `json:"timestamp"`
}

type UsageEventReportInput struct {
	CustomerID     string                 `json:"customerId"`
	Dimensions     map[string]interface{} `json:"dimensions,omitempty"`
	EventName      string                 `json:"eventName"`
	IdempotencyKey string                 `json:"idempotencyKey"`
	ResourceID     *string                `json:"resourceId,omitempty"`
	Timestamp      *string                `json:"timestamp,omitempty"`
}

type UsageEventsInput struct {
	EnvironmentID string                        `json:"environmentId"`
	Filters       []*MeterFilterDefinitionInput `json:"filters,omitempty"`
}

type UsageEventsPreview struct {
	Events []*UsageEvent `json:"events"`
}

type UsageEventsReportInput struct {
	EnvironmentID *string                  `json:"environmentId,omitempty"`
	UsageEvents   []*UsageEventReportInput `json:"usageEvents"`
}

type UsageHistory struct {
	EndDate           *string                  `json:"endDate"`
	StartDate         string                   `json:"startDate"`
	UsageMeasurements []*UsageMeasurementPoint `json:"usageMeasurements"`
}

type UsageHistoryInput struct {
	CustomerRefID                   string                         `json:"customerRefId"`
	EndDate                         *string                        `json:"endDate,omitempty"`
	EnvironmentID                   *string                        `json:"environmentId,omitempty"`
	FeatureRefID                    string                         `json:"featureRefId"`
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	ResetPeriod                     *EntitlementResetPeriod        `json:"resetPeriod,omitempty"`
	ResourceRefID                   *string                        `json:"resourceRefId,omitempty"`
	StartDate                       string                         `json:"startDate"`
	WeeklyResetPeriodConfiguration  *WeeklyResetPeriodConfigInput  `json:"weeklyResetPeriodConfiguration,omitempty"`
	YearlyResetPeriodConfiguration  *YearlyResetPeriodConfigInput  `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type UsageMeasurement struct {
	CreatedAt     string      `json:"createdAt"`
	Customer      Customer    `json:"customer"`
	CustomerID    string      `json:"customerId"`
	Environment   Environment `json:"environment"`
	EnvironmentID string      `json:"environmentId"`
	Feature       Feature     `json:"feature"`
	FeatureID     string      `json:"featureId"`
	ID            string      `json:"id"`
	Value         float64     `json:"value"`
}

type UsageMeasurementAggregateGroupBy struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type UsageMeasurementAvgAggregate struct {
	ID *float64 `json:"id"`
}

type UsageMeasurementConnection struct {
	// Array of edges.
	Edges []*UsageMeasurementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type UsageMeasurementCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
}

type UsageMeasurementCreateInput struct {
	CreatedAt      *string              `json:"createdAt,omitempty"`
	CustomerID     string               `json:"customerId"`
	EnvironmentID  *string              `json:"environmentId,omitempty"`
	FeatureID      string               `json:"featureId"`
	ResourceID     *string              `json:"resourceId,omitempty"`
	UpdateBehavior *UsageUpdateBehavior `json:"updateBehavior,omitempty"`
	Value          float64              `json:"value"`
}

type UsageMeasurementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the UsageMeasurement
	Node UsageMeasurement `json:"node"`
}

type UsageMeasurementFilter struct {
	And           []*UsageMeasurementFilter             `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	Customer      *UsageMeasurementFilterCustomerFilter `json:"customer,omitempty"`
	EnvironmentID *StringFieldComparison                `json:"environmentId,omitempty"`
	Feature       *UsageMeasurementFilterFeatureFilter  `json:"feature,omitempty"`
	ID            *StringFieldComparison                `json:"id,omitempty"`
	Or            []*UsageMeasurementFilter             `json:"or,omitempty"`
}

type UsageMeasurementFilterCustomerFilter struct {
	And                  []*UsageMeasurementFilterCustomerFilter `json:"and,omitempty"`
	BillingID            *StringFieldComparison                  `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                    `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                  `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                  `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison                  `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison                  `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                    `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison                  `json:"email,omitempty"`
	EnvironmentID        *StringFieldComparison                  `json:"environmentId,omitempty"`
	ID                   *StringFieldComparison                  `json:"id,omitempty"`
	Name                 *StringFieldComparison                  `json:"name,omitempty"`
	Or                   []*UsageMeasurementFilterCustomerFilter `json:"or,omitempty"`
	RefID                *StringFieldComparison                  `json:"refId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison    `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                    `json:"updatedAt,omitempty"`
}

type UsageMeasurementFilterFeatureFilter struct {
	And           []*UsageMeasurementFilterFeatureFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                   `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                 `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                 `json:"displayName,omitempty"`
	EnvironmentID *StringFieldComparison                 `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison         `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison           `json:"featureType,omitempty"`
	ID            *StringFieldComparison                 `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison             `json:"meterType,omitempty"`
	Or            []*UsageMeasurementFilterFeatureFilter `json:"or,omitempty"`
	RefID         *StringFieldComparison                 `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison                   `json:"updatedAt,omitempty"`
}

type UsageMeasurementMaxAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type UsageMeasurementMinAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type UsageMeasurementPoint struct {
	Date         string  `json:"date"`
	IsResetPoint *bool   `json:"isResetPoint"`
	Value        float64 `json:"value"`
}

type UsageMeasurementSort struct {
	Direction SortDirection              `json:"direction"`
	Field     UsageMeasurementSortFields `json:"field"`
	Nulls     *SortNulls                 `json:"nulls,omitempty"`
}

type UsageMeasurementSumAggregate struct {
	ID *float64 `json:"id"`
}

type UsageMeasurementUpdated struct {
	AccountID     string   `json:"accountId"`
	CurrentUsage  float64  `json:"currentUsage"`
	CustomerID    string   `json:"customerId"`
	EnvironmentID string   `json:"environmentId"`
	FeatureID     string   `json:"featureId"`
	NextResetDate *float64 `json:"nextResetDate"`
	ResourceID    *string  `json:"resourceId"`
}

type UsageMeasurementWithCurrentUsage struct {
	CreatedAt     string   `json:"createdAt"`
	CurrentUsage  *float64 `json:"currentUsage"`
	CustomerID    string   `json:"customerId"`
	EnvironmentID string   `json:"environmentId"`
	FeatureID     string   `json:"featureId"`
	ID            string   `json:"id"`
	NextResetDate *string  `json:"nextResetDate"`
	ResourceID    *string  `json:"resourceId"`
	Timestamp     string   `json:"timestamp"`
	Value         float64  `json:"value"`
}

type UsageUpdated struct {
	Entitlement Entitlement             `json:"entitlement"`
	Usage       UsageMeasurementUpdated `json:"usage"`
}

type User struct {
	Department      *Department `json:"department"`
	Email           *string     `json:"email"`
	ID              string      `json:"id"`
	LastSeenAt      *string     `json:"lastSeenAt"`
	Memberships     []*Member   `json:"memberships"`
	Name            *string     `json:"name"`
	ProfileImageURL *string     `json:"profileImageUrl"`
}

type ValidateMergeEnvironment struct {
	Errors  []string `json:"errors"`
	IsValid bool     `json:"isValid"`
}

// Input type for validateMergeEnvironment query.
type ValidateMergeEnvironmentInput struct {
	// The slug of the environment to copy to.
	DestinationEnvironmentSlug string `json:"destinationEnvironmentSlug"`
	// The slug of the environment to copy from.
	SourceEnvironmentSlug string `json:"sourceEnvironmentSlug"`
}

type VendorIdentifierFilterComparison struct {
	Eq       *VendorIdentifier  `json:"eq,omitempty"`
	Gt       *VendorIdentifier  `json:"gt,omitempty"`
	Gte      *VendorIdentifier  `json:"gte,omitempty"`
	ILike    *VendorIdentifier  `json:"iLike,omitempty"`
	In       []VendorIdentifier `json:"in,omitempty"`
	Is       *bool              `json:"is,omitempty"`
	IsNot    *bool              `json:"isNot,omitempty"`
	Like     *VendorIdentifier  `json:"like,omitempty"`
	Lt       *VendorIdentifier  `json:"lt,omitempty"`
	Lte      *VendorIdentifier  `json:"lte,omitempty"`
	Neq      *VendorIdentifier  `json:"neq,omitempty"`
	NotILike *VendorIdentifier  `json:"notILike,omitempty"`
	NotIn    []VendorIdentifier `json:"notIn,omitempty"`
	NotLike  *VendorIdentifier  `json:"notLike,omitempty"`
}

type WeeklyResetPeriodConfig struct {
	WeeklyAccordingTo *WeeklyAccordingTo `json:"weeklyAccordingTo"`
}

func (WeeklyResetPeriodConfig) IsResetPeriodConfiguration() {}

type WeeklyResetPeriodConfigInput struct {
	AccordingTo WeeklyAccordingTo `json:"accordingTo"`
}

type WidgetConfiguration struct {
	Checkout       *CheckoutConfiguration       `json:"checkout"`
	CustomerPortal *CustomerPortalConfiguration `json:"customerPortal"`
	Paywall        *PaywallConfiguration        `json:"paywall"`
}

type WidgetConfigurationUpdateInput struct {
	CheckoutConfiguration       *CheckoutConfigurationInput       `json:"checkoutConfiguration,omitempty"`
	CustomerPortalConfiguration *CustomerPortalConfigurationInput `json:"customerPortalConfiguration,omitempty"`
	EnvironmentID               *string                           `json:"environmentId,omitempty"`
	PaywallConfiguration        *PaywallConfigurationInput        `json:"paywallConfiguration,omitempty"`
}

type YearlyResetPeriodConfig struct {
	YearlyAccordingTo *YearlyAccordingTo `json:"yearlyAccordingTo"`
}

func (YearlyResetPeriodConfig) IsResetPeriodConfiguration() {}

type YearlyResetPeriodConfigInput struct {
	AccordingTo YearlyAccordingTo `json:"accordingTo"`
}

type ZuoraCredentials struct {
	BaseURL      string `json:"baseUrl"`
	ClientID     string `json:"clientId"`
	ClientSecret string `json:"clientSecret"`
}

func (ZuoraCredentials) IsCredentials() {}

type ZuoraCredentialsInput struct {
	BaseURL      string `json:"baseUrl"`
	ClientID     string `json:"clientId"`
	ClientSecret string `json:"clientSecret"`
}

type ExperimentInfo struct {
	GroupName string              `json:"groupName"`
	GroupType ExperimentGroupType `json:"groupType"`
	ID        string              `json:"id"`
	Name      string              `json:"name"`
	Status    ExperimentStatus    `json:"status"`
}

// DenyReason of get access policy
type AccessDeniedReason string

const (
	AccessDeniedReasonCustomerIsArchived                 AccessDeniedReason = "CustomerIsArchived"
	AccessDeniedReasonCustomerNotFound                   AccessDeniedReason = "CustomerNotFound"
	AccessDeniedReasonCustomerResourceNotFound           AccessDeniedReason = "CustomerResourceNotFound"
	AccessDeniedReasonFeatureNotFound                    AccessDeniedReason = "FeatureNotFound"
	AccessDeniedReasonNoActiveSubscription               AccessDeniedReason = "NoActiveSubscription"
	AccessDeniedReasonNoFeatureEntitlementInSubscription AccessDeniedReason = "NoFeatureEntitlementInSubscription"
	AccessDeniedReasonRequestedUsageExceedingLimit       AccessDeniedReason = "RequestedUsageExceedingLimit"
	AccessDeniedReasonUnknown                            AccessDeniedReason = "Unknown"
)

var AllAccessDeniedReason = []AccessDeniedReason{
	AccessDeniedReasonCustomerIsArchived,
	AccessDeniedReasonCustomerNotFound,
	AccessDeniedReasonCustomerResourceNotFound,
	AccessDeniedReasonFeatureNotFound,
	AccessDeniedReasonNoActiveSubscription,
	AccessDeniedReasonNoFeatureEntitlementInSubscription,
	AccessDeniedReasonRequestedUsageExceedingLimit,
	AccessDeniedReasonUnknown,
}

func (e AccessDeniedReason) IsValid() bool {
	switch e {
	case AccessDeniedReasonCustomerIsArchived, AccessDeniedReasonCustomerNotFound, AccessDeniedReasonCustomerResourceNotFound, AccessDeniedReasonFeatureNotFound, AccessDeniedReasonNoActiveSubscription, AccessDeniedReasonNoFeatureEntitlementInSubscription, AccessDeniedReasonRequestedUsageExceedingLimit, AccessDeniedReasonUnknown:
		return true
	}
	return false
}

func (e AccessDeniedReason) String() string {
	return string(e)
}

func (e *AccessDeniedReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessDeniedReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessDeniedReason", str)
	}
	return nil
}

func (e AccessDeniedReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccountStatus string

const (
	AccountStatusActive  AccountStatus = "ACTIVE"
	AccountStatusBlocked AccountStatus = "BLOCKED"
)

var AllAccountStatus = []AccountStatus{
	AccountStatusActive,
	AccountStatusBlocked,
}

func (e AccountStatus) IsValid() bool {
	switch e {
	case AccountStatusActive, AccountStatusBlocked:
		return true
	}
	return false
}

func (e AccountStatus) String() string {
	return string(e)
}

func (e *AccountStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountStatus", str)
	}
	return nil
}

func (e AccountStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AddonSortFields string

const (
	AddonSortFieldsBillingID     AddonSortFields = "billingId"
	AddonSortFieldsCreatedAt     AddonSortFields = "createdAt"
	AddonSortFieldsDescription   AddonSortFields = "description"
	AddonSortFieldsDisplayName   AddonSortFields = "displayName"
	AddonSortFieldsEnvironmentID AddonSortFields = "environmentId"
	AddonSortFieldsID            AddonSortFields = "id"
	AddonSortFieldsIsLatest      AddonSortFields = "isLatest"
	AddonSortFieldsPricingType   AddonSortFields = "pricingType"
	AddonSortFieldsProductID     AddonSortFields = "productId"
	AddonSortFieldsRefID         AddonSortFields = "refId"
	AddonSortFieldsStatus        AddonSortFields = "status"
	AddonSortFieldsUpdatedAt     AddonSortFields = "updatedAt"
	AddonSortFieldsVersionNumber AddonSortFields = "versionNumber"
)

var AllAddonSortFields = []AddonSortFields{
	AddonSortFieldsBillingID,
	AddonSortFieldsCreatedAt,
	AddonSortFieldsDescription,
	AddonSortFieldsDisplayName,
	AddonSortFieldsEnvironmentID,
	AddonSortFieldsID,
	AddonSortFieldsIsLatest,
	AddonSortFieldsPricingType,
	AddonSortFieldsProductID,
	AddonSortFieldsRefID,
	AddonSortFieldsStatus,
	AddonSortFieldsUpdatedAt,
	AddonSortFieldsVersionNumber,
}

func (e AddonSortFields) IsValid() bool {
	switch e {
	case AddonSortFieldsBillingID, AddonSortFieldsCreatedAt, AddonSortFieldsDescription, AddonSortFieldsDisplayName, AddonSortFieldsEnvironmentID, AddonSortFieldsID, AddonSortFieldsIsLatest, AddonSortFieldsPricingType, AddonSortFieldsProductID, AddonSortFieldsRefID, AddonSortFieldsStatus, AddonSortFieldsUpdatedAt, AddonSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e AddonSortFields) String() string {
	return string(e)
}

func (e *AddonSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddonSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddonSortFields", str)
	}
	return nil
}

func (e AddonSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Aggregation function
type AggregationFunction string

const (
	AggregationFunctionAvg    AggregationFunction = "AVG"
	AggregationFunctionCount  AggregationFunction = "COUNT"
	AggregationFunctionMax    AggregationFunction = "MAX"
	AggregationFunctionMin    AggregationFunction = "MIN"
	AggregationFunctionSum    AggregationFunction = "SUM"
	AggregationFunctionUnique AggregationFunction = "UNIQUE"
)

var AllAggregationFunction = []AggregationFunction{
	AggregationFunctionAvg,
	AggregationFunctionCount,
	AggregationFunctionMax,
	AggregationFunctionMin,
	AggregationFunctionSum,
	AggregationFunctionUnique,
}

func (e AggregationFunction) IsValid() bool {
	switch e {
	case AggregationFunctionAvg, AggregationFunctionCount, AggregationFunctionMax, AggregationFunctionMin, AggregationFunctionSum, AggregationFunctionUnique:
		return true
	}
	return false
}

func (e AggregationFunction) String() string {
	return string(e)
}

func (e *AggregationFunction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregationFunction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregationFunction", str)
	}
	return nil
}

func (e AggregationFunction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Alignment
type Alignment string

const (
	AlignmentCenter Alignment = "CENTER"
	AlignmentLeft   Alignment = "LEFT"
	AlignmentRight  Alignment = "RIGHT"
)

var AllAlignment = []Alignment{
	AlignmentCenter,
	AlignmentLeft,
	AlignmentRight,
}

func (e Alignment) IsValid() bool {
	switch e {
	case AlignmentCenter, AlignmentLeft, AlignmentRight:
		return true
	}
	return false
}

func (e Alignment) String() string {
	return string(e)
}

func (e *Alignment) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Alignment(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Alignment", str)
	}
	return nil
}

func (e Alignment) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type APIKeySortFields string

const (
	APIKeySortFieldsID APIKeySortFields = "id"
)

var AllAPIKeySortFields = []APIKeySortFields{
	APIKeySortFieldsID,
}

func (e APIKeySortFields) IsValid() bool {
	switch e {
	case APIKeySortFieldsID:
		return true
	}
	return false
}

func (e APIKeySortFields) String() string {
	return string(e)
}

func (e *APIKeySortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APIKeySortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApiKeySortFields", str)
	}
	return nil
}

func (e APIKeySortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type APIKeyType string

const (
	APIKeyTypeClient APIKeyType = "CLIENT"
	APIKeyTypeServer APIKeyType = "SERVER"
)

var AllAPIKeyType = []APIKeyType{
	APIKeyTypeClient,
	APIKeyTypeServer,
}

func (e APIKeyType) IsValid() bool {
	switch e {
	case APIKeyTypeClient, APIKeyTypeServer:
		return true
	}
	return false
}

func (e APIKeyType) String() string {
	return string(e)
}

func (e *APIKeyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APIKeyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApiKeyType", str)
	}
	return nil
}

func (e APIKeyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BillingAnchor string

const (
	BillingAnchorStartOfTheMonth   BillingAnchor = "START_OF_THE_MONTH"
	BillingAnchorSubscriptionStart BillingAnchor = "SUBSCRIPTION_START"
)

var AllBillingAnchor = []BillingAnchor{
	BillingAnchorStartOfTheMonth,
	BillingAnchorSubscriptionStart,
}

func (e BillingAnchor) IsValid() bool {
	switch e {
	case BillingAnchorStartOfTheMonth, BillingAnchorSubscriptionStart:
		return true
	}
	return false
}

func (e BillingAnchor) String() string {
	return string(e)
}

func (e *BillingAnchor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingAnchor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingAnchor", str)
	}
	return nil
}

func (e BillingAnchor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing model.
type BillingModel string

const (
	BillingModelFlatFee    BillingModel = "FLAT_FEE"
	BillingModelPerUnit    BillingModel = "PER_UNIT"
	BillingModelUsageBased BillingModel = "USAGE_BASED"
)

var AllBillingModel = []BillingModel{
	BillingModelFlatFee,
	BillingModelPerUnit,
	BillingModelUsageBased,
}

func (e BillingModel) IsValid() bool {
	switch e {
	case BillingModelFlatFee, BillingModelPerUnit, BillingModelUsageBased:
		return true
	}
	return false
}

func (e BillingModel) String() string {
	return string(e)
}

func (e *BillingModel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingModel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingModel", str)
	}
	return nil
}

func (e BillingModel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing period.
type BillingPeriod string

const (
	BillingPeriodAnnually BillingPeriod = "ANNUALLY"
	BillingPeriodMonthly  BillingPeriod = "MONTHLY"
)

var AllBillingPeriod = []BillingPeriod{
	BillingPeriodAnnually,
	BillingPeriodMonthly,
}

func (e BillingPeriod) IsValid() bool {
	switch e {
	case BillingPeriodAnnually, BillingPeriodMonthly:
		return true
	}
	return false
}

func (e BillingPeriod) String() string {
	return string(e)
}

func (e *BillingPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingPeriod", str)
	}
	return nil
}

func (e BillingPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing vendor identifiers
type BillingVendorIdentifier string

const (
	BillingVendorIdentifierStripe BillingVendorIdentifier = "STRIPE"
)

var AllBillingVendorIdentifier = []BillingVendorIdentifier{
	BillingVendorIdentifierStripe,
}

func (e BillingVendorIdentifier) IsValid() bool {
	switch e {
	case BillingVendorIdentifierStripe:
		return true
	}
	return false
}

func (e BillingVendorIdentifier) String() string {
	return string(e)
}

func (e *BillingVendorIdentifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingVendorIdentifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingVendorIdentifier", str)
	}
	return nil
}

func (e BillingVendorIdentifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChangeType string

const (
	ChangeTypeAdded     ChangeType = "ADDED"
	ChangeTypeDeleted   ChangeType = "DELETED"
	ChangeTypeModified  ChangeType = "MODIFIED"
	ChangeTypeReordered ChangeType = "REORDERED"
)

var AllChangeType = []ChangeType{
	ChangeTypeAdded,
	ChangeTypeDeleted,
	ChangeTypeModified,
	ChangeTypeReordered,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeAdded, ChangeTypeDeleted, ChangeTypeModified, ChangeTypeReordered:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Condition operation
type ConditionOperation string

const (
	ConditionOperationEquals             ConditionOperation = "EQUALS"
	ConditionOperationGreaterThan        ConditionOperation = "GREATER_THAN"
	ConditionOperationGreaterThanOrEqual ConditionOperation = "GREATER_THAN_OR_EQUAL"
	ConditionOperationIsNotNull          ConditionOperation = "IS_NOT_NULL"
	ConditionOperationIsNull             ConditionOperation = "IS_NULL"
	ConditionOperationLessThan           ConditionOperation = "LESS_THAN"
	ConditionOperationLessThanOrEqual    ConditionOperation = "LESS_THAN_OR_EQUAL"
	ConditionOperationNotEquals          ConditionOperation = "NOT_EQUALS"
)

var AllConditionOperation = []ConditionOperation{
	ConditionOperationEquals,
	ConditionOperationGreaterThan,
	ConditionOperationGreaterThanOrEqual,
	ConditionOperationIsNotNull,
	ConditionOperationIsNull,
	ConditionOperationLessThan,
	ConditionOperationLessThanOrEqual,
	ConditionOperationNotEquals,
}

func (e ConditionOperation) IsValid() bool {
	switch e {
	case ConditionOperationEquals, ConditionOperationGreaterThan, ConditionOperationGreaterThanOrEqual, ConditionOperationIsNotNull, ConditionOperationIsNull, ConditionOperationLessThan, ConditionOperationLessThanOrEqual, ConditionOperationNotEquals:
		return true
	}
	return false
}

func (e ConditionOperation) String() string {
	return string(e)
}

func (e *ConditionOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperation", str)
	}
	return nil
}

func (e ConditionOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CouponSortFields string

const (
	CouponSortFieldsBillingID     CouponSortFields = "billingId"
	CouponSortFieldsCreatedAt     CouponSortFields = "createdAt"
	CouponSortFieldsDescription   CouponSortFields = "description"
	CouponSortFieldsEnvironmentID CouponSortFields = "environmentId"
	CouponSortFieldsID            CouponSortFields = "id"
	CouponSortFieldsName          CouponSortFields = "name"
	CouponSortFieldsRefID         CouponSortFields = "refId"
	CouponSortFieldsStatus        CouponSortFields = "status"
	CouponSortFieldsType          CouponSortFields = "type"
	CouponSortFieldsUpdatedAt     CouponSortFields = "updatedAt"
)

var AllCouponSortFields = []CouponSortFields{
	CouponSortFieldsBillingID,
	CouponSortFieldsCreatedAt,
	CouponSortFieldsDescription,
	CouponSortFieldsEnvironmentID,
	CouponSortFieldsID,
	CouponSortFieldsName,
	CouponSortFieldsRefID,
	CouponSortFieldsStatus,
	CouponSortFieldsType,
	CouponSortFieldsUpdatedAt,
}

func (e CouponSortFields) IsValid() bool {
	switch e {
	case CouponSortFieldsBillingID, CouponSortFieldsCreatedAt, CouponSortFieldsDescription, CouponSortFieldsEnvironmentID, CouponSortFieldsID, CouponSortFieldsName, CouponSortFieldsRefID, CouponSortFieldsStatus, CouponSortFieldsType, CouponSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e CouponSortFields) String() string {
	return string(e)
}

func (e *CouponSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponSortFields", str)
	}
	return nil
}

func (e CouponSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the coupon
type CouponStatus string

const (
	CouponStatusActive   CouponStatus = "ACTIVE"
	CouponStatusArchived CouponStatus = "ARCHIVED"
)

var AllCouponStatus = []CouponStatus{
	CouponStatusActive,
	CouponStatusArchived,
}

func (e CouponStatus) IsValid() bool {
	switch e {
	case CouponStatusActive, CouponStatusArchived:
		return true
	}
	return false
}

func (e CouponStatus) String() string {
	return string(e)
}

func (e *CouponStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponStatus", str)
	}
	return nil
}

func (e CouponStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the coupon
type CouponType string

const (
	CouponTypeFixed      CouponType = "FIXED"
	CouponTypePercentage CouponType = "PERCENTAGE"
)

var AllCouponType = []CouponType{
	CouponTypeFixed,
	CouponTypePercentage,
}

func (e CouponType) IsValid() bool {
	switch e {
	case CouponTypeFixed, CouponTypePercentage:
		return true
	}
	return false
}

func (e CouponType) String() string {
	return string(e)
}

func (e *CouponType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponType", str)
	}
	return nil
}

func (e CouponType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Currency
type Currency string

const (
	CurrencyAed Currency = "AED"
	CurrencyAll Currency = "ALL"
	CurrencyAmd Currency = "AMD"
	CurrencyAng Currency = "ANG"
	CurrencyAud Currency = "AUD"
	CurrencyAwg Currency = "AWG"
	CurrencyAzn Currency = "AZN"
	CurrencyBam Currency = "BAM"
	CurrencyBbd Currency = "BBD"
	CurrencyBdt Currency = "BDT"
	CurrencyBgn Currency = "BGN"
	CurrencyBif Currency = "BIF"
	CurrencyBmd Currency = "BMD"
	CurrencyBnd Currency = "BND"
	CurrencyBsd Currency = "BSD"
	CurrencyBwp Currency = "BWP"
	CurrencyByn Currency = "BYN"
	CurrencyBzd Currency = "BZD"
	CurrencyCad Currency = "CAD"
	CurrencyCdf Currency = "CDF"
	CurrencyChf Currency = "CHF"
	CurrencyClp Currency = "CLP"
	CurrencyCny Currency = "CNY"
	CurrencyCzk Currency = "CZK"
	CurrencyDjf Currency = "DJF"
	CurrencyDkk Currency = "DKK"
	CurrencyDop Currency = "DOP"
	CurrencyDzd Currency = "DZD"
	CurrencyEgp Currency = "EGP"
	CurrencyEtb Currency = "ETB"
	CurrencyEur Currency = "EUR"
	CurrencyFjd Currency = "FJD"
	CurrencyGbp Currency = "GBP"
	CurrencyGel Currency = "GEL"
	CurrencyGip Currency = "GIP"
	CurrencyGmd Currency = "GMD"
	CurrencyGnf Currency = "GNF"
	CurrencyGyd Currency = "GYD"
	CurrencyHkd Currency = "HKD"
	CurrencyHrk Currency = "HRK"
	CurrencyHtg Currency = "HTG"
	CurrencyIDR Currency = "IDR"
	CurrencyIls Currency = "ILS"
	CurrencyInr Currency = "INR"
	CurrencyIsk Currency = "ISK"
	CurrencyJmd Currency = "JMD"
	CurrencyJpy Currency = "JPY"
	CurrencyKes Currency = "KES"
	CurrencyKgs Currency = "KGS"
	CurrencyKhr Currency = "KHR"
	CurrencyKmf Currency = "KMF"
	CurrencyKrw Currency = "KRW"
	CurrencyKyd Currency = "KYD"
	CurrencyKzt Currency = "KZT"
	CurrencyLbp Currency = "LBP"
	CurrencyLkr Currency = "LKR"
	CurrencyLrd Currency = "LRD"
	CurrencyLsl Currency = "LSL"
	CurrencyMad Currency = "MAD"
	CurrencyMdl Currency = "MDL"
	CurrencyMga Currency = "MGA"
	CurrencyMkd Currency = "MKD"
	CurrencyMmk Currency = "MMK"
	CurrencyMnt Currency = "MNT"
	CurrencyMop Currency = "MOP"
	CurrencyMro Currency = "MRO"
	CurrencyMvr Currency = "MVR"
	CurrencyMwk Currency = "MWK"
	CurrencyMxn Currency = "MXN"
	CurrencyMyr Currency = "MYR"
	CurrencyMzn Currency = "MZN"
	CurrencyNad Currency = "NAD"
	CurrencyNgn Currency = "NGN"
	CurrencyNok Currency = "NOK"
	CurrencyNpr Currency = "NPR"
	CurrencyNzd Currency = "NZD"
	CurrencyPgk Currency = "PGK"
	CurrencyPhp Currency = "PHP"
	CurrencyPkr Currency = "PKR"
	CurrencyPln Currency = "PLN"
	CurrencyPyg Currency = "PYG"
	CurrencyQar Currency = "QAR"
	CurrencyRon Currency = "RON"
	CurrencyRsd Currency = "RSD"
	CurrencyRub Currency = "RUB"
	CurrencyRwf Currency = "RWF"
	CurrencySar Currency = "SAR"
	CurrencySbd Currency = "SBD"
	CurrencyScr Currency = "SCR"
	CurrencySek Currency = "SEK"
	CurrencySgd Currency = "SGD"
	CurrencySle Currency = "SLE"
	CurrencySll Currency = "SLL"
	CurrencySos Currency = "SOS"
	CurrencySzl Currency = "SZL"
	CurrencyThb Currency = "THB"
	CurrencyTjs Currency = "TJS"
	CurrencyTop Currency = "TOP"
	CurrencyTry Currency = "TRY"
	CurrencyTtd Currency = "TTD"
	CurrencyTzs Currency = "TZS"
	CurrencyUah Currency = "UAH"
	CurrencyUgx Currency = "UGX"
	CurrencyUsd Currency = "USD"
	CurrencyUzs Currency = "UZS"
	CurrencyVnd Currency = "VND"
	CurrencyVuv Currency = "VUV"
	CurrencyWst Currency = "WST"
	CurrencyXaf Currency = "XAF"
	CurrencyXcd Currency = "XCD"
	CurrencyXof Currency = "XOF"
	CurrencyXpf Currency = "XPF"
	CurrencyYer Currency = "YER"
	CurrencyZar Currency = "ZAR"
	CurrencyZmw Currency = "ZMW"
)

var AllCurrency = []Currency{
	CurrencyAed,
	CurrencyAll,
	CurrencyAmd,
	CurrencyAng,
	CurrencyAud,
	CurrencyAwg,
	CurrencyAzn,
	CurrencyBam,
	CurrencyBbd,
	CurrencyBdt,
	CurrencyBgn,
	CurrencyBif,
	CurrencyBmd,
	CurrencyBnd,
	CurrencyBsd,
	CurrencyBwp,
	CurrencyByn,
	CurrencyBzd,
	CurrencyCad,
	CurrencyCdf,
	CurrencyChf,
	CurrencyClp,
	CurrencyCny,
	CurrencyCzk,
	CurrencyDjf,
	CurrencyDkk,
	CurrencyDop,
	CurrencyDzd,
	CurrencyEgp,
	CurrencyEtb,
	CurrencyEur,
	CurrencyFjd,
	CurrencyGbp,
	CurrencyGel,
	CurrencyGip,
	CurrencyGmd,
	CurrencyGnf,
	CurrencyGyd,
	CurrencyHkd,
	CurrencyHrk,
	CurrencyHtg,
	CurrencyIDR,
	CurrencyIls,
	CurrencyInr,
	CurrencyIsk,
	CurrencyJmd,
	CurrencyJpy,
	CurrencyKes,
	CurrencyKgs,
	CurrencyKhr,
	CurrencyKmf,
	CurrencyKrw,
	CurrencyKyd,
	CurrencyKzt,
	CurrencyLbp,
	CurrencyLkr,
	CurrencyLrd,
	CurrencyLsl,
	CurrencyMad,
	CurrencyMdl,
	CurrencyMga,
	CurrencyMkd,
	CurrencyMmk,
	CurrencyMnt,
	CurrencyMop,
	CurrencyMro,
	CurrencyMvr,
	CurrencyMwk,
	CurrencyMxn,
	CurrencyMyr,
	CurrencyMzn,
	CurrencyNad,
	CurrencyNgn,
	CurrencyNok,
	CurrencyNpr,
	CurrencyNzd,
	CurrencyPgk,
	CurrencyPhp,
	CurrencyPkr,
	CurrencyPln,
	CurrencyPyg,
	CurrencyQar,
	CurrencyRon,
	CurrencyRsd,
	CurrencyRub,
	CurrencyRwf,
	CurrencySar,
	CurrencySbd,
	CurrencyScr,
	CurrencySek,
	CurrencySgd,
	CurrencySle,
	CurrencySll,
	CurrencySos,
	CurrencySzl,
	CurrencyThb,
	CurrencyTjs,
	CurrencyTop,
	CurrencyTry,
	CurrencyTtd,
	CurrencyTzs,
	CurrencyUah,
	CurrencyUgx,
	CurrencyUsd,
	CurrencyUzs,
	CurrencyVnd,
	CurrencyVuv,
	CurrencyWst,
	CurrencyXaf,
	CurrencyXcd,
	CurrencyXof,
	CurrencyXpf,
	CurrencyYer,
	CurrencyZar,
	CurrencyZmw,
}

func (e Currency) IsValid() bool {
	switch e {
	case CurrencyAed, CurrencyAll, CurrencyAmd, CurrencyAng, CurrencyAud, CurrencyAwg, CurrencyAzn, CurrencyBam, CurrencyBbd, CurrencyBdt, CurrencyBgn, CurrencyBif, CurrencyBmd, CurrencyBnd, CurrencyBsd, CurrencyBwp, CurrencyByn, CurrencyBzd, CurrencyCad, CurrencyCdf, CurrencyChf, CurrencyClp, CurrencyCny, CurrencyCzk, CurrencyDjf, CurrencyDkk, CurrencyDop, CurrencyDzd, CurrencyEgp, CurrencyEtb, CurrencyEur, CurrencyFjd, CurrencyGbp, CurrencyGel, CurrencyGip, CurrencyGmd, CurrencyGnf, CurrencyGyd, CurrencyHkd, CurrencyHrk, CurrencyHtg, CurrencyIDR, CurrencyIls, CurrencyInr, CurrencyIsk, CurrencyJmd, CurrencyJpy, CurrencyKes, CurrencyKgs, CurrencyKhr, CurrencyKmf, CurrencyKrw, CurrencyKyd, CurrencyKzt, CurrencyLbp, CurrencyLkr, CurrencyLrd, CurrencyLsl, CurrencyMad, CurrencyMdl, CurrencyMga, CurrencyMkd, CurrencyMmk, CurrencyMnt, CurrencyMop, CurrencyMro, CurrencyMvr, CurrencyMwk, CurrencyMxn, CurrencyMyr, CurrencyMzn, CurrencyNad, CurrencyNgn, CurrencyNok, CurrencyNpr, CurrencyNzd, CurrencyPgk, CurrencyPhp, CurrencyPkr, CurrencyPln, CurrencyPyg, CurrencyQar, CurrencyRon, CurrencyRsd, CurrencyRub, CurrencyRwf, CurrencySar, CurrencySbd, CurrencyScr, CurrencySek, CurrencySgd, CurrencySle, CurrencySll, CurrencySos, CurrencySzl, CurrencyThb, CurrencyTjs, CurrencyTop, CurrencyTry, CurrencyTtd, CurrencyTzs, CurrencyUah, CurrencyUgx, CurrencyUsd, CurrencyUzs, CurrencyVnd, CurrencyVuv, CurrencyWst, CurrencyXaf, CurrencyXcd, CurrencyXof, CurrencyXpf, CurrencyYer, CurrencyZar, CurrencyZmw:
		return true
	}
	return false
}

func (e Currency) String() string {
	return string(e)
}

func (e *Currency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Currency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Currency", str)
	}
	return nil
}

func (e Currency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerResourceSortFields string

const (
	CustomerResourceSortFieldsCreatedAt     CustomerResourceSortFields = "createdAt"
	CustomerResourceSortFieldsEnvironmentID CustomerResourceSortFields = "environmentId"
	CustomerResourceSortFieldsResourceID    CustomerResourceSortFields = "resourceId"
)

var AllCustomerResourceSortFields = []CustomerResourceSortFields{
	CustomerResourceSortFieldsCreatedAt,
	CustomerResourceSortFieldsEnvironmentID,
	CustomerResourceSortFieldsResourceID,
}

func (e CustomerResourceSortFields) IsValid() bool {
	switch e {
	case CustomerResourceSortFieldsCreatedAt, CustomerResourceSortFieldsEnvironmentID, CustomerResourceSortFieldsResourceID:
		return true
	}
	return false
}

func (e CustomerResourceSortFields) String() string {
	return string(e)
}

func (e *CustomerResourceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerResourceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerResourceSortFields", str)
	}
	return nil
}

func (e CustomerResourceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerSortFields string

const (
	CustomerSortFieldsBillingID            CustomerSortFields = "billingId"
	CustomerSortFieldsCreatedAt            CustomerSortFields = "createdAt"
	CustomerSortFieldsCrmHubspotCompanyID  CustomerSortFields = "crmHubspotCompanyId"
	CustomerSortFieldsCrmHubspotCompanyURL CustomerSortFields = "crmHubspotCompanyUrl"
	CustomerSortFieldsCrmID                CustomerSortFields = "crmId"
	CustomerSortFieldsCustomerID           CustomerSortFields = "customerId"
	CustomerSortFieldsDeletedAt            CustomerSortFields = "deletedAt"
	CustomerSortFieldsEmail                CustomerSortFields = "email"
	CustomerSortFieldsEnvironmentID        CustomerSortFields = "environmentId"
	CustomerSortFieldsID                   CustomerSortFields = "id"
	CustomerSortFieldsName                 CustomerSortFields = "name"
	CustomerSortFieldsRefID                CustomerSortFields = "refId"
	CustomerSortFieldsSearchQuery          CustomerSortFields = "searchQuery"
	CustomerSortFieldsUpdatedAt            CustomerSortFields = "updatedAt"
)

var AllCustomerSortFields = []CustomerSortFields{
	CustomerSortFieldsBillingID,
	CustomerSortFieldsCreatedAt,
	CustomerSortFieldsCrmHubspotCompanyID,
	CustomerSortFieldsCrmHubspotCompanyURL,
	CustomerSortFieldsCrmID,
	CustomerSortFieldsCustomerID,
	CustomerSortFieldsDeletedAt,
	CustomerSortFieldsEmail,
	CustomerSortFieldsEnvironmentID,
	CustomerSortFieldsID,
	CustomerSortFieldsName,
	CustomerSortFieldsRefID,
	CustomerSortFieldsSearchQuery,
	CustomerSortFieldsUpdatedAt,
}

func (e CustomerSortFields) IsValid() bool {
	switch e {
	case CustomerSortFieldsBillingID, CustomerSortFieldsCreatedAt, CustomerSortFieldsCrmHubspotCompanyID, CustomerSortFieldsCrmHubspotCompanyURL, CustomerSortFieldsCrmID, CustomerSortFieldsCustomerID, CustomerSortFieldsDeletedAt, CustomerSortFieldsEmail, CustomerSortFieldsEnvironmentID, CustomerSortFieldsID, CustomerSortFieldsName, CustomerSortFieldsRefID, CustomerSortFieldsSearchQuery, CustomerSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e CustomerSortFields) String() string {
	return string(e)
}

func (e *CustomerSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSortFields", str)
	}
	return nil
}

func (e CustomerSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerSubscriptionSortFields string

const (
	CustomerSubscriptionSortFieldsBillingID                 CustomerSubscriptionSortFields = "billingId"
	CustomerSubscriptionSortFieldsCancelReason              CustomerSubscriptionSortFields = "cancelReason"
	CustomerSubscriptionSortFieldsCancellationDate          CustomerSubscriptionSortFields = "cancellationDate"
	CustomerSubscriptionSortFieldsCreatedAt                 CustomerSubscriptionSortFields = "createdAt"
	CustomerSubscriptionSortFieldsCrmID                     CustomerSubscriptionSortFields = "crmId"
	CustomerSubscriptionSortFieldsCrmLinkURL                CustomerSubscriptionSortFields = "crmLinkUrl"
	CustomerSubscriptionSortFieldsCurrentBillingPeriodEnd   CustomerSubscriptionSortFields = "currentBillingPeriodEnd"
	CustomerSubscriptionSortFieldsCurrentBillingPeriodStart CustomerSubscriptionSortFields = "currentBillingPeriodStart"
	CustomerSubscriptionSortFieldsEffectiveEndDate          CustomerSubscriptionSortFields = "effectiveEndDate"
	CustomerSubscriptionSortFieldsEndDate                   CustomerSubscriptionSortFields = "endDate"
	CustomerSubscriptionSortFieldsEnvironmentID             CustomerSubscriptionSortFields = "environmentId"
	CustomerSubscriptionSortFieldsID                        CustomerSubscriptionSortFields = "id"
	CustomerSubscriptionSortFieldsOldBillingID              CustomerSubscriptionSortFields = "oldBillingId"
	CustomerSubscriptionSortFieldsPaymentCollection         CustomerSubscriptionSortFields = "paymentCollection"
	CustomerSubscriptionSortFieldsPricingType               CustomerSubscriptionSortFields = "pricingType"
	CustomerSubscriptionSortFieldsRefID                     CustomerSubscriptionSortFields = "refId"
	CustomerSubscriptionSortFieldsResourceID                CustomerSubscriptionSortFields = "resourceId"
	CustomerSubscriptionSortFieldsStartDate                 CustomerSubscriptionSortFields = "startDate"
	CustomerSubscriptionSortFieldsStatus                    CustomerSubscriptionSortFields = "status"
	CustomerSubscriptionSortFieldsSubscriptionID            CustomerSubscriptionSortFields = "subscriptionId"
	CustomerSubscriptionSortFieldsTrialEndDate              CustomerSubscriptionSortFields = "trialEndDate"
)

var AllCustomerSubscriptionSortFields = []CustomerSubscriptionSortFields{
	CustomerSubscriptionSortFieldsBillingID,
	CustomerSubscriptionSortFieldsCancelReason,
	CustomerSubscriptionSortFieldsCancellationDate,
	CustomerSubscriptionSortFieldsCreatedAt,
	CustomerSubscriptionSortFieldsCrmID,
	CustomerSubscriptionSortFieldsCrmLinkURL,
	CustomerSubscriptionSortFieldsCurrentBillingPeriodEnd,
	CustomerSubscriptionSortFieldsCurrentBillingPeriodStart,
	CustomerSubscriptionSortFieldsEffectiveEndDate,
	CustomerSubscriptionSortFieldsEndDate,
	CustomerSubscriptionSortFieldsEnvironmentID,
	CustomerSubscriptionSortFieldsID,
	CustomerSubscriptionSortFieldsOldBillingID,
	CustomerSubscriptionSortFieldsPaymentCollection,
	CustomerSubscriptionSortFieldsPricingType,
	CustomerSubscriptionSortFieldsRefID,
	CustomerSubscriptionSortFieldsResourceID,
	CustomerSubscriptionSortFieldsStartDate,
	CustomerSubscriptionSortFieldsStatus,
	CustomerSubscriptionSortFieldsSubscriptionID,
	CustomerSubscriptionSortFieldsTrialEndDate,
}

func (e CustomerSubscriptionSortFields) IsValid() bool {
	switch e {
	case CustomerSubscriptionSortFieldsBillingID, CustomerSubscriptionSortFieldsCancelReason, CustomerSubscriptionSortFieldsCancellationDate, CustomerSubscriptionSortFieldsCreatedAt, CustomerSubscriptionSortFieldsCrmID, CustomerSubscriptionSortFieldsCrmLinkURL, CustomerSubscriptionSortFieldsCurrentBillingPeriodEnd, CustomerSubscriptionSortFieldsCurrentBillingPeriodStart, CustomerSubscriptionSortFieldsEffectiveEndDate, CustomerSubscriptionSortFieldsEndDate, CustomerSubscriptionSortFieldsEnvironmentID, CustomerSubscriptionSortFieldsID, CustomerSubscriptionSortFieldsOldBillingID, CustomerSubscriptionSortFieldsPaymentCollection, CustomerSubscriptionSortFieldsPricingType, CustomerSubscriptionSortFieldsRefID, CustomerSubscriptionSortFieldsResourceID, CustomerSubscriptionSortFieldsStartDate, CustomerSubscriptionSortFieldsStatus, CustomerSubscriptionSortFieldsSubscriptionID, CustomerSubscriptionSortFieldsTrialEndDate:
		return true
	}
	return false
}

func (e CustomerSubscriptionSortFields) String() string {
	return string(e)
}

func (e *CustomerSubscriptionSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSubscriptionSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSubscriptionSortFields", str)
	}
	return nil
}

func (e CustomerSubscriptionSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Department string

const (
	DepartmentCeoOrFounder Department = "CEO_OR_FOUNDER"
	DepartmentEngineering  Department = "ENGINEERING"
	DepartmentGrowth       Department = "GROWTH"
	DepartmentMarketing    Department = "MARKETING"
	DepartmentMonetization Department = "MONETIZATION"
	DepartmentOther        Department = "OTHER"
	DepartmentProduct      Department = "PRODUCT"
)

var AllDepartment = []Department{
	DepartmentCeoOrFounder,
	DepartmentEngineering,
	DepartmentGrowth,
	DepartmentMarketing,
	DepartmentMonetization,
	DepartmentOther,
	DepartmentProduct,
}

func (e Department) IsValid() bool {
	switch e {
	case DepartmentCeoOrFounder, DepartmentEngineering, DepartmentGrowth, DepartmentMarketing, DepartmentMonetization, DepartmentOther, DepartmentProduct:
		return true
	}
	return false
}

func (e Department) String() string {
	return string(e)
}

func (e *Department) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Department(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Department", str)
	}
	return nil
}

func (e Department) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the discount duration
type DiscountDurationType string

const (
	DiscountDurationTypeForever   DiscountDurationType = "FOREVER"
	DiscountDurationTypeOnce      DiscountDurationType = "ONCE"
	DiscountDurationTypeRepeating DiscountDurationType = "REPEATING"
)

var AllDiscountDurationType = []DiscountDurationType{
	DiscountDurationTypeForever,
	DiscountDurationTypeOnce,
	DiscountDurationTypeRepeating,
}

func (e DiscountDurationType) IsValid() bool {
	switch e {
	case DiscountDurationTypeForever, DiscountDurationTypeOnce, DiscountDurationTypeRepeating:
		return true
	}
	return false
}

func (e DiscountDurationType) String() string {
	return string(e)
}

func (e *DiscountDurationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountDurationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountDurationType", str)
	}
	return nil
}

func (e DiscountDurationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the discount
type DiscountType string

const (
	DiscountTypeFixed      DiscountType = "FIXED"
	DiscountTypePercentage DiscountType = "PERCENTAGE"
)

var AllDiscountType = []DiscountType{
	DiscountTypeFixed,
	DiscountTypePercentage,
}

func (e DiscountType) IsValid() bool {
	switch e {
	case DiscountTypeFixed, DiscountTypePercentage:
		return true
	}
	return false
}

func (e DiscountType) String() string {
	return string(e)
}

func (e *DiscountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountType", str)
	}
	return nil
}

func (e DiscountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Entitlement reset period.
type EntitlementResetPeriod string

const (
	EntitlementResetPeriodDay   EntitlementResetPeriod = "DAY"
	EntitlementResetPeriodHour  EntitlementResetPeriod = "HOUR"
	EntitlementResetPeriodMonth EntitlementResetPeriod = "MONTH"
	EntitlementResetPeriodWeek  EntitlementResetPeriod = "WEEK"
	EntitlementResetPeriodYear  EntitlementResetPeriod = "YEAR"
)

var AllEntitlementResetPeriod = []EntitlementResetPeriod{
	EntitlementResetPeriodDay,
	EntitlementResetPeriodHour,
	EntitlementResetPeriodMonth,
	EntitlementResetPeriodWeek,
	EntitlementResetPeriodYear,
}

func (e EntitlementResetPeriod) IsValid() bool {
	switch e {
	case EntitlementResetPeriodDay, EntitlementResetPeriodHour, EntitlementResetPeriodMonth, EntitlementResetPeriodWeek, EntitlementResetPeriodYear:
		return true
	}
	return false
}

func (e EntitlementResetPeriod) String() string {
	return string(e)
}

func (e *EntitlementResetPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitlementResetPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitlementResetPeriod", str)
	}
	return nil
}

func (e EntitlementResetPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntitySelectionMode string

const (
	EntitySelectionModeBlackList EntitySelectionMode = "BLACK_LIST"
	EntitySelectionModeWhiteList EntitySelectionMode = "WHITE_LIST"
)

var AllEntitySelectionMode = []EntitySelectionMode{
	EntitySelectionModeBlackList,
	EntitySelectionModeWhiteList,
}

func (e EntitySelectionMode) IsValid() bool {
	switch e {
	case EntitySelectionModeBlackList, EntitySelectionModeWhiteList:
		return true
	}
	return false
}

func (e EntitySelectionMode) String() string {
	return string(e)
}

func (e *EntitySelectionMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitySelectionMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitySelectionMode", str)
	}
	return nil
}

func (e EntitySelectionMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// EnvironmentProvisionStatus.
type EnvironmentProvisionStatus string

const (
	EnvironmentProvisionStatusDone           EnvironmentProvisionStatus = "DONE"
	EnvironmentProvisionStatusFailed         EnvironmentProvisionStatus = "FAILED"
	EnvironmentProvisionStatusInProgress     EnvironmentProvisionStatus = "IN_PROGRESS"
	EnvironmentProvisionStatusNotProvisioned EnvironmentProvisionStatus = "NOT_PROVISIONED"
)

var AllEnvironmentProvisionStatus = []EnvironmentProvisionStatus{
	EnvironmentProvisionStatusDone,
	EnvironmentProvisionStatusFailed,
	EnvironmentProvisionStatusInProgress,
	EnvironmentProvisionStatusNotProvisioned,
}

func (e EnvironmentProvisionStatus) IsValid() bool {
	switch e {
	case EnvironmentProvisionStatusDone, EnvironmentProvisionStatusFailed, EnvironmentProvisionStatusInProgress, EnvironmentProvisionStatusNotProvisioned:
		return true
	}
	return false
}

func (e EnvironmentProvisionStatus) String() string {
	return string(e)
}

func (e *EnvironmentProvisionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentProvisionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentProvisionStatus", str)
	}
	return nil
}

func (e EnvironmentProvisionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EnvironmentSortFields string

const (
	EnvironmentSortFieldsCreatedAt             EnvironmentSortFields = "createdAt"
	EnvironmentSortFieldsDisplayName           EnvironmentSortFields = "displayName"
	EnvironmentSortFieldsID                    EnvironmentSortFields = "id"
	EnvironmentSortFieldsPermanentDeletionDate EnvironmentSortFields = "permanentDeletionDate"
	EnvironmentSortFieldsSlug                  EnvironmentSortFields = "slug"
)

var AllEnvironmentSortFields = []EnvironmentSortFields{
	EnvironmentSortFieldsCreatedAt,
	EnvironmentSortFieldsDisplayName,
	EnvironmentSortFieldsID,
	EnvironmentSortFieldsPermanentDeletionDate,
	EnvironmentSortFieldsSlug,
}

func (e EnvironmentSortFields) IsValid() bool {
	switch e {
	case EnvironmentSortFieldsCreatedAt, EnvironmentSortFieldsDisplayName, EnvironmentSortFieldsID, EnvironmentSortFieldsPermanentDeletionDate, EnvironmentSortFieldsSlug:
		return true
	}
	return false
}

func (e EnvironmentSortFields) String() string {
	return string(e)
}

func (e *EnvironmentSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentSortFields", str)
	}
	return nil
}

func (e EnvironmentSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// EnvironmentType.
type EnvironmentType string

const (
	EnvironmentTypeDevelopment EnvironmentType = "DEVELOPMENT"
	EnvironmentTypeProduction  EnvironmentType = "PRODUCTION"
	EnvironmentTypeSandbox     EnvironmentType = "SANDBOX"
)

var AllEnvironmentType = []EnvironmentType{
	EnvironmentTypeDevelopment,
	EnvironmentTypeProduction,
	EnvironmentTypeSandbox,
}

func (e EnvironmentType) IsValid() bool {
	switch e {
	case EnvironmentTypeDevelopment, EnvironmentTypeProduction, EnvironmentTypeSandbox:
		return true
	}
	return false
}

func (e EnvironmentType) String() string {
	return string(e)
}

func (e *EnvironmentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentType", str)
	}
	return nil
}

func (e EnvironmentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// error codes
type ErrorCode string

const (
	ErrorCodeAccountNotFoundError                             ErrorCode = "AccountNotFoundError"
	ErrorCodeAddonHasToHavePriceError                         ErrorCode = "AddonHasToHavePriceError"
	ErrorCodeAddonNotFound                                    ErrorCode = "AddonNotFound"
	ErrorCodeAddonWithDraftCannotBeDeletedError               ErrorCode = "AddonWithDraftCannotBeDeletedError"
	ErrorCodeAmountTooLarge                                   ErrorCode = "AmountTooLarge"
	ErrorCodeArchivedCouponCantBeApplied                      ErrorCode = "ArchivedCouponCantBeApplied"
	ErrorCodeAuthCustomerMismatch                             ErrorCode = "AuthCustomerMismatch"
	ErrorCodeAwsMarketplaceIntegrationError                   ErrorCode = "AwsMarketplaceIntegrationError"
	ErrorCodeAwsMarketplaceIntegrationValidationError         ErrorCode = "AwsMarketplaceIntegrationValidationError"
	ErrorCodeBadUserInput                                     ErrorCode = "BadUserInput"
	ErrorCodeBillingPeriodMissingError                        ErrorCode = "BillingPeriodMissingError"
	ErrorCodeCannotArchiveFeatureError                        ErrorCode = "CannotArchiveFeatureError"
	ErrorCodeCannotDeleteCustomerError                        ErrorCode = "CannotDeleteCustomerError"
	ErrorCodeCannotDeleteFeatureError                         ErrorCode = "CannotDeleteFeatureError"
	ErrorCodeCannotDeleteProductError                         ErrorCode = "CannotDeleteProductError"
	ErrorCodeCannotEditPackageInNonDraftMode                  ErrorCode = "CannotEditPackageInNonDraftMode"
	ErrorCodeCannotRemovePaymentMethodFromCustomerError       ErrorCode = "CannotRemovePaymentMethodFromCustomerError"
	ErrorCodeCannotReportUsageForEntitlementWithMeterError    ErrorCode = "CannotReportUsageForEntitlementWithMeterError"
	ErrorCodeCannotUpsertToPackageThatHasDraft                ErrorCode = "CannotUpsertToPackageThatHasDraft"
	ErrorCodeCheckoutIsNotSupported                           ErrorCode = "CheckoutIsNotSupported"
	ErrorCodeCheckoutOptionsMissing                           ErrorCode = "CheckoutOptionsMissing"
	ErrorCodeCouponNotFound                                   ErrorCode = "CouponNotFound"
	ErrorCodeCustomerAlreadyHaveCustomerCoupon                ErrorCode = "CustomerAlreadyHaveCustomerCoupon"
	ErrorCodeCustomerAlreadyUsesCoupon                        ErrorCode = "CustomerAlreadyUsesCoupon"
	ErrorCodeCustomerHasNoEmailAddress                        ErrorCode = "CustomerHasNoEmailAddress"
	ErrorCodeCustomerHasNoPaymentMethod                       ErrorCode = "CustomerHasNoPaymentMethod"
	ErrorCodeCustomerNoBillingID                              ErrorCode = "CustomerNoBillingId"
	ErrorCodeCustomerNotFound                                 ErrorCode = "CustomerNotFound"
	ErrorCodeCustomerResourceNotFound                         ErrorCode = "CustomerResourceNotFound"
	ErrorCodeDowngradeBillingPeriodNotSupportedError          ErrorCode = "DowngradeBillingPeriodNotSupportedError"
	ErrorCodeDraftPlanCantBeArchived                          ErrorCode = "DraftPlanCantBeArchived"
	ErrorCodeDuplicateProductValidationError                  ErrorCode = "DuplicateProductValidationError"
	ErrorCodeDuplicatedEntityNotAllowed                       ErrorCode = "DuplicatedEntityNotAllowed"
	ErrorCodeEditAllowedOnDraftPackageOnlyError               ErrorCode = "EditAllowedOnDraftPackageOnlyError"
	ErrorCodeEntitlementLimitExceededError                    ErrorCode = "EntitlementLimitExceededError"
	ErrorCodeEntitlementsMustBelongToSamePackage              ErrorCode = "EntitlementsMustBelongToSamePackage"
	ErrorCodeEntityIDDifferentFromRefIDError                  ErrorCode = "EntityIdDifferentFromRefIdError"
	ErrorCodeEntityIsArchivedError                            ErrorCode = "EntityIsArchivedError"
	ErrorCodeEnvironmentMissing                               ErrorCode = "EnvironmentMissing"
	ErrorCodeExperimentAlreadyRunning                         ErrorCode = "ExperimentAlreadyRunning"
	ErrorCodeExperimentNotFoundError                          ErrorCode = "ExperimentNotFoundError"
	ErrorCodeExperimentStatusError                            ErrorCode = "ExperimentStatusError"
	ErrorCodeFailedToCreateCheckoutSessionError               ErrorCode = "FailedToCreateCheckoutSessionError"
	ErrorCodeFailedToImportCustomer                           ErrorCode = "FailedToImportCustomer"
	ErrorCodeFeatureNotFound                                  ErrorCode = "FeatureNotFound"
	ErrorCodeFetchAllCountriesPricesNotAllowed                ErrorCode = "FetchAllCountriesPricesNotAllowed"
	ErrorCodeIdentityForbidden                                ErrorCode = "IdentityForbidden"
	ErrorCodeImportAlreadyInProgress                          ErrorCode = "ImportAlreadyInProgress"
	ErrorCodeImportSubscriptionsBulkError                     ErrorCode = "ImportSubscriptionsBulkError"
	ErrorCodeInitStripePaymentMethodError                     ErrorCode = "InitStripePaymentMethodError"
	ErrorCodeIntegrationNotFound                              ErrorCode = "IntegrationNotFound"
	ErrorCodeIntegrationValidationError                       ErrorCode = "IntegrationValidationError"
	ErrorCodeIntegrityViolation                               ErrorCode = "IntegrityViolation"
	ErrorCodeInvalidAddressError                              ErrorCode = "InvalidAddressError"
	ErrorCodeInvalidArgumentError                             ErrorCode = "InvalidArgumentError"
	ErrorCodeInvalidCancellationDate                          ErrorCode = "InvalidCancellationDate"
	ErrorCodeInvalidEntitlementResetPeriod                    ErrorCode = "InvalidEntitlementResetPeriod"
	ErrorCodeInvalidMemberDelete                              ErrorCode = "InvalidMemberDelete"
	ErrorCodeInvalidMetadataError                             ErrorCode = "InvalidMetadataError"
	ErrorCodeInvalidQuantity                                  ErrorCode = "InvalidQuantity"
	ErrorCodeInvalidSubscriptionStatus                        ErrorCode = "InvalidSubscriptionStatus"
	ErrorCodeInvalidUpdatePriceUnitAmountError                ErrorCode = "InvalidUpdatePriceUnitAmountError"
	ErrorCodeMemberInvitationError                            ErrorCode = "MemberInvitationError"
	ErrorCodeMemberNotFound                                   ErrorCode = "MemberNotFound"
	ErrorCodeMergeEnvironmentValidationError                  ErrorCode = "MergeEnvironmentValidationError"
	ErrorCodeMeterMustBeAssociatedToMeteredFeature            ErrorCode = "MeterMustBeAssociatedToMeteredFeature"
	ErrorCodeMeteringNotAvailableForFeatureType               ErrorCode = "MeteringNotAvailableForFeatureType"
	ErrorCodeMissingEntityIDError                             ErrorCode = "MissingEntityIdError"
	ErrorCodeNoFeatureEntitlementInSubscription               ErrorCode = "NoFeatureEntitlementInSubscription"
	ErrorCodeNoProductsAvailable                              ErrorCode = "NoProductsAvailable"
	ErrorCodeOperationNotAllowedDuringInProgressExperiment    ErrorCode = "OperationNotAllowedDuringInProgressExperiment"
	ErrorCodePackageAlreadyPublished                          ErrorCode = "PackageAlreadyPublished"
	ErrorCodePackagePricingTypeNotSet                         ErrorCode = "PackagePricingTypeNotSet"
	ErrorCodePaymentMethodNotFoundError                       ErrorCode = "PaymentMethodNotFoundError"
	ErrorCodePlanCannotBePublishWhenBasePlanIsDraft           ErrorCode = "PlanCannotBePublishWhenBasePlanIsDraft"
	ErrorCodePlanCannotBePublishWhenCompatibleAddonIsDraft    ErrorCode = "PlanCannotBePublishWhenCompatibleAddonIsDraft"
	ErrorCodePlanIsUsedAsDefaultStartPlan                     ErrorCode = "PlanIsUsedAsDefaultStartPlan"
	ErrorCodePlanIsUsedAsDowngradePlan                        ErrorCode = "PlanIsUsedAsDowngradePlan"
	ErrorCodePlanNotFound                                     ErrorCode = "PlanNotFound"
	ErrorCodePlanWithChildCantBeDeleted                       ErrorCode = "PlanWithChildCantBeDeleted"
	ErrorCodePlansCircularDependencyError                     ErrorCode = "PlansCircularDependencyError"
	ErrorCodePriceNotFound                                    ErrorCode = "PriceNotFound"
	ErrorCodePromotionCodeCustomerNotFirstPurchase            ErrorCode = "PromotionCodeCustomerNotFirstPurchase"
	ErrorCodePromotionCodeMaxRedemptionsReached               ErrorCode = "PromotionCodeMaxRedemptionsReached"
	ErrorCodePromotionCodeMinimumAmountNotReached             ErrorCode = "PromotionCodeMinimumAmountNotReached"
	ErrorCodePromotionCodeNotActive                           ErrorCode = "PromotionCodeNotActive"
	ErrorCodePromotionCodeNotForCustomer                      ErrorCode = "PromotionCodeNotForCustomer"
	ErrorCodePromotionCodeNotFound                            ErrorCode = "PromotionCodeNotFound"
	ErrorCodePromotionalEntitlementNotFoundError              ErrorCode = "PromotionalEntitlementNotFoundError"
	ErrorCodeRateLimitExceeded                                ErrorCode = "RateLimitExceeded"
	ErrorCodeRecalculateEntitlementsError                     ErrorCode = "RecalculateEntitlementsError"
	ErrorCodeResyncAlreadyInProgress                          ErrorCode = "ResyncAlreadyInProgress"
	ErrorCodeScheduledMigrationAlreadyExistsError             ErrorCode = "ScheduledMigrationAlreadyExistsError"
	ErrorCodeSelectedBillingModelDoesntMatchImportedItemError ErrorCode = "SelectedBillingModelDoesntMatchImportedItemError"
	ErrorCodeStripeCustomerIsDeleted                          ErrorCode = "StripeCustomerIsDeleted"
	ErrorCodeStripeError                                      ErrorCode = "StripeError"
	ErrorCodeSubscriptionAlreadyCanceledOrExpired             ErrorCode = "SubscriptionAlreadyCanceledOrExpired"
	ErrorCodeSubscriptionAlreadyOnLatestPlanError             ErrorCode = "SubscriptionAlreadyOnLatestPlanError"
	ErrorCodeSubscriptionMustHaveSinglePlanError              ErrorCode = "SubscriptionMustHaveSinglePlanError"
	ErrorCodeSubscriptionNotFound                             ErrorCode = "SubscriptionNotFound"
	ErrorCodeTooManySubscriptionsPerCustomer                  ErrorCode = "TooManySubscriptionsPerCustomer"
	ErrorCodeTrialMinDateError                                ErrorCode = "TrialMinDateError"
	ErrorCodeTrialMustBeCancelledImmediately                  ErrorCode = "TrialMustBeCancelledImmediately"
	ErrorCodeUnPublishedPackage                               ErrorCode = "UnPublishedPackage"
	ErrorCodeUnauthenticated                                  ErrorCode = "Unauthenticated"
	ErrorCodeUncompatibleSubscriptionAddon                    ErrorCode = "UncompatibleSubscriptionAddon"
	ErrorCodeUnexpectedError                                  ErrorCode = "UnexpectedError"
	ErrorCodeUnsupportedFeatureType                           ErrorCode = "UnsupportedFeatureType"
	ErrorCodeUnsupportedSubscriptionScheduleType              ErrorCode = "UnsupportedSubscriptionScheduleType"
	ErrorCodeUnsupportedVendorIdentifier                      ErrorCode = "UnsupportedVendorIdentifier"
)

var AllErrorCode = []ErrorCode{
	ErrorCodeAccountNotFoundError,
	ErrorCodeAddonHasToHavePriceError,
	ErrorCodeAddonNotFound,
	ErrorCodeAddonWithDraftCannotBeDeletedError,
	ErrorCodeAmountTooLarge,
	ErrorCodeArchivedCouponCantBeApplied,
	ErrorCodeAuthCustomerMismatch,
	ErrorCodeAwsMarketplaceIntegrationError,
	ErrorCodeAwsMarketplaceIntegrationValidationError,
	ErrorCodeBadUserInput,
	ErrorCodeBillingPeriodMissingError,
	ErrorCodeCannotArchiveFeatureError,
	ErrorCodeCannotDeleteCustomerError,
	ErrorCodeCannotDeleteFeatureError,
	ErrorCodeCannotDeleteProductError,
	ErrorCodeCannotEditPackageInNonDraftMode,
	ErrorCodeCannotRemovePaymentMethodFromCustomerError,
	ErrorCodeCannotReportUsageForEntitlementWithMeterError,
	ErrorCodeCannotUpsertToPackageThatHasDraft,
	ErrorCodeCheckoutIsNotSupported,
	ErrorCodeCheckoutOptionsMissing,
	ErrorCodeCouponNotFound,
	ErrorCodeCustomerAlreadyHaveCustomerCoupon,
	ErrorCodeCustomerAlreadyUsesCoupon,
	ErrorCodeCustomerHasNoEmailAddress,
	ErrorCodeCustomerHasNoPaymentMethod,
	ErrorCodeCustomerNoBillingID,
	ErrorCodeCustomerNotFound,
	ErrorCodeCustomerResourceNotFound,
	ErrorCodeDowngradeBillingPeriodNotSupportedError,
	ErrorCodeDraftPlanCantBeArchived,
	ErrorCodeDuplicateProductValidationError,
	ErrorCodeDuplicatedEntityNotAllowed,
	ErrorCodeEditAllowedOnDraftPackageOnlyError,
	ErrorCodeEntitlementLimitExceededError,
	ErrorCodeEntitlementsMustBelongToSamePackage,
	ErrorCodeEntityIDDifferentFromRefIDError,
	ErrorCodeEntityIsArchivedError,
	ErrorCodeEnvironmentMissing,
	ErrorCodeExperimentAlreadyRunning,
	ErrorCodeExperimentNotFoundError,
	ErrorCodeExperimentStatusError,
	ErrorCodeFailedToCreateCheckoutSessionError,
	ErrorCodeFailedToImportCustomer,
	ErrorCodeFeatureNotFound,
	ErrorCodeFetchAllCountriesPricesNotAllowed,
	ErrorCodeIdentityForbidden,
	ErrorCodeImportAlreadyInProgress,
	ErrorCodeImportSubscriptionsBulkError,
	ErrorCodeInitStripePaymentMethodError,
	ErrorCodeIntegrationNotFound,
	ErrorCodeIntegrationValidationError,
	ErrorCodeIntegrityViolation,
	ErrorCodeInvalidAddressError,
	ErrorCodeInvalidArgumentError,
	ErrorCodeInvalidCancellationDate,
	ErrorCodeInvalidEntitlementResetPeriod,
	ErrorCodeInvalidMemberDelete,
	ErrorCodeInvalidMetadataError,
	ErrorCodeInvalidQuantity,
	ErrorCodeInvalidSubscriptionStatus,
	ErrorCodeInvalidUpdatePriceUnitAmountError,
	ErrorCodeMemberInvitationError,
	ErrorCodeMemberNotFound,
	ErrorCodeMergeEnvironmentValidationError,
	ErrorCodeMeterMustBeAssociatedToMeteredFeature,
	ErrorCodeMeteringNotAvailableForFeatureType,
	ErrorCodeMissingEntityIDError,
	ErrorCodeNoFeatureEntitlementInSubscription,
	ErrorCodeNoProductsAvailable,
	ErrorCodeOperationNotAllowedDuringInProgressExperiment,
	ErrorCodePackageAlreadyPublished,
	ErrorCodePackagePricingTypeNotSet,
	ErrorCodePaymentMethodNotFoundError,
	ErrorCodePlanCannotBePublishWhenBasePlanIsDraft,
	ErrorCodePlanCannotBePublishWhenCompatibleAddonIsDraft,
	ErrorCodePlanIsUsedAsDefaultStartPlan,
	ErrorCodePlanIsUsedAsDowngradePlan,
	ErrorCodePlanNotFound,
	ErrorCodePlanWithChildCantBeDeleted,
	ErrorCodePlansCircularDependencyError,
	ErrorCodePriceNotFound,
	ErrorCodePromotionCodeCustomerNotFirstPurchase,
	ErrorCodePromotionCodeMaxRedemptionsReached,
	ErrorCodePromotionCodeMinimumAmountNotReached,
	ErrorCodePromotionCodeNotActive,
	ErrorCodePromotionCodeNotForCustomer,
	ErrorCodePromotionCodeNotFound,
	ErrorCodePromotionalEntitlementNotFoundError,
	ErrorCodeRateLimitExceeded,
	ErrorCodeRecalculateEntitlementsError,
	ErrorCodeResyncAlreadyInProgress,
	ErrorCodeScheduledMigrationAlreadyExistsError,
	ErrorCodeSelectedBillingModelDoesntMatchImportedItemError,
	ErrorCodeStripeCustomerIsDeleted,
	ErrorCodeStripeError,
	ErrorCodeSubscriptionAlreadyCanceledOrExpired,
	ErrorCodeSubscriptionAlreadyOnLatestPlanError,
	ErrorCodeSubscriptionMustHaveSinglePlanError,
	ErrorCodeSubscriptionNotFound,
	ErrorCodeTooManySubscriptionsPerCustomer,
	ErrorCodeTrialMinDateError,
	ErrorCodeTrialMustBeCancelledImmediately,
	ErrorCodeUnPublishedPackage,
	ErrorCodeUnauthenticated,
	ErrorCodeUncompatibleSubscriptionAddon,
	ErrorCodeUnexpectedError,
	ErrorCodeUnsupportedFeatureType,
	ErrorCodeUnsupportedSubscriptionScheduleType,
	ErrorCodeUnsupportedVendorIdentifier,
}

func (e ErrorCode) IsValid() bool {
	switch e {
	case ErrorCodeAccountNotFoundError, ErrorCodeAddonHasToHavePriceError, ErrorCodeAddonNotFound, ErrorCodeAddonWithDraftCannotBeDeletedError, ErrorCodeAmountTooLarge, ErrorCodeArchivedCouponCantBeApplied, ErrorCodeAuthCustomerMismatch, ErrorCodeAwsMarketplaceIntegrationError, ErrorCodeAwsMarketplaceIntegrationValidationError, ErrorCodeBadUserInput, ErrorCodeBillingPeriodMissingError, ErrorCodeCannotArchiveFeatureError, ErrorCodeCannotDeleteCustomerError, ErrorCodeCannotDeleteFeatureError, ErrorCodeCannotDeleteProductError, ErrorCodeCannotEditPackageInNonDraftMode, ErrorCodeCannotRemovePaymentMethodFromCustomerError, ErrorCodeCannotReportUsageForEntitlementWithMeterError, ErrorCodeCannotUpsertToPackageThatHasDraft, ErrorCodeCheckoutIsNotSupported, ErrorCodeCheckoutOptionsMissing, ErrorCodeCouponNotFound, ErrorCodeCustomerAlreadyHaveCustomerCoupon, ErrorCodeCustomerAlreadyUsesCoupon, ErrorCodeCustomerHasNoEmailAddress, ErrorCodeCustomerHasNoPaymentMethod, ErrorCodeCustomerNoBillingID, ErrorCodeCustomerNotFound, ErrorCodeCustomerResourceNotFound, ErrorCodeDowngradeBillingPeriodNotSupportedError, ErrorCodeDraftPlanCantBeArchived, ErrorCodeDuplicateProductValidationError, ErrorCodeDuplicatedEntityNotAllowed, ErrorCodeEditAllowedOnDraftPackageOnlyError, ErrorCodeEntitlementLimitExceededError, ErrorCodeEntitlementsMustBelongToSamePackage, ErrorCodeEntityIDDifferentFromRefIDError, ErrorCodeEntityIsArchivedError, ErrorCodeEnvironmentMissing, ErrorCodeExperimentAlreadyRunning, ErrorCodeExperimentNotFoundError, ErrorCodeExperimentStatusError, ErrorCodeFailedToCreateCheckoutSessionError, ErrorCodeFailedToImportCustomer, ErrorCodeFeatureNotFound, ErrorCodeFetchAllCountriesPricesNotAllowed, ErrorCodeIdentityForbidden, ErrorCodeImportAlreadyInProgress, ErrorCodeImportSubscriptionsBulkError, ErrorCodeInitStripePaymentMethodError, ErrorCodeIntegrationNotFound, ErrorCodeIntegrationValidationError, ErrorCodeIntegrityViolation, ErrorCodeInvalidAddressError, ErrorCodeInvalidArgumentError, ErrorCodeInvalidCancellationDate, ErrorCodeInvalidEntitlementResetPeriod, ErrorCodeInvalidMemberDelete, ErrorCodeInvalidMetadataError, ErrorCodeInvalidQuantity, ErrorCodeInvalidSubscriptionStatus, ErrorCodeInvalidUpdatePriceUnitAmountError, ErrorCodeMemberInvitationError, ErrorCodeMemberNotFound, ErrorCodeMergeEnvironmentValidationError, ErrorCodeMeterMustBeAssociatedToMeteredFeature, ErrorCodeMeteringNotAvailableForFeatureType, ErrorCodeMissingEntityIDError, ErrorCodeNoFeatureEntitlementInSubscription, ErrorCodeNoProductsAvailable, ErrorCodeOperationNotAllowedDuringInProgressExperiment, ErrorCodePackageAlreadyPublished, ErrorCodePackagePricingTypeNotSet, ErrorCodePaymentMethodNotFoundError, ErrorCodePlanCannotBePublishWhenBasePlanIsDraft, ErrorCodePlanCannotBePublishWhenCompatibleAddonIsDraft, ErrorCodePlanIsUsedAsDefaultStartPlan, ErrorCodePlanIsUsedAsDowngradePlan, ErrorCodePlanNotFound, ErrorCodePlanWithChildCantBeDeleted, ErrorCodePlansCircularDependencyError, ErrorCodePriceNotFound, ErrorCodePromotionCodeCustomerNotFirstPurchase, ErrorCodePromotionCodeMaxRedemptionsReached, ErrorCodePromotionCodeMinimumAmountNotReached, ErrorCodePromotionCodeNotActive, ErrorCodePromotionCodeNotForCustomer, ErrorCodePromotionCodeNotFound, ErrorCodePromotionalEntitlementNotFoundError, ErrorCodeRateLimitExceeded, ErrorCodeRecalculateEntitlementsError, ErrorCodeResyncAlreadyInProgress, ErrorCodeScheduledMigrationAlreadyExistsError, ErrorCodeSelectedBillingModelDoesntMatchImportedItemError, ErrorCodeStripeCustomerIsDeleted, ErrorCodeStripeError, ErrorCodeSubscriptionAlreadyCanceledOrExpired, ErrorCodeSubscriptionAlreadyOnLatestPlanError, ErrorCodeSubscriptionMustHaveSinglePlanError, ErrorCodeSubscriptionNotFound, ErrorCodeTooManySubscriptionsPerCustomer, ErrorCodeTrialMinDateError, ErrorCodeTrialMustBeCancelledImmediately, ErrorCodeUnPublishedPackage, ErrorCodeUnauthenticated, ErrorCodeUncompatibleSubscriptionAddon, ErrorCodeUnexpectedError, ErrorCodeUnsupportedFeatureType, ErrorCodeUnsupportedSubscriptionScheduleType, ErrorCodeUnsupportedVendorIdentifier:
		return true
	}
	return false
}

func (e ErrorCode) String() string {
	return string(e)
}

func (e *ErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCode", str)
	}
	return nil
}

func (e ErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// EventLogType
type EventLogType string

const (
	EventLogTypeAddonCreated                                    EventLogType = "ADDON_CREATED"
	EventLogTypeAddonDeleted                                    EventLogType = "ADDON_DELETED"
	EventLogTypeAddonUpdated                                    EventLogType = "ADDON_UPDATED"
	EventLogTypeCouponArchived                                  EventLogType = "COUPON_ARCHIVED"
	EventLogTypeCouponCreated                                   EventLogType = "COUPON_CREATED"
	EventLogTypeCouponUpdated                                   EventLogType = "COUPON_UPDATED"
	EventLogTypeCreateSubscriptionFailed                        EventLogType = "CREATE_SUBSCRIPTION_FAILED"
	EventLogTypeCustomerCreated                                 EventLogType = "CUSTOMER_CREATED"
	EventLogTypeCustomerDeleted                                 EventLogType = "CUSTOMER_DELETED"
	EventLogTypeCustomerEntitlementCalculationTriggered         EventLogType = "CUSTOMER_ENTITLEMENT_CALCULATION_TRIGGERED"
	EventLogTypeCustomerPaymentFailed                           EventLogType = "CUSTOMER_PAYMENT_FAILED"
	EventLogTypeCustomerResourceEntitlementCalculationTriggered EventLogType = "CUSTOMER_RESOURCE_ENTITLEMENT_CALCULATION_TRIGGERED"
	EventLogTypeCustomerUpdated                                 EventLogType = "CUSTOMER_UPDATED"
	EventLogTypeEdgeAPICustomerDataResync                       EventLogType = "EDGE_API_CUSTOMER_DATA_RESYNC"
	EventLogTypeEdgeAPIDataResync                               EventLogType = "EDGE_API_DATA_RESYNC"
	EventLogTypeEdgeAPIDoggoResync                              EventLogType = "EDGE_API_DOGGO_RESYNC"
	EventLogTypeEdgeAPIPackageEntitlementsDataResync            EventLogType = "EDGE_API_PACKAGE_ENTITLEMENTS_DATA_RESYNC"
	EventLogTypeEdgeAPISubscriptionsDataResync                  EventLogType = "EDGE_API_SUBSCRIPTIONS_DATA_RESYNC"
	EventLogTypeEntitlementsUpdated                             EventLogType = "ENTITLEMENTS_UPDATED"
	EventLogTypeEntitlementDenied                               EventLogType = "ENTITLEMENT_DENIED"
	EventLogTypeEntitlementGranted                              EventLogType = "ENTITLEMENT_GRANTED"
	EventLogTypeEntitlementRequested                            EventLogType = "ENTITLEMENT_REQUESTED"
	EventLogTypeEnvironmentDeleted                              EventLogType = "ENVIRONMENT_DELETED"
	EventLogTypeFeatureArchived                                 EventLogType = "FEATURE_ARCHIVED"
	EventLogTypeFeatureCreated                                  EventLogType = "FEATURE_CREATED"
	EventLogTypeFeatureDeleted                                  EventLogType = "FEATURE_DELETED"
	EventLogTypeFeatureUpdated                                  EventLogType = "FEATURE_UPDATED"
	EventLogTypeImportIntegrationCatalogTriggered               EventLogType = "IMPORT_INTEGRATION_CATALOG_TRIGGERED"
	EventLogTypeImportIntegrationCustomersTriggered             EventLogType = "IMPORT_INTEGRATION_CUSTOMERS_TRIGGERED"
	EventLogTypeImportSubscriptionsBulkTriggered                EventLogType = "IMPORT_SUBSCRIPTIONS_BULK_TRIGGERED"
	EventLogTypeMeasurementReported                             EventLogType = "MEASUREMENT_REPORTED"
	EventLogTypePackagePublished                                EventLogType = "PACKAGE_PUBLISHED"
	EventLogTypePlanCreated                                     EventLogType = "PLAN_CREATED"
	EventLogTypePlanDeleted                                     EventLogType = "PLAN_DELETED"
	EventLogTypePlanUpdated                                     EventLogType = "PLAN_UPDATED"
	EventLogTypeProductCreated                                  EventLogType = "PRODUCT_CREATED"
	EventLogTypeProductDeleted                                  EventLogType = "PRODUCT_DELETED"
	EventLogTypeProductUpdated                                  EventLogType = "PRODUCT_UPDATED"
	EventLogTypePromotionalEntitlementExpired                   EventLogType = "PROMOTIONAL_ENTITLEMENT_EXPIRED"
	EventLogTypePromotionalEntitlementGranted                   EventLogType = "PROMOTIONAL_ENTITLEMENT_GRANTED"
	EventLogTypePromotionalEntitlementRevoked                   EventLogType = "PROMOTIONAL_ENTITLEMENT_REVOKED"
	EventLogTypePromotionalEntitlementUpdated                   EventLogType = "PROMOTIONAL_ENTITLEMENT_UPDATED"
	EventLogTypeRecalculateEntitlementsTriggered                EventLogType = "RECALCULATE_ENTITLEMENTS_TRIGGERED"
	EventLogTypeResyncIntegrationTriggered                      EventLogType = "RESYNC_INTEGRATION_TRIGGERED"
	EventLogTypeSubscriptionsMigrated                           EventLogType = "SUBSCRIPTIONS_MIGRATED"
	EventLogTypeSubscriptionsMigrationTriggered                 EventLogType = "SUBSCRIPTIONS_MIGRATION_TRIGGERED"
	EventLogTypeSubscriptionCanceled                            EventLogType = "SUBSCRIPTION_CANCELED"
	EventLogTypeSubscriptionCreated                             EventLogType = "SUBSCRIPTION_CREATED"
	EventLogTypeSubscriptionExpired                             EventLogType = "SUBSCRIPTION_EXPIRED"
	EventLogTypeSubscriptionTrialConverted                      EventLogType = "SUBSCRIPTION_TRIAL_CONVERTED"
	EventLogTypeSubscriptionTrialEndsSoon                       EventLogType = "SUBSCRIPTION_TRIAL_ENDS_SOON"
	EventLogTypeSubscriptionTrialExpired                        EventLogType = "SUBSCRIPTION_TRIAL_EXPIRED"
	EventLogTypeSubscriptionTrialStarted                        EventLogType = "SUBSCRIPTION_TRIAL_STARTED"
	EventLogTypeSubscriptionUpdated                             EventLogType = "SUBSCRIPTION_UPDATED"
	EventLogTypeSubscriptionUsageUpdated                        EventLogType = "SUBSCRIPTION_USAGE_UPDATED"
	EventLogTypeSyncFailed                                      EventLogType = "SYNC_FAILED"
	EventLogTypeWidgetConfigurationUpdated                      EventLogType = "WIDGET_CONFIGURATION_UPDATED"
)

var AllEventLogType = []EventLogType{
	EventLogTypeAddonCreated,
	EventLogTypeAddonDeleted,
	EventLogTypeAddonUpdated,
	EventLogTypeCouponArchived,
	EventLogTypeCouponCreated,
	EventLogTypeCouponUpdated,
	EventLogTypeCreateSubscriptionFailed,
	EventLogTypeCustomerCreated,
	EventLogTypeCustomerDeleted,
	EventLogTypeCustomerEntitlementCalculationTriggered,
	EventLogTypeCustomerPaymentFailed,
	EventLogTypeCustomerResourceEntitlementCalculationTriggered,
	EventLogTypeCustomerUpdated,
	EventLogTypeEdgeAPICustomerDataResync,
	EventLogTypeEdgeAPIDataResync,
	EventLogTypeEdgeAPIDoggoResync,
	EventLogTypeEdgeAPIPackageEntitlementsDataResync,
	EventLogTypeEdgeAPISubscriptionsDataResync,
	EventLogTypeEntitlementsUpdated,
	EventLogTypeEntitlementDenied,
	EventLogTypeEntitlementGranted,
	EventLogTypeEntitlementRequested,
	EventLogTypeEnvironmentDeleted,
	EventLogTypeFeatureArchived,
	EventLogTypeFeatureCreated,
	EventLogTypeFeatureDeleted,
	EventLogTypeFeatureUpdated,
	EventLogTypeImportIntegrationCatalogTriggered,
	EventLogTypeImportIntegrationCustomersTriggered,
	EventLogTypeImportSubscriptionsBulkTriggered,
	EventLogTypeMeasurementReported,
	EventLogTypePackagePublished,
	EventLogTypePlanCreated,
	EventLogTypePlanDeleted,
	EventLogTypePlanUpdated,
	EventLogTypeProductCreated,
	EventLogTypeProductDeleted,
	EventLogTypeProductUpdated,
	EventLogTypePromotionalEntitlementExpired,
	EventLogTypePromotionalEntitlementGranted,
	EventLogTypePromotionalEntitlementRevoked,
	EventLogTypePromotionalEntitlementUpdated,
	EventLogTypeRecalculateEntitlementsTriggered,
	EventLogTypeResyncIntegrationTriggered,
	EventLogTypeSubscriptionsMigrated,
	EventLogTypeSubscriptionsMigrationTriggered,
	EventLogTypeSubscriptionCanceled,
	EventLogTypeSubscriptionCreated,
	EventLogTypeSubscriptionExpired,
	EventLogTypeSubscriptionTrialConverted,
	EventLogTypeSubscriptionTrialEndsSoon,
	EventLogTypeSubscriptionTrialExpired,
	EventLogTypeSubscriptionTrialStarted,
	EventLogTypeSubscriptionUpdated,
	EventLogTypeSubscriptionUsageUpdated,
	EventLogTypeSyncFailed,
	EventLogTypeWidgetConfigurationUpdated,
}

func (e EventLogType) IsValid() bool {
	switch e {
	case EventLogTypeAddonCreated, EventLogTypeAddonDeleted, EventLogTypeAddonUpdated, EventLogTypeCouponArchived, EventLogTypeCouponCreated, EventLogTypeCouponUpdated, EventLogTypeCreateSubscriptionFailed, EventLogTypeCustomerCreated, EventLogTypeCustomerDeleted, EventLogTypeCustomerEntitlementCalculationTriggered, EventLogTypeCustomerPaymentFailed, EventLogTypeCustomerResourceEntitlementCalculationTriggered, EventLogTypeCustomerUpdated, EventLogTypeEdgeAPICustomerDataResync, EventLogTypeEdgeAPIDataResync, EventLogTypeEdgeAPIDoggoResync, EventLogTypeEdgeAPIPackageEntitlementsDataResync, EventLogTypeEdgeAPISubscriptionsDataResync, EventLogTypeEntitlementsUpdated, EventLogTypeEntitlementDenied, EventLogTypeEntitlementGranted, EventLogTypeEntitlementRequested, EventLogTypeEnvironmentDeleted, EventLogTypeFeatureArchived, EventLogTypeFeatureCreated, EventLogTypeFeatureDeleted, EventLogTypeFeatureUpdated, EventLogTypeImportIntegrationCatalogTriggered, EventLogTypeImportIntegrationCustomersTriggered, EventLogTypeImportSubscriptionsBulkTriggered, EventLogTypeMeasurementReported, EventLogTypePackagePublished, EventLogTypePlanCreated, EventLogTypePlanDeleted, EventLogTypePlanUpdated, EventLogTypeProductCreated, EventLogTypeProductDeleted, EventLogTypeProductUpdated, EventLogTypePromotionalEntitlementExpired, EventLogTypePromotionalEntitlementGranted, EventLogTypePromotionalEntitlementRevoked, EventLogTypePromotionalEntitlementUpdated, EventLogTypeRecalculateEntitlementsTriggered, EventLogTypeResyncIntegrationTriggered, EventLogTypeSubscriptionsMigrated, EventLogTypeSubscriptionsMigrationTriggered, EventLogTypeSubscriptionCanceled, EventLogTypeSubscriptionCreated, EventLogTypeSubscriptionExpired, EventLogTypeSubscriptionTrialConverted, EventLogTypeSubscriptionTrialEndsSoon, EventLogTypeSubscriptionTrialExpired, EventLogTypeSubscriptionTrialStarted, EventLogTypeSubscriptionUpdated, EventLogTypeSubscriptionUsageUpdated, EventLogTypeSyncFailed, EventLogTypeWidgetConfigurationUpdated:
		return true
	}
	return false
}

func (e EventLogType) String() string {
	return string(e)
}

func (e *EventLogType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventLogType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventLogType", str)
	}
	return nil
}

func (e EventLogType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ExperimentSortFields string

const (
	ExperimentSortFieldsCreatedAt     ExperimentSortFields = "createdAt"
	ExperimentSortFieldsEnvironmentID ExperimentSortFields = "environmentId"
	ExperimentSortFieldsID            ExperimentSortFields = "id"
	ExperimentSortFieldsName          ExperimentSortFields = "name"
	ExperimentSortFieldsProductID     ExperimentSortFields = "productId"
	ExperimentSortFieldsRefID         ExperimentSortFields = "refId"
	ExperimentSortFieldsStatus        ExperimentSortFields = "status"
)

var AllExperimentSortFields = []ExperimentSortFields{
	ExperimentSortFieldsCreatedAt,
	ExperimentSortFieldsEnvironmentID,
	ExperimentSortFieldsID,
	ExperimentSortFieldsName,
	ExperimentSortFieldsProductID,
	ExperimentSortFieldsRefID,
	ExperimentSortFieldsStatus,
}

func (e ExperimentSortFields) IsValid() bool {
	switch e {
	case ExperimentSortFieldsCreatedAt, ExperimentSortFieldsEnvironmentID, ExperimentSortFieldsID, ExperimentSortFieldsName, ExperimentSortFieldsProductID, ExperimentSortFieldsRefID, ExperimentSortFieldsStatus:
		return true
	}
	return false
}

func (e ExperimentSortFields) String() string {
	return string(e)
}

func (e *ExperimentSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentSortFields", str)
	}
	return nil
}

func (e ExperimentSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the EXPERIMENT
type ExperimentStatus string

const (
	ExperimentStatusCompleted  ExperimentStatus = "COMPLETED"
	ExperimentStatusDraft      ExperimentStatus = "DRAFT"
	ExperimentStatusInProgress ExperimentStatus = "IN_PROGRESS"
)

var AllExperimentStatus = []ExperimentStatus{
	ExperimentStatusCompleted,
	ExperimentStatusDraft,
	ExperimentStatusInProgress,
}

func (e ExperimentStatus) IsValid() bool {
	switch e {
	case ExperimentStatusCompleted, ExperimentStatusDraft, ExperimentStatusInProgress:
		return true
	}
	return false
}

func (e ExperimentStatus) String() string {
	return string(e)
}

func (e *ExperimentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentStatus", str)
	}
	return nil
}

func (e ExperimentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FeatureSortFields string

const (
	FeatureSortFieldsCreatedAt     FeatureSortFields = "createdAt"
	FeatureSortFieldsDescription   FeatureSortFields = "description"
	FeatureSortFieldsDisplayName   FeatureSortFields = "displayName"
	FeatureSortFieldsEnvironmentID FeatureSortFields = "environmentId"
	FeatureSortFieldsFeatureStatus FeatureSortFields = "featureStatus"
	FeatureSortFieldsFeatureType   FeatureSortFields = "featureType"
	FeatureSortFieldsID            FeatureSortFields = "id"
	FeatureSortFieldsMeterType     FeatureSortFields = "meterType"
	FeatureSortFieldsRefID         FeatureSortFields = "refId"
	FeatureSortFieldsUpdatedAt     FeatureSortFields = "updatedAt"
)

var AllFeatureSortFields = []FeatureSortFields{
	FeatureSortFieldsCreatedAt,
	FeatureSortFieldsDescription,
	FeatureSortFieldsDisplayName,
	FeatureSortFieldsEnvironmentID,
	FeatureSortFieldsFeatureStatus,
	FeatureSortFieldsFeatureType,
	FeatureSortFieldsID,
	FeatureSortFieldsMeterType,
	FeatureSortFieldsRefID,
	FeatureSortFieldsUpdatedAt,
}

func (e FeatureSortFields) IsValid() bool {
	switch e {
	case FeatureSortFieldsCreatedAt, FeatureSortFieldsDescription, FeatureSortFieldsDisplayName, FeatureSortFieldsEnvironmentID, FeatureSortFieldsFeatureStatus, FeatureSortFieldsFeatureType, FeatureSortFieldsID, FeatureSortFieldsMeterType, FeatureSortFieldsRefID, FeatureSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e FeatureSortFields) String() string {
	return string(e)
}

func (e *FeatureSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureSortFields", str)
	}
	return nil
}

func (e FeatureSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feature status.
type FeatureStatus string

const (
	FeatureStatusActive    FeatureStatus = "ACTIVE"
	FeatureStatusNew       FeatureStatus = "NEW"
	FeatureStatusSuspended FeatureStatus = "SUSPENDED"
)

var AllFeatureStatus = []FeatureStatus{
	FeatureStatusActive,
	FeatureStatusNew,
	FeatureStatusSuspended,
}

func (e FeatureStatus) IsValid() bool {
	switch e {
	case FeatureStatusActive, FeatureStatusNew, FeatureStatusSuspended:
		return true
	}
	return false
}

func (e FeatureStatus) String() string {
	return string(e)
}

func (e *FeatureStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureStatus", str)
	}
	return nil
}

func (e FeatureStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the feature
type FeatureType string

const (
	FeatureTypeBoolean FeatureType = "BOOLEAN"
	FeatureTypeNumber  FeatureType = "NUMBER"
)

var AllFeatureType = []FeatureType{
	FeatureTypeBoolean,
	FeatureTypeNumber,
}

func (e FeatureType) IsValid() bool {
	switch e {
	case FeatureTypeBoolean, FeatureTypeNumber:
		return true
	}
	return false
}

func (e FeatureType) String() string {
	return string(e)
}

func (e *FeatureType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureType", str)
	}
	return nil
}

func (e FeatureType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Font weight
type FontWeight string

const (
	FontWeightBold   FontWeight = "BOLD"
	FontWeightNormal FontWeight = "NORMAL"
)

var AllFontWeight = []FontWeight{
	FontWeightBold,
	FontWeightNormal,
}

func (e FontWeight) IsValid() bool {
	switch e {
	case FontWeightBold, FontWeightNormal:
		return true
	}
	return false
}

func (e FontWeight) String() string {
	return string(e)
}

func (e *FontWeight) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FontWeight(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FontWeight", str)
	}
	return nil
}

func (e FontWeight) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HookSortFields string

const (
	HookSortFieldsCreatedAt     HookSortFields = "createdAt"
	HookSortFieldsEndpoint      HookSortFields = "endpoint"
	HookSortFieldsEnvironmentID HookSortFields = "environmentId"
	HookSortFieldsID            HookSortFields = "id"
	HookSortFieldsStatus        HookSortFields = "status"
)

var AllHookSortFields = []HookSortFields{
	HookSortFieldsCreatedAt,
	HookSortFieldsEndpoint,
	HookSortFieldsEnvironmentID,
	HookSortFieldsID,
	HookSortFieldsStatus,
}

func (e HookSortFields) IsValid() bool {
	switch e {
	case HookSortFieldsCreatedAt, HookSortFieldsEndpoint, HookSortFieldsEnvironmentID, HookSortFieldsID, HookSortFieldsStatus:
		return true
	}
	return false
}

func (e HookSortFields) String() string {
	return string(e)
}

func (e *HookSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HookSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HookSortFields", str)
	}
	return nil
}

func (e HookSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// HookStatus.
type HookStatus string

const (
	HookStatusActive   HookStatus = "ACTIVE"
	HookStatusInactive HookStatus = "INACTIVE"
)

var AllHookStatus = []HookStatus{
	HookStatusActive,
	HookStatusInactive,
}

func (e HookStatus) IsValid() bool {
	switch e {
	case HookStatusActive, HookStatusInactive:
		return true
	}
	return false
}

func (e HookStatus) String() string {
	return string(e)
}

func (e *HookStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HookStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HookStatus", str)
	}
	return nil
}

func (e HookStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImportIntegrationTaskSortFields string

const (
	ImportIntegrationTaskSortFieldsCreatedAt     ImportIntegrationTaskSortFields = "createdAt"
	ImportIntegrationTaskSortFieldsEnvironmentID ImportIntegrationTaskSortFields = "environmentId"
	ImportIntegrationTaskSortFieldsID            ImportIntegrationTaskSortFields = "id"
	ImportIntegrationTaskSortFieldsStatus        ImportIntegrationTaskSortFields = "status"
	ImportIntegrationTaskSortFieldsTaskType      ImportIntegrationTaskSortFields = "taskType"
)

var AllImportIntegrationTaskSortFields = []ImportIntegrationTaskSortFields{
	ImportIntegrationTaskSortFieldsCreatedAt,
	ImportIntegrationTaskSortFieldsEnvironmentID,
	ImportIntegrationTaskSortFieldsID,
	ImportIntegrationTaskSortFieldsStatus,
	ImportIntegrationTaskSortFieldsTaskType,
}

func (e ImportIntegrationTaskSortFields) IsValid() bool {
	switch e {
	case ImportIntegrationTaskSortFieldsCreatedAt, ImportIntegrationTaskSortFieldsEnvironmentID, ImportIntegrationTaskSortFieldsID, ImportIntegrationTaskSortFieldsStatus, ImportIntegrationTaskSortFieldsTaskType:
		return true
	}
	return false
}

func (e ImportIntegrationTaskSortFields) String() string {
	return string(e)
}

func (e *ImportIntegrationTaskSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportIntegrationTaskSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportIntegrationTaskSortFields", str)
	}
	return nil
}

func (e ImportIntegrationTaskSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IntegrationSortFields string

const (
	IntegrationSortFieldsCreatedAt        IntegrationSortFields = "createdAt"
	IntegrationSortFieldsEnvironmentID    IntegrationSortFields = "environmentId"
	IntegrationSortFieldsID               IntegrationSortFields = "id"
	IntegrationSortFieldsVendorIdentifier IntegrationSortFields = "vendorIdentifier"
)

var AllIntegrationSortFields = []IntegrationSortFields{
	IntegrationSortFieldsCreatedAt,
	IntegrationSortFieldsEnvironmentID,
	IntegrationSortFieldsID,
	IntegrationSortFieldsVendorIdentifier,
}

func (e IntegrationSortFields) IsValid() bool {
	switch e {
	case IntegrationSortFieldsCreatedAt, IntegrationSortFieldsEnvironmentID, IntegrationSortFieldsID, IntegrationSortFieldsVendorIdentifier:
		return true
	}
	return false
}

func (e IntegrationSortFields) String() string {
	return string(e)
}

func (e *IntegrationSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationSortFields", str)
	}
	return nil
}

func (e IntegrationSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MemberSortFields string

const (
	MemberSortFieldsCreatedAt MemberSortFields = "createdAt"
	MemberSortFieldsID        MemberSortFields = "id"
)

var AllMemberSortFields = []MemberSortFields{
	MemberSortFieldsCreatedAt,
	MemberSortFieldsID,
}

func (e MemberSortFields) IsValid() bool {
	switch e {
	case MemberSortFieldsCreatedAt, MemberSortFieldsID:
		return true
	}
	return false
}

func (e MemberSortFields) String() string {
	return string(e)
}

func (e *MemberSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberSortFields", str)
	}
	return nil
}

func (e MemberSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Member Status.
type MemberStatus string

const (
	MemberStatusInvited    MemberStatus = "INVITED"
	MemberStatusRegistered MemberStatus = "REGISTERED"
)

var AllMemberStatus = []MemberStatus{
	MemberStatusInvited,
	MemberStatusRegistered,
}

func (e MemberStatus) IsValid() bool {
	switch e {
	case MemberStatusInvited, MemberStatusRegistered:
		return true
	}
	return false
}

func (e MemberStatus) String() string {
	return string(e)
}

func (e *MemberStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberStatus", str)
	}
	return nil
}

func (e MemberStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The meter type of the feature
type MeterType string

const (
	MeterTypeFluctuating MeterType = "Fluctuating"
	MeterTypeIncremental MeterType = "Incremental"
	MeterTypeNone        MeterType = "None"
)

var AllMeterType = []MeterType{
	MeterTypeFluctuating,
	MeterTypeIncremental,
	MeterTypeNone,
}

func (e MeterType) IsValid() bool {
	switch e {
	case MeterTypeFluctuating, MeterTypeIncremental, MeterTypeNone:
		return true
	}
	return false
}

func (e MeterType) String() string {
	return string(e)
}

func (e *MeterType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MeterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MeterType", str)
	}
	return nil
}

func (e MeterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Monthly reset period according to configuration
type MonthlyAccordingTo string

const (
	MonthlyAccordingToStartOfTheMonth   MonthlyAccordingTo = "StartOfTheMonth"
	MonthlyAccordingToSubscriptionStart MonthlyAccordingTo = "SubscriptionStart"
)

var AllMonthlyAccordingTo = []MonthlyAccordingTo{
	MonthlyAccordingToStartOfTheMonth,
	MonthlyAccordingToSubscriptionStart,
}

func (e MonthlyAccordingTo) IsValid() bool {
	switch e {
	case MonthlyAccordingToStartOfTheMonth, MonthlyAccordingToSubscriptionStart:
		return true
	}
	return false
}

func (e MonthlyAccordingTo) String() string {
	return string(e)
}

func (e *MonthlyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MonthlyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MonthlyAccordingTo", str)
	}
	return nil
}

func (e MonthlyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PackageDTOSortFields string

const (
	PackageDTOSortFieldsBillingID     PackageDTOSortFields = "billingId"
	PackageDTOSortFieldsCreatedAt     PackageDTOSortFields = "createdAt"
	PackageDTOSortFieldsDescription   PackageDTOSortFields = "description"
	PackageDTOSortFieldsDisplayName   PackageDTOSortFields = "displayName"
	PackageDTOSortFieldsEnvironmentID PackageDTOSortFields = "environmentId"
	PackageDTOSortFieldsID            PackageDTOSortFields = "id"
	PackageDTOSortFieldsIsLatest      PackageDTOSortFields = "isLatest"
	PackageDTOSortFieldsPricingType   PackageDTOSortFields = "pricingType"
	PackageDTOSortFieldsProductID     PackageDTOSortFields = "productId"
	PackageDTOSortFieldsRefID         PackageDTOSortFields = "refId"
	PackageDTOSortFieldsStatus        PackageDTOSortFields = "status"
	PackageDTOSortFieldsUpdatedAt     PackageDTOSortFields = "updatedAt"
	PackageDTOSortFieldsVersionNumber PackageDTOSortFields = "versionNumber"
)

var AllPackageDTOSortFields = []PackageDTOSortFields{
	PackageDTOSortFieldsBillingID,
	PackageDTOSortFieldsCreatedAt,
	PackageDTOSortFieldsDescription,
	PackageDTOSortFieldsDisplayName,
	PackageDTOSortFieldsEnvironmentID,
	PackageDTOSortFieldsID,
	PackageDTOSortFieldsIsLatest,
	PackageDTOSortFieldsPricingType,
	PackageDTOSortFieldsProductID,
	PackageDTOSortFieldsRefID,
	PackageDTOSortFieldsStatus,
	PackageDTOSortFieldsUpdatedAt,
	PackageDTOSortFieldsVersionNumber,
}

func (e PackageDTOSortFields) IsValid() bool {
	switch e {
	case PackageDTOSortFieldsBillingID, PackageDTOSortFieldsCreatedAt, PackageDTOSortFieldsDescription, PackageDTOSortFieldsDisplayName, PackageDTOSortFieldsEnvironmentID, PackageDTOSortFieldsID, PackageDTOSortFieldsIsLatest, PackageDTOSortFieldsPricingType, PackageDTOSortFieldsProductID, PackageDTOSortFieldsRefID, PackageDTOSortFieldsStatus, PackageDTOSortFieldsUpdatedAt, PackageDTOSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e PackageDTOSortFields) String() string {
	return string(e)
}

func (e *PackageDTOSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageDTOSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageDTOSortFields", str)
	}
	return nil
}

func (e PackageDTOSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PackageEntitlementSortFields string

const (
	PackageEntitlementSortFieldsCreatedAt     PackageEntitlementSortFields = "createdAt"
	PackageEntitlementSortFieldsEnvironmentID PackageEntitlementSortFields = "environmentId"
	PackageEntitlementSortFieldsID            PackageEntitlementSortFields = "id"
	PackageEntitlementSortFieldsPackageID     PackageEntitlementSortFields = "packageId"
	PackageEntitlementSortFieldsUpdatedAt     PackageEntitlementSortFields = "updatedAt"
)

var AllPackageEntitlementSortFields = []PackageEntitlementSortFields{
	PackageEntitlementSortFieldsCreatedAt,
	PackageEntitlementSortFieldsEnvironmentID,
	PackageEntitlementSortFieldsID,
	PackageEntitlementSortFieldsPackageID,
	PackageEntitlementSortFieldsUpdatedAt,
}

func (e PackageEntitlementSortFields) IsValid() bool {
	switch e {
	case PackageEntitlementSortFieldsCreatedAt, PackageEntitlementSortFieldsEnvironmentID, PackageEntitlementSortFieldsID, PackageEntitlementSortFieldsPackageID, PackageEntitlementSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e PackageEntitlementSortFields) String() string {
	return string(e)
}

func (e *PackageEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageEntitlementSortFields", str)
	}
	return nil
}

func (e PackageEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Package status.
type PackageStatus string

const (
	PackageStatusArchived  PackageStatus = "ARCHIVED"
	PackageStatusDraft     PackageStatus = "DRAFT"
	PackageStatusPublished PackageStatus = "PUBLISHED"
)

var AllPackageStatus = []PackageStatus{
	PackageStatusArchived,
	PackageStatusDraft,
	PackageStatusPublished,
}

func (e PackageStatus) IsValid() bool {
	switch e {
	case PackageStatusArchived, PackageStatusDraft, PackageStatusPublished:
		return true
	}
	return false
}

func (e PackageStatus) String() string {
	return string(e)
}

func (e *PackageStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageStatus", str)
	}
	return nil
}

func (e PackageStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Payment collection
type PaymentCollection string

const (
	PaymentCollectionActionRequired PaymentCollection = "ACTION_REQUIRED"
	PaymentCollectionFailed         PaymentCollection = "FAILED"
	PaymentCollectionNotRequired    PaymentCollection = "NOT_REQUIRED"
	PaymentCollectionProcessing     PaymentCollection = "PROCESSING"
)

var AllPaymentCollection = []PaymentCollection{
	PaymentCollectionActionRequired,
	PaymentCollectionFailed,
	PaymentCollectionNotRequired,
	PaymentCollectionProcessing,
}

func (e PaymentCollection) IsValid() bool {
	switch e {
	case PaymentCollectionActionRequired, PaymentCollectionFailed, PaymentCollectionNotRequired, PaymentCollectionProcessing:
		return true
	}
	return false
}

func (e PaymentCollection) String() string {
	return string(e)
}

func (e *PaymentCollection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentCollection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentCollection", str)
	}
	return nil
}

func (e PaymentCollection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of a payment method
type PaymentMethodType string

const (
	PaymentMethodTypeBank PaymentMethodType = "BANK"
	PaymentMethodTypeCard PaymentMethodType = "CARD"
)

var AllPaymentMethodType = []PaymentMethodType{
	PaymentMethodTypeBank,
	PaymentMethodTypeCard,
}

func (e PaymentMethodType) IsValid() bool {
	switch e {
	case PaymentMethodTypeBank, PaymentMethodTypeCard:
		return true
	}
	return false
}

func (e PaymentMethodType) String() string {
	return string(e)
}

func (e *PaymentMethodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethodType", str)
	}
	return nil
}

func (e PaymentMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlanSortFields string

const (
	PlanSortFieldsBillingID     PlanSortFields = "billingId"
	PlanSortFieldsCreatedAt     PlanSortFields = "createdAt"
	PlanSortFieldsDescription   PlanSortFields = "description"
	PlanSortFieldsDisplayName   PlanSortFields = "displayName"
	PlanSortFieldsEnvironmentID PlanSortFields = "environmentId"
	PlanSortFieldsID            PlanSortFields = "id"
	PlanSortFieldsIsLatest      PlanSortFields = "isLatest"
	PlanSortFieldsPricingType   PlanSortFields = "pricingType"
	PlanSortFieldsProductID     PlanSortFields = "productId"
	PlanSortFieldsRefID         PlanSortFields = "refId"
	PlanSortFieldsStatus        PlanSortFields = "status"
	PlanSortFieldsUpdatedAt     PlanSortFields = "updatedAt"
	PlanSortFieldsVersionNumber PlanSortFields = "versionNumber"
)

var AllPlanSortFields = []PlanSortFields{
	PlanSortFieldsBillingID,
	PlanSortFieldsCreatedAt,
	PlanSortFieldsDescription,
	PlanSortFieldsDisplayName,
	PlanSortFieldsEnvironmentID,
	PlanSortFieldsID,
	PlanSortFieldsIsLatest,
	PlanSortFieldsPricingType,
	PlanSortFieldsProductID,
	PlanSortFieldsRefID,
	PlanSortFieldsStatus,
	PlanSortFieldsUpdatedAt,
	PlanSortFieldsVersionNumber,
}

func (e PlanSortFields) IsValid() bool {
	switch e {
	case PlanSortFieldsBillingID, PlanSortFieldsCreatedAt, PlanSortFieldsDescription, PlanSortFieldsDisplayName, PlanSortFieldsEnvironmentID, PlanSortFieldsID, PlanSortFieldsIsLatest, PlanSortFieldsPricingType, PlanSortFieldsProductID, PlanSortFieldsRefID, PlanSortFieldsStatus, PlanSortFieldsUpdatedAt, PlanSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e PlanSortFields) String() string {
	return string(e)
}

func (e *PlanSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlanSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlanSortFields", str)
	}
	return nil
}

func (e PlanSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PriceSortFields string

const (
	PriceSortFieldsBillingID     PriceSortFields = "billingId"
	PriceSortFieldsBillingModel  PriceSortFields = "billingModel"
	PriceSortFieldsBillingPeriod PriceSortFields = "billingPeriod"
	PriceSortFieldsCreatedAt     PriceSortFields = "createdAt"
	PriceSortFieldsID            PriceSortFields = "id"
	PriceSortFieldsTiersMode     PriceSortFields = "tiersMode"
)

var AllPriceSortFields = []PriceSortFields{
	PriceSortFieldsBillingID,
	PriceSortFieldsBillingModel,
	PriceSortFieldsBillingPeriod,
	PriceSortFieldsCreatedAt,
	PriceSortFieldsID,
	PriceSortFieldsTiersMode,
}

func (e PriceSortFields) IsValid() bool {
	switch e {
	case PriceSortFieldsBillingID, PriceSortFieldsBillingModel, PriceSortFieldsBillingPeriod, PriceSortFieldsCreatedAt, PriceSortFieldsID, PriceSortFieldsTiersMode:
		return true
	}
	return false
}

func (e PriceSortFields) String() string {
	return string(e)
}

func (e *PriceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceSortFields", str)
	}
	return nil
}

func (e PriceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pricing Type.
type PricingType string

const (
	PricingTypeCustom PricingType = "CUSTOM"
	PricingTypeFree   PricingType = "FREE"
	PricingTypePaid   PricingType = "PAID"
)

var AllPricingType = []PricingType{
	PricingTypeCustom,
	PricingTypeFree,
	PricingTypePaid,
}

func (e PricingType) IsValid() bool {
	switch e {
	case PricingTypeCustom, PricingTypeFree, PricingTypePaid:
		return true
	}
	return false
}

func (e PricingType) String() string {
	return string(e)
}

func (e *PricingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PricingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PricingType", str)
	}
	return nil
}

func (e PricingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductSortFields string

const (
	ProductSortFieldsAwsMarketplaceProductCode ProductSortFields = "awsMarketplaceProductCode"
	ProductSortFieldsAwsMarketplaceProductID   ProductSortFields = "awsMarketplaceProductId"
	ProductSortFieldsCreatedAt                 ProductSortFields = "createdAt"
	ProductSortFieldsDescription               ProductSortFields = "description"
	ProductSortFieldsDisplayName               ProductSortFields = "displayName"
	ProductSortFieldsEnvironmentID             ProductSortFields = "environmentId"
	ProductSortFieldsID                        ProductSortFields = "id"
	ProductSortFieldsIsDefaultProduct          ProductSortFields = "isDefaultProduct"
	ProductSortFieldsRefID                     ProductSortFields = "refId"
	ProductSortFieldsUpdatedAt                 ProductSortFields = "updatedAt"
)

var AllProductSortFields = []ProductSortFields{
	ProductSortFieldsAwsMarketplaceProductCode,
	ProductSortFieldsAwsMarketplaceProductID,
	ProductSortFieldsCreatedAt,
	ProductSortFieldsDescription,
	ProductSortFieldsDisplayName,
	ProductSortFieldsEnvironmentID,
	ProductSortFieldsID,
	ProductSortFieldsIsDefaultProduct,
	ProductSortFieldsRefID,
	ProductSortFieldsUpdatedAt,
}

func (e ProductSortFields) IsValid() bool {
	switch e {
	case ProductSortFieldsAwsMarketplaceProductCode, ProductSortFieldsAwsMarketplaceProductID, ProductSortFieldsCreatedAt, ProductSortFieldsDescription, ProductSortFieldsDisplayName, ProductSortFieldsEnvironmentID, ProductSortFieldsID, ProductSortFieldsIsDefaultProduct, ProductSortFieldsRefID, ProductSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e ProductSortFields) String() string {
	return string(e)
}

func (e *ProductSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortFields", str)
	}
	return nil
}

func (e ProductSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Promotional entitlement duration
type PromotionalEntitlementPeriod string

const (
	PromotionalEntitlementPeriodCustom   PromotionalEntitlementPeriod = "CUSTOM"
	PromotionalEntitlementPeriodLifetime PromotionalEntitlementPeriod = "LIFETIME"
	PromotionalEntitlementPeriodOneMonth PromotionalEntitlementPeriod = "ONE_MONTH"
	PromotionalEntitlementPeriodOneWeek  PromotionalEntitlementPeriod = "ONE_WEEK"
	PromotionalEntitlementPeriodOneYear  PromotionalEntitlementPeriod = "ONE_YEAR"
	PromotionalEntitlementPeriodSixMonth PromotionalEntitlementPeriod = "SIX_MONTH"
)

var AllPromotionalEntitlementPeriod = []PromotionalEntitlementPeriod{
	PromotionalEntitlementPeriodCustom,
	PromotionalEntitlementPeriodLifetime,
	PromotionalEntitlementPeriodOneMonth,
	PromotionalEntitlementPeriodOneWeek,
	PromotionalEntitlementPeriodOneYear,
	PromotionalEntitlementPeriodSixMonth,
}

func (e PromotionalEntitlementPeriod) IsValid() bool {
	switch e {
	case PromotionalEntitlementPeriodCustom, PromotionalEntitlementPeriodLifetime, PromotionalEntitlementPeriodOneMonth, PromotionalEntitlementPeriodOneWeek, PromotionalEntitlementPeriodOneYear, PromotionalEntitlementPeriodSixMonth:
		return true
	}
	return false
}

func (e PromotionalEntitlementPeriod) String() string {
	return string(e)
}

func (e *PromotionalEntitlementPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementPeriod", str)
	}
	return nil
}

func (e PromotionalEntitlementPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PromotionalEntitlementSortFields string

const (
	PromotionalEntitlementSortFieldsCreatedAt     PromotionalEntitlementSortFields = "createdAt"
	PromotionalEntitlementSortFieldsEnvironmentID PromotionalEntitlementSortFields = "environmentId"
	PromotionalEntitlementSortFieldsID            PromotionalEntitlementSortFields = "id"
	PromotionalEntitlementSortFieldsStatus        PromotionalEntitlementSortFields = "status"
	PromotionalEntitlementSortFieldsUpdatedAt     PromotionalEntitlementSortFields = "updatedAt"
)

var AllPromotionalEntitlementSortFields = []PromotionalEntitlementSortFields{
	PromotionalEntitlementSortFieldsCreatedAt,
	PromotionalEntitlementSortFieldsEnvironmentID,
	PromotionalEntitlementSortFieldsID,
	PromotionalEntitlementSortFieldsStatus,
	PromotionalEntitlementSortFieldsUpdatedAt,
}

func (e PromotionalEntitlementSortFields) IsValid() bool {
	switch e {
	case PromotionalEntitlementSortFieldsCreatedAt, PromotionalEntitlementSortFieldsEnvironmentID, PromotionalEntitlementSortFieldsID, PromotionalEntitlementSortFieldsStatus, PromotionalEntitlementSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e PromotionalEntitlementSortFields) String() string {
	return string(e)
}

func (e *PromotionalEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementSortFields", str)
	}
	return nil
}

func (e PromotionalEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Promotional entitlement status
type PromotionalEntitlementStatus string

const (
	PromotionalEntitlementStatusActive  PromotionalEntitlementStatus = "Active"
	PromotionalEntitlementStatusExpired PromotionalEntitlementStatus = "Expired"
	PromotionalEntitlementStatusPaused  PromotionalEntitlementStatus = "Paused"
)

var AllPromotionalEntitlementStatus = []PromotionalEntitlementStatus{
	PromotionalEntitlementStatusActive,
	PromotionalEntitlementStatusExpired,
	PromotionalEntitlementStatusPaused,
}

func (e PromotionalEntitlementStatus) IsValid() bool {
	switch e {
	case PromotionalEntitlementStatusActive, PromotionalEntitlementStatusExpired, PromotionalEntitlementStatusPaused:
		return true
	}
	return false
}

func (e PromotionalEntitlementStatus) String() string {
	return string(e)
}

func (e *PromotionalEntitlementStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementStatus", str)
	}
	return nil
}

func (e PromotionalEntitlementStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProrationBehavior string

const (
	ProrationBehaviorCreateProrations   ProrationBehavior = "CREATE_PRORATIONS"
	ProrationBehaviorInvoiceImmediately ProrationBehavior = "INVOICE_IMMEDIATELY"
)

var AllProrationBehavior = []ProrationBehavior{
	ProrationBehaviorCreateProrations,
	ProrationBehaviorInvoiceImmediately,
}

func (e ProrationBehavior) IsValid() bool {
	switch e {
	case ProrationBehaviorCreateProrations, ProrationBehaviorInvoiceImmediately:
		return true
	}
	return false
}

func (e ProrationBehavior) String() string {
	return string(e)
}

func (e *ProrationBehavior) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProrationBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProrationBehavior", str)
	}
	return nil
}

func (e ProrationBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Provision subscription status
type ProvisionSubscriptionStatus string

const (
	ProvisionSubscriptionStatusPaymentRequired ProvisionSubscriptionStatus = "PAYMENT_REQUIRED"
	ProvisionSubscriptionStatusSuccess         ProvisionSubscriptionStatus = "SUCCESS"
)

var AllProvisionSubscriptionStatus = []ProvisionSubscriptionStatus{
	ProvisionSubscriptionStatusPaymentRequired,
	ProvisionSubscriptionStatusSuccess,
}

func (e ProvisionSubscriptionStatus) IsValid() bool {
	switch e {
	case ProvisionSubscriptionStatusPaymentRequired, ProvisionSubscriptionStatusSuccess:
		return true
	}
	return false
}

func (e ProvisionSubscriptionStatus) String() string {
	return string(e)
}

func (e *ProvisionSubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisionSubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisionSubscriptionStatus", str)
	}
	return nil
}

func (e ProvisionSubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PublishMigrationType
type PublishMigrationType string

const (
	PublishMigrationTypeAllCustomers PublishMigrationType = "ALL_CUSTOMERS"
	PublishMigrationTypeNewCustomers PublishMigrationType = "NEW_CUSTOMERS"
)

var AllPublishMigrationType = []PublishMigrationType{
	PublishMigrationTypeAllCustomers,
	PublishMigrationTypeNewCustomers,
}

func (e PublishMigrationType) IsValid() bool {
	switch e {
	case PublishMigrationTypeAllCustomers, PublishMigrationTypeNewCustomers:
		return true
	}
	return false
}

func (e PublishMigrationType) String() string {
	return string(e)
}

func (e *PublishMigrationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishMigrationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishMigrationType", str)
	}
	return nil
}

func (e PublishMigrationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort Directions
type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort Nulls Options
type SortNulls string

const (
	SortNullsNullsFirst SortNulls = "NULLS_FIRST"
	SortNullsNullsLast  SortNulls = "NULLS_LAST"
)

var AllSortNulls = []SortNulls{
	SortNullsNullsFirst,
	SortNullsNullsLast,
}

func (e SortNulls) IsValid() bool {
	switch e {
	case SortNullsNullsFirst, SortNullsNullsLast:
		return true
	}
	return false
}

func (e SortNulls) String() string {
	return string(e)
}

func (e *SortNulls) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortNulls(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortNulls", str)
	}
	return nil
}

func (e SortNulls) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SourceType string

const (
	SourceTypeJsClientSdk            SourceType = "JS_CLIENT_SDK"
	SourceTypeNodeServerSdk          SourceType = "NODE_SERVER_SDK"
	SourceTypePersistentCacheService SourceType = "PERSISTENT_CACHE_SERVICE"
)

var AllSourceType = []SourceType{
	SourceTypeJsClientSdk,
	SourceTypeNodeServerSdk,
	SourceTypePersistentCacheService,
}

func (e SourceType) IsValid() bool {
	switch e {
	case SourceTypeJsClientSdk, SourceTypeNodeServerSdk, SourceTypePersistentCacheService:
		return true
	}
	return false
}

func (e SourceType) String() string {
	return string(e)
}

func (e *SourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SourceType", str)
	}
	return nil
}

func (e SourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionAddonSortFields string

const (
	SubscriptionAddonSortFieldsCreatedAt SubscriptionAddonSortFields = "createdAt"
	SubscriptionAddonSortFieldsID        SubscriptionAddonSortFields = "id"
	SubscriptionAddonSortFieldsQuantity  SubscriptionAddonSortFields = "quantity"
	SubscriptionAddonSortFieldsUpdatedAt SubscriptionAddonSortFields = "updatedAt"
)

var AllSubscriptionAddonSortFields = []SubscriptionAddonSortFields{
	SubscriptionAddonSortFieldsCreatedAt,
	SubscriptionAddonSortFieldsID,
	SubscriptionAddonSortFieldsQuantity,
	SubscriptionAddonSortFieldsUpdatedAt,
}

func (e SubscriptionAddonSortFields) IsValid() bool {
	switch e {
	case SubscriptionAddonSortFieldsCreatedAt, SubscriptionAddonSortFieldsID, SubscriptionAddonSortFieldsQuantity, SubscriptionAddonSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionAddonSortFields) String() string {
	return string(e)
}

func (e *SubscriptionAddonSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionAddonSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionAddonSortFields", str)
	}
	return nil
}

func (e SubscriptionAddonSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription cancellation status
type SubscriptionCancelReason string

const (
	SubscriptionCancelReasonCancelledByBilling    SubscriptionCancelReason = "CancelledByBilling"
	SubscriptionCancelReasonCustomerArchived      SubscriptionCancelReason = "CustomerArchived"
	SubscriptionCancelReasonDetachBilling         SubscriptionCancelReason = "DetachBilling"
	SubscriptionCancelReasonExpired               SubscriptionCancelReason = "Expired"
	SubscriptionCancelReasonImmediate             SubscriptionCancelReason = "Immediate"
	SubscriptionCancelReasonPendingPaymentExpired SubscriptionCancelReason = "PendingPaymentExpired"
	SubscriptionCancelReasonScheduledCancellation SubscriptionCancelReason = "ScheduledCancellation"
	SubscriptionCancelReasonTrialConverted        SubscriptionCancelReason = "TrialConverted"
	SubscriptionCancelReasonTrialEnded            SubscriptionCancelReason = "TrialEnded"
	SubscriptionCancelReasonUpgradeOrDowngrade    SubscriptionCancelReason = "UpgradeOrDowngrade"
)

var AllSubscriptionCancelReason = []SubscriptionCancelReason{
	SubscriptionCancelReasonCancelledByBilling,
	SubscriptionCancelReasonCustomerArchived,
	SubscriptionCancelReasonDetachBilling,
	SubscriptionCancelReasonExpired,
	SubscriptionCancelReasonImmediate,
	SubscriptionCancelReasonPendingPaymentExpired,
	SubscriptionCancelReasonScheduledCancellation,
	SubscriptionCancelReasonTrialConverted,
	SubscriptionCancelReasonTrialEnded,
	SubscriptionCancelReasonUpgradeOrDowngrade,
}

func (e SubscriptionCancelReason) IsValid() bool {
	switch e {
	case SubscriptionCancelReasonCancelledByBilling, SubscriptionCancelReasonCustomerArchived, SubscriptionCancelReasonDetachBilling, SubscriptionCancelReasonExpired, SubscriptionCancelReasonImmediate, SubscriptionCancelReasonPendingPaymentExpired, SubscriptionCancelReasonScheduledCancellation, SubscriptionCancelReasonTrialConverted, SubscriptionCancelReasonTrialEnded, SubscriptionCancelReasonUpgradeOrDowngrade:
		return true
	}
	return false
}

func (e SubscriptionCancelReason) String() string {
	return string(e)
}

func (e *SubscriptionCancelReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancelReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancelReason", str)
	}
	return nil
}

func (e SubscriptionCancelReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionCancellationAction string

const (
	SubscriptionCancellationActionDefault            SubscriptionCancellationAction = "DEFAULT"
	SubscriptionCancellationActionRevokeEntitlements SubscriptionCancellationAction = "REVOKE_ENTITLEMENTS"
)

var AllSubscriptionCancellationAction = []SubscriptionCancellationAction{
	SubscriptionCancellationActionDefault,
	SubscriptionCancellationActionRevokeEntitlements,
}

func (e SubscriptionCancellationAction) IsValid() bool {
	switch e {
	case SubscriptionCancellationActionDefault, SubscriptionCancellationActionRevokeEntitlements:
		return true
	}
	return false
}

func (e SubscriptionCancellationAction) String() string {
	return string(e)
}

func (e *SubscriptionCancellationAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancellationAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancellationAction", str)
	}
	return nil
}

func (e SubscriptionCancellationAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionCancellationTime string

const (
	SubscriptionCancellationTimeEndOfBillingPeriod SubscriptionCancellationTime = "END_OF_BILLING_PERIOD"
	SubscriptionCancellationTimeImmediate          SubscriptionCancellationTime = "IMMEDIATE"
	SubscriptionCancellationTimeSpecificDate       SubscriptionCancellationTime = "SPECIFIC_DATE"
)

var AllSubscriptionCancellationTime = []SubscriptionCancellationTime{
	SubscriptionCancellationTimeEndOfBillingPeriod,
	SubscriptionCancellationTimeImmediate,
	SubscriptionCancellationTimeSpecificDate,
}

func (e SubscriptionCancellationTime) IsValid() bool {
	switch e {
	case SubscriptionCancellationTimeEndOfBillingPeriod, SubscriptionCancellationTimeImmediate, SubscriptionCancellationTimeSpecificDate:
		return true
	}
	return false
}

func (e SubscriptionCancellationTime) String() string {
	return string(e)
}

func (e *SubscriptionCancellationTime) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancellationTime(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancellationTime", str)
	}
	return nil
}

func (e SubscriptionCancellationTime) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription decision strategy
type SubscriptionDecisionStrategy string

const (
	SubscriptionDecisionStrategyPredefinedFreePlan          SubscriptionDecisionStrategy = "PREDEFINED_FREE_PLAN"
	SubscriptionDecisionStrategyPredefinedTrialPlan         SubscriptionDecisionStrategy = "PREDEFINED_TRIAL_PLAN"
	SubscriptionDecisionStrategyRequestedPlan               SubscriptionDecisionStrategy = "REQUESTED_PLAN"
	SubscriptionDecisionStrategySkippedSubscriptionCreation SubscriptionDecisionStrategy = "SKIPPED_SUBSCRIPTION_CREATION"
)

var AllSubscriptionDecisionStrategy = []SubscriptionDecisionStrategy{
	SubscriptionDecisionStrategyPredefinedFreePlan,
	SubscriptionDecisionStrategyPredefinedTrialPlan,
	SubscriptionDecisionStrategyRequestedPlan,
	SubscriptionDecisionStrategySkippedSubscriptionCreation,
}

func (e SubscriptionDecisionStrategy) IsValid() bool {
	switch e {
	case SubscriptionDecisionStrategyPredefinedFreePlan, SubscriptionDecisionStrategyPredefinedTrialPlan, SubscriptionDecisionStrategyRequestedPlan, SubscriptionDecisionStrategySkippedSubscriptionCreation:
		return true
	}
	return false
}

func (e SubscriptionDecisionStrategy) String() string {
	return string(e)
}

func (e *SubscriptionDecisionStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionDecisionStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionDecisionStrategy", str)
	}
	return nil
}

func (e SubscriptionDecisionStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionEndSetup string

const (
	SubscriptionEndSetupCancelSubscription SubscriptionEndSetup = "CANCEL_SUBSCRIPTION"
	SubscriptionEndSetupDowngradeToFree    SubscriptionEndSetup = "DOWNGRADE_TO_FREE"
)

var AllSubscriptionEndSetup = []SubscriptionEndSetup{
	SubscriptionEndSetupCancelSubscription,
	SubscriptionEndSetupDowngradeToFree,
}

func (e SubscriptionEndSetup) IsValid() bool {
	switch e {
	case SubscriptionEndSetupCancelSubscription, SubscriptionEndSetupDowngradeToFree:
		return true
	}
	return false
}

func (e SubscriptionEndSetup) String() string {
	return string(e)
}

func (e *SubscriptionEndSetup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEndSetup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionEndSetup", str)
	}
	return nil
}

func (e SubscriptionEndSetup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionEntitlementSortFields string

const (
	SubscriptionEntitlementSortFieldsCreatedAt      SubscriptionEntitlementSortFields = "createdAt"
	SubscriptionEntitlementSortFieldsEnvironmentID  SubscriptionEntitlementSortFields = "environmentId"
	SubscriptionEntitlementSortFieldsID             SubscriptionEntitlementSortFields = "id"
	SubscriptionEntitlementSortFieldsSubscriptionID SubscriptionEntitlementSortFields = "subscriptionId"
	SubscriptionEntitlementSortFieldsUpdatedAt      SubscriptionEntitlementSortFields = "updatedAt"
)

var AllSubscriptionEntitlementSortFields = []SubscriptionEntitlementSortFields{
	SubscriptionEntitlementSortFieldsCreatedAt,
	SubscriptionEntitlementSortFieldsEnvironmentID,
	SubscriptionEntitlementSortFieldsID,
	SubscriptionEntitlementSortFieldsSubscriptionID,
	SubscriptionEntitlementSortFieldsUpdatedAt,
}

func (e SubscriptionEntitlementSortFields) IsValid() bool {
	switch e {
	case SubscriptionEntitlementSortFieldsCreatedAt, SubscriptionEntitlementSortFieldsEnvironmentID, SubscriptionEntitlementSortFieldsID, SubscriptionEntitlementSortFieldsSubscriptionID, SubscriptionEntitlementSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionEntitlementSortFields) String() string {
	return string(e)
}

func (e *SubscriptionEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionEntitlementSortFields", str)
	}
	return nil
}

func (e SubscriptionEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SubscriptionInvoice status
type SubscriptionInvoiceStatus string

const (
	SubscriptionInvoiceStatusCanceled SubscriptionInvoiceStatus = "CANCELED"
	SubscriptionInvoiceStatusOpen     SubscriptionInvoiceStatus = "OPEN"
	SubscriptionInvoiceStatusPaid     SubscriptionInvoiceStatus = "PAID"
)

var AllSubscriptionInvoiceStatus = []SubscriptionInvoiceStatus{
	SubscriptionInvoiceStatusCanceled,
	SubscriptionInvoiceStatusOpen,
	SubscriptionInvoiceStatusPaid,
}

func (e SubscriptionInvoiceStatus) IsValid() bool {
	switch e {
	case SubscriptionInvoiceStatusCanceled, SubscriptionInvoiceStatusOpen, SubscriptionInvoiceStatusPaid:
		return true
	}
	return false
}

func (e SubscriptionInvoiceStatus) String() string {
	return string(e)
}

func (e *SubscriptionInvoiceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionInvoiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionInvoiceStatus", str)
	}
	return nil
}

func (e SubscriptionInvoiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionMigrationTaskSortFields string

const (
	SubscriptionMigrationTaskSortFieldsCreatedAt     SubscriptionMigrationTaskSortFields = "createdAt"
	SubscriptionMigrationTaskSortFieldsEnvironmentID SubscriptionMigrationTaskSortFields = "environmentId"
	SubscriptionMigrationTaskSortFieldsID            SubscriptionMigrationTaskSortFields = "id"
	SubscriptionMigrationTaskSortFieldsStatus        SubscriptionMigrationTaskSortFields = "status"
	SubscriptionMigrationTaskSortFieldsTaskType      SubscriptionMigrationTaskSortFields = "taskType"
)

var AllSubscriptionMigrationTaskSortFields = []SubscriptionMigrationTaskSortFields{
	SubscriptionMigrationTaskSortFieldsCreatedAt,
	SubscriptionMigrationTaskSortFieldsEnvironmentID,
	SubscriptionMigrationTaskSortFieldsID,
	SubscriptionMigrationTaskSortFieldsStatus,
	SubscriptionMigrationTaskSortFieldsTaskType,
}

func (e SubscriptionMigrationTaskSortFields) IsValid() bool {
	switch e {
	case SubscriptionMigrationTaskSortFieldsCreatedAt, SubscriptionMigrationTaskSortFieldsEnvironmentID, SubscriptionMigrationTaskSortFieldsID, SubscriptionMigrationTaskSortFieldsStatus, SubscriptionMigrationTaskSortFieldsTaskType:
		return true
	}
	return false
}

func (e SubscriptionMigrationTaskSortFields) String() string {
	return string(e)
}

func (e *SubscriptionMigrationTaskSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionMigrationTaskSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionMigrationTaskSortFields", str)
	}
	return nil
}

func (e SubscriptionMigrationTaskSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Set non immediate cancellation time (atm supported only for stripe integration)
type SubscriptionMigrationTime string

const (
	SubscriptionMigrationTimeEndOfBillingPeriod SubscriptionMigrationTime = "END_OF_BILLING_PERIOD"
	SubscriptionMigrationTimeImmediate          SubscriptionMigrationTime = "IMMEDIATE"
)

var AllSubscriptionMigrationTime = []SubscriptionMigrationTime{
	SubscriptionMigrationTimeEndOfBillingPeriod,
	SubscriptionMigrationTimeImmediate,
}

func (e SubscriptionMigrationTime) IsValid() bool {
	switch e {
	case SubscriptionMigrationTimeEndOfBillingPeriod, SubscriptionMigrationTimeImmediate:
		return true
	}
	return false
}

func (e SubscriptionMigrationTime) String() string {
	return string(e)
}

func (e *SubscriptionMigrationTime) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionMigrationTime(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionMigrationTime", str)
	}
	return nil
}

func (e SubscriptionMigrationTime) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionPriceSortFields string

const (
	SubscriptionPriceSortFieldsBillingModel SubscriptionPriceSortFields = "billingModel"
	SubscriptionPriceSortFieldsCreatedAt    SubscriptionPriceSortFields = "createdAt"
	SubscriptionPriceSortFieldsFeatureID    SubscriptionPriceSortFields = "featureId"
	SubscriptionPriceSortFieldsID           SubscriptionPriceSortFields = "id"
	SubscriptionPriceSortFieldsUpdatedAt    SubscriptionPriceSortFields = "updatedAt"
	SubscriptionPriceSortFieldsUsageLimit   SubscriptionPriceSortFields = "usageLimit"
)

var AllSubscriptionPriceSortFields = []SubscriptionPriceSortFields{
	SubscriptionPriceSortFieldsBillingModel,
	SubscriptionPriceSortFieldsCreatedAt,
	SubscriptionPriceSortFieldsFeatureID,
	SubscriptionPriceSortFieldsID,
	SubscriptionPriceSortFieldsUpdatedAt,
	SubscriptionPriceSortFieldsUsageLimit,
}

func (e SubscriptionPriceSortFields) IsValid() bool {
	switch e {
	case SubscriptionPriceSortFieldsBillingModel, SubscriptionPriceSortFieldsCreatedAt, SubscriptionPriceSortFieldsFeatureID, SubscriptionPriceSortFieldsID, SubscriptionPriceSortFieldsUpdatedAt, SubscriptionPriceSortFieldsUsageLimit:
		return true
	}
	return false
}

func (e SubscriptionPriceSortFields) String() string {
	return string(e)
}

func (e *SubscriptionPriceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPriceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionPriceSortFields", str)
	}
	return nil
}

func (e SubscriptionPriceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription scheduled schedule status
type SubscriptionScheduleStatus string

const (
	SubscriptionScheduleStatusCanceled       SubscriptionScheduleStatus = "Canceled"
	SubscriptionScheduleStatusDone           SubscriptionScheduleStatus = "Done"
	SubscriptionScheduleStatusFailed         SubscriptionScheduleStatus = "Failed"
	SubscriptionScheduleStatusPendingPayment SubscriptionScheduleStatus = "PendingPayment"
	SubscriptionScheduleStatusScheduled      SubscriptionScheduleStatus = "Scheduled"
)

var AllSubscriptionScheduleStatus = []SubscriptionScheduleStatus{
	SubscriptionScheduleStatusCanceled,
	SubscriptionScheduleStatusDone,
	SubscriptionScheduleStatusFailed,
	SubscriptionScheduleStatusPendingPayment,
	SubscriptionScheduleStatusScheduled,
}

func (e SubscriptionScheduleStatus) IsValid() bool {
	switch e {
	case SubscriptionScheduleStatusCanceled, SubscriptionScheduleStatusDone, SubscriptionScheduleStatusFailed, SubscriptionScheduleStatusPendingPayment, SubscriptionScheduleStatusScheduled:
		return true
	}
	return false
}

func (e SubscriptionScheduleStatus) String() string {
	return string(e)
}

func (e *SubscriptionScheduleStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionScheduleStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionScheduleStatus", str)
	}
	return nil
}

func (e SubscriptionScheduleStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription scheduled schedule type
type SubscriptionScheduleType string

const (
	SubscriptionScheduleTypeAddon           SubscriptionScheduleType = "Addon"
	SubscriptionScheduleTypeBillingPeriod   SubscriptionScheduleType = "BillingPeriod"
	SubscriptionScheduleTypeDowngrade       SubscriptionScheduleType = "Downgrade"
	SubscriptionScheduleTypeMigrateToLatest SubscriptionScheduleType = "MigrateToLatest"
	SubscriptionScheduleTypeUnitAmount      SubscriptionScheduleType = "UnitAmount"
)

var AllSubscriptionScheduleType = []SubscriptionScheduleType{
	SubscriptionScheduleTypeAddon,
	SubscriptionScheduleTypeBillingPeriod,
	SubscriptionScheduleTypeDowngrade,
	SubscriptionScheduleTypeMigrateToLatest,
	SubscriptionScheduleTypeUnitAmount,
}

func (e SubscriptionScheduleType) IsValid() bool {
	switch e {
	case SubscriptionScheduleTypeAddon, SubscriptionScheduleTypeBillingPeriod, SubscriptionScheduleTypeDowngrade, SubscriptionScheduleTypeMigrateToLatest, SubscriptionScheduleTypeUnitAmount:
		return true
	}
	return false
}

func (e SubscriptionScheduleType) String() string {
	return string(e)
}

func (e *SubscriptionScheduleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionScheduleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionScheduleType", str)
	}
	return nil
}

func (e SubscriptionScheduleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionStartSetup string

const (
	SubscriptionStartSetupFreePlan      SubscriptionStartSetup = "FREE_PLAN"
	SubscriptionStartSetupPlanSelection SubscriptionStartSetup = "PLAN_SELECTION"
	SubscriptionStartSetupTrialPeriod   SubscriptionStartSetup = "TRIAL_PERIOD"
)

var AllSubscriptionStartSetup = []SubscriptionStartSetup{
	SubscriptionStartSetupFreePlan,
	SubscriptionStartSetupPlanSelection,
	SubscriptionStartSetupTrialPeriod,
}

func (e SubscriptionStartSetup) IsValid() bool {
	switch e {
	case SubscriptionStartSetupFreePlan, SubscriptionStartSetupPlanSelection, SubscriptionStartSetupTrialPeriod:
		return true
	}
	return false
}

func (e SubscriptionStartSetup) String() string {
	return string(e)
}

func (e *SubscriptionStartSetup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStartSetup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionStartSetup", str)
	}
	return nil
}

func (e SubscriptionStartSetup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription status
type SubscriptionStatus string

const (
	SubscriptionStatusActive         SubscriptionStatus = "ACTIVE"
	SubscriptionStatusCanceled       SubscriptionStatus = "CANCELED"
	SubscriptionStatusExpired        SubscriptionStatus = "EXPIRED"
	SubscriptionStatusInTrial        SubscriptionStatus = "IN_TRIAL"
	SubscriptionStatusNotStarted     SubscriptionStatus = "NOT_STARTED"
	SubscriptionStatusPaymentPending SubscriptionStatus = "PAYMENT_PENDING"
)

var AllSubscriptionStatus = []SubscriptionStatus{
	SubscriptionStatusActive,
	SubscriptionStatusCanceled,
	SubscriptionStatusExpired,
	SubscriptionStatusInTrial,
	SubscriptionStatusNotStarted,
	SubscriptionStatusPaymentPending,
}

func (e SubscriptionStatus) IsValid() bool {
	switch e {
	case SubscriptionStatusActive, SubscriptionStatusCanceled, SubscriptionStatusExpired, SubscriptionStatusInTrial, SubscriptionStatusNotStarted, SubscriptionStatusPaymentPending:
		return true
	}
	return false
}

func (e SubscriptionStatus) String() string {
	return string(e)
}

func (e *SubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionStatus", str)
	}
	return nil
}

func (e SubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of the integration sync
type SyncStatus string

const (
	SyncStatusError          SyncStatus = "ERROR"
	SyncStatusNoSyncRequired SyncStatus = "NO_SYNC_REQUIRED"
	SyncStatusPending        SyncStatus = "PENDING"
	SyncStatusSuccess        SyncStatus = "SUCCESS"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusError,
	SyncStatusNoSyncRequired,
	SyncStatusPending,
	SyncStatusSuccess,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusError, SyncStatusNoSyncRequired, SyncStatusPending, SyncStatusSuccess:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TaskStatus string

const (
	TaskStatusCanceled        TaskStatus = "CANCELED"
	TaskStatusCompleted       TaskStatus = "COMPLETED"
	TaskStatusFailed          TaskStatus = "FAILED"
	TaskStatusInProgress      TaskStatus = "IN_PROGRESS"
	TaskStatusPartiallyFailed TaskStatus = "PARTIALLY_FAILED"
	TaskStatusPending         TaskStatus = "PENDING"
)

var AllTaskStatus = []TaskStatus{
	TaskStatusCanceled,
	TaskStatusCompleted,
	TaskStatusFailed,
	TaskStatusInProgress,
	TaskStatusPartiallyFailed,
	TaskStatusPending,
}

func (e TaskStatus) IsValid() bool {
	switch e {
	case TaskStatusCanceled, TaskStatusCompleted, TaskStatusFailed, TaskStatusInProgress, TaskStatusPartiallyFailed, TaskStatusPending:
		return true
	}
	return false
}

func (e TaskStatus) String() string {
	return string(e)
}

func (e *TaskStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskStatus", str)
	}
	return nil
}

func (e TaskStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TaskType string

const (
	TaskTypeImportIntegrationCatalog     TaskType = "IMPORT_INTEGRATION_CATALOG"
	TaskTypeImportIntegrationCustomers   TaskType = "IMPORT_INTEGRATION_CUSTOMERS"
	TaskTypeImportSubscriptionsBulk      TaskType = "IMPORT_SUBSCRIPTIONS_BULK"
	TaskTypeRecalculateBatchEntitlements TaskType = "RECALCULATE_BATCH_ENTITLEMENTS"
	TaskTypeRecalculateEntitlements      TaskType = "RECALCULATE_ENTITLEMENTS"
	TaskTypeResyncIntegration            TaskType = "RESYNC_INTEGRATION"
	TaskTypeSubscriptionMigration        TaskType = "SUBSCRIPTION_MIGRATION"
	TaskTypeSubscriptionMigrationV2      TaskType = "SUBSCRIPTION_MIGRATION_V2"
)

var AllTaskType = []TaskType{
	TaskTypeImportIntegrationCatalog,
	TaskTypeImportIntegrationCustomers,
	TaskTypeImportSubscriptionsBulk,
	TaskTypeRecalculateBatchEntitlements,
	TaskTypeRecalculateEntitlements,
	TaskTypeResyncIntegration,
	TaskTypeSubscriptionMigration,
	TaskTypeSubscriptionMigrationV2,
}

func (e TaskType) IsValid() bool {
	switch e {
	case TaskTypeImportIntegrationCatalog, TaskTypeImportIntegrationCustomers, TaskTypeImportSubscriptionsBulk, TaskTypeRecalculateBatchEntitlements, TaskTypeRecalculateEntitlements, TaskTypeResyncIntegration, TaskTypeSubscriptionMigration, TaskTypeSubscriptionMigrationV2:
		return true
	}
	return false
}

func (e TaskType) String() string {
	return string(e)
}

func (e *TaskType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskType", str)
	}
	return nil
}

func (e TaskType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Tiers mode.
type TiersMode string

const (
	TiersModeGraduated TiersMode = "GRADUATED"
	TiersModeVolume    TiersMode = "VOLUME"
)

var AllTiersMode = []TiersMode{
	TiersModeGraduated,
	TiersModeVolume,
}

func (e TiersMode) IsValid() bool {
	switch e {
	case TiersModeGraduated, TiersModeVolume:
		return true
	}
	return false
}

func (e TiersMode) String() string {
	return string(e)
}

func (e *TiersMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TiersMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TiersMode", str)
	}
	return nil
}

func (e TiersMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// day or month.
type TrialPeriodUnits string

const (
	TrialPeriodUnitsDay   TrialPeriodUnits = "DAY"
	TrialPeriodUnitsMonth TrialPeriodUnits = "MONTH"
)

var AllTrialPeriodUnits = []TrialPeriodUnits{
	TrialPeriodUnitsDay,
	TrialPeriodUnitsMonth,
}

func (e TrialPeriodUnits) IsValid() bool {
	switch e {
	case TrialPeriodUnitsDay, TrialPeriodUnitsMonth:
		return true
	}
	return false
}

func (e TrialPeriodUnits) String() string {
	return string(e)
}

func (e *TrialPeriodUnits) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrialPeriodUnits(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrialPeriodUnits", str)
	}
	return nil
}

func (e TrialPeriodUnits) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsageMeasurementSortFields string

const (
	UsageMeasurementSortFieldsCreatedAt     UsageMeasurementSortFields = "createdAt"
	UsageMeasurementSortFieldsEnvironmentID UsageMeasurementSortFields = "environmentId"
	UsageMeasurementSortFieldsID            UsageMeasurementSortFields = "id"
)

var AllUsageMeasurementSortFields = []UsageMeasurementSortFields{
	UsageMeasurementSortFieldsCreatedAt,
	UsageMeasurementSortFieldsEnvironmentID,
	UsageMeasurementSortFieldsID,
}

func (e UsageMeasurementSortFields) IsValid() bool {
	switch e {
	case UsageMeasurementSortFieldsCreatedAt, UsageMeasurementSortFieldsEnvironmentID, UsageMeasurementSortFieldsID:
		return true
	}
	return false
}

func (e UsageMeasurementSortFields) String() string {
	return string(e)
}

func (e *UsageMeasurementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageMeasurementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageMeasurementSortFields", str)
	}
	return nil
}

func (e UsageMeasurementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsageUpdateBehavior string

const (
	UsageUpdateBehaviorDelta UsageUpdateBehavior = "DELTA"
	UsageUpdateBehaviorSet   UsageUpdateBehavior = "SET"
)

var AllUsageUpdateBehavior = []UsageUpdateBehavior{
	UsageUpdateBehaviorDelta,
	UsageUpdateBehaviorSet,
}

func (e UsageUpdateBehavior) IsValid() bool {
	switch e {
	case UsageUpdateBehaviorDelta, UsageUpdateBehaviorSet:
		return true
	}
	return false
}

func (e UsageUpdateBehavior) String() string {
	return string(e)
}

func (e *UsageUpdateBehavior) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageUpdateBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageUpdateBehavior", str)
	}
	return nil
}

func (e UsageUpdateBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VendorIdentifier string

const (
	VendorIdentifierAwsMarketplace VendorIdentifier = "AWS_MARKETPLACE"
	VendorIdentifierHubspot        VendorIdentifier = "HUBSPOT"
	VendorIdentifierStripe         VendorIdentifier = "STRIPE"
	VendorIdentifierZuora          VendorIdentifier = "ZUORA"
)

var AllVendorIdentifier = []VendorIdentifier{
	VendorIdentifierAwsMarketplace,
	VendorIdentifierHubspot,
	VendorIdentifierStripe,
	VendorIdentifierZuora,
}

func (e VendorIdentifier) IsValid() bool {
	switch e {
	case VendorIdentifierAwsMarketplace, VendorIdentifierHubspot, VendorIdentifierStripe, VendorIdentifierZuora:
		return true
	}
	return false
}

func (e VendorIdentifier) String() string {
	return string(e)
}

func (e *VendorIdentifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorIdentifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorIdentifier", str)
	}
	return nil
}

func (e VendorIdentifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Weekly reset period according to configuration
type WeeklyAccordingTo string

const (
	WeeklyAccordingToEveryFriday       WeeklyAccordingTo = "EveryFriday"
	WeeklyAccordingToEveryMonday       WeeklyAccordingTo = "EveryMonday"
	WeeklyAccordingToEverySaturday     WeeklyAccordingTo = "EverySaturday"
	WeeklyAccordingToEverySunday       WeeklyAccordingTo = "EverySunday"
	WeeklyAccordingToEveryThursday     WeeklyAccordingTo = "EveryThursday"
	WeeklyAccordingToEveryTuesday      WeeklyAccordingTo = "EveryTuesday"
	WeeklyAccordingToEveryWednesday    WeeklyAccordingTo = "EveryWednesday"
	WeeklyAccordingToSubscriptionStart WeeklyAccordingTo = "SubscriptionStart"
)

var AllWeeklyAccordingTo = []WeeklyAccordingTo{
	WeeklyAccordingToEveryFriday,
	WeeklyAccordingToEveryMonday,
	WeeklyAccordingToEverySaturday,
	WeeklyAccordingToEverySunday,
	WeeklyAccordingToEveryThursday,
	WeeklyAccordingToEveryTuesday,
	WeeklyAccordingToEveryWednesday,
	WeeklyAccordingToSubscriptionStart,
}

func (e WeeklyAccordingTo) IsValid() bool {
	switch e {
	case WeeklyAccordingToEveryFriday, WeeklyAccordingToEveryMonday, WeeklyAccordingToEverySaturday, WeeklyAccordingToEverySunday, WeeklyAccordingToEveryThursday, WeeklyAccordingToEveryTuesday, WeeklyAccordingToEveryWednesday, WeeklyAccordingToSubscriptionStart:
		return true
	}
	return false
}

func (e WeeklyAccordingTo) String() string {
	return string(e)
}

func (e *WeeklyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WeeklyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WeeklyAccordingTo", str)
	}
	return nil
}

func (e WeeklyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The widget type
type WidgetType string

const (
	WidgetTypeCheckout       WidgetType = "CHECKOUT"
	WidgetTypeCustomerPortal WidgetType = "CUSTOMER_PORTAL"
	WidgetTypePaywall        WidgetType = "PAYWALL"
)

var AllWidgetType = []WidgetType{
	WidgetTypeCheckout,
	WidgetTypeCustomerPortal,
	WidgetTypePaywall,
}

func (e WidgetType) IsValid() bool {
	switch e {
	case WidgetTypeCheckout, WidgetTypeCustomerPortal, WidgetTypePaywall:
		return true
	}
	return false
}

func (e WidgetType) String() string {
	return string(e)
}

func (e *WidgetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetType", str)
	}
	return nil
}

func (e WidgetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Yearly reset period according to configuration
type YearlyAccordingTo string

const (
	YearlyAccordingToSubscriptionStart YearlyAccordingTo = "SubscriptionStart"
)

var AllYearlyAccordingTo = []YearlyAccordingTo{
	YearlyAccordingToSubscriptionStart,
}

func (e YearlyAccordingTo) IsValid() bool {
	switch e {
	case YearlyAccordingToSubscriptionStart:
		return true
	}
	return false
}

func (e YearlyAccordingTo) String() string {
	return string(e)
}

func (e *YearlyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = YearlyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid YearlyAccordingTo", str)
	}
	return nil
}

func (e YearlyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The group of the experiment
type ExperimentGroupType string

const (
	ExperimentGroupTypeControl ExperimentGroupType = "CONTROL"
	ExperimentGroupTypeVariant ExperimentGroupType = "VARIANT"
)

var AllExperimentGroupType = []ExperimentGroupType{
	ExperimentGroupTypeControl,
	ExperimentGroupTypeVariant,
}

func (e ExperimentGroupType) IsValid() bool {
	switch e {
	case ExperimentGroupTypeControl, ExperimentGroupTypeVariant:
		return true
	}
	return false
}

func (e ExperimentGroupType) String() string {
	return string(e)
}

func (e *ExperimentGroupType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentGroupType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid experimentGroupType", str)
	}
	return nil
}

func (e ExperimentGroupType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
