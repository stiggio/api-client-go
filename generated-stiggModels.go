// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package stigg

import (
	"fmt"
	"io"
	"strconv"
)

// Configuration for the integration
type Credentials interface {
	IsCredentials()
}

// Union of all payment method forms for different billing providers
type PaymentMethodForm interface {
	IsPaymentMethodForm()
}

// Reset period config
type ResetPeriodConfiguration interface {
	IsResetPeriodConfiguration()
}

// Schedule variables by the type of the schedule
type ScheduleVariables interface {
	IsScheduleVariables()
}

// Data of the sync revision
type SyncRevisionData interface {
	IsSyncRevisionData()
}

// access roles
type AccessRoles struct {
	// Account level access of the user
	AccountRole AccountAccessRole `json:"accountRole"`
	// Non-production environment level access of the user
	NonProductionRole EnvironmentAccessRole `json:"nonProductionRole"`
	// Production environment level access of the user
	ProductionRole EnvironmentAccessRole `json:"productionRole"`
}

// An account object
type Account struct {
	// Access method for new users to join this account. 'invite only' is the default
	AccessMethod AccountAccessMethod `json:"accessMethod"`
	// Email domain to be used for SSO and authorized domain configuration
	AccountEmailDomain *string `json:"accountEmailDomain"`
	// The status of the account, e.g. "ACTIVE" or "BLOCKED"
	AccountStatus *AccountStatus `json:"accountStatus"`
	// Default SSO roles for the account
	DefaultSSORoles *AccessRoles `json:"defaultSSORoles"`
	// The display name of the account
	DisplayName string `json:"displayName"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Whether SAML SSO is enabled for the account
	SamlEnabled *bool `json:"samlEnabled"`
	// The billing anchor for the subscription, e.g. "START_OF_THE_MONTH"
	SubscriptionBillingAnchor *BillingAnchor `json:"subscriptionBillingAnchor"`
	// The proration behavior for the subscription, e.g. "CREATE_PRORATIONS"
	SubscriptionProrationBehavior *ProrationBehavior `json:"subscriptionProrationBehavior"`
	// The timezone of the account, e.g. "America/New_York"
	Timezone *string `json:"timezone"`
}

type AccountNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type AddCompatibleAddonsToPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

// Additional meta data change
type AdditionalMetaDataChange struct {
	// The value after the change
	After map[string]interface{} `json:"after"`
	// The value before the change
	Before map[string]interface{} `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Addon
type Addon struct {
	// The additional meta data of the package
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The billing link url of the package
	BillingLinkURL *string `json:"billingLinkUrl"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// List of addons the addon is dependant on
	Dependencies []*Addon `json:"dependencies"`
	// The description of the package
	Description *string `json:"description"`
	// The display name of the package
	DisplayName string `json:"displayName"`
	// Draft details for the addon
	DraftDetails *PackageDraftDetails `json:"draftDetails"`
	// Draft summary for the addon
	DraftSummary *PackageDraftSummary `json:"draftSummary"`
	// List of entitlements for the addon
	Entitlements []*PackageEntitlement `json:"entitlements"`
	Environment  Environment           `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Indicates if the addon has subscriptions
	HasSubscriptions bool `json:"hasSubscriptions"`
	// List of hidden widgets of the package
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Indicates if the package is the latest version
	IsLatest *bool `json:"isLatest"`
	// The maximum quantity of this addon that can be added to a subscription
	MaxQuantity *float64 `json:"maxQuantity"`
	// The overage billing period of the package
	OverageBillingPeriod *OverageBillingPeriod `json:"overageBillingPeriod"`
	// List of overage prices of the package
	OveragePrices []*Price `json:"overagePrices"`
	Prices        []*Price `json:"prices"`
	// The pricing type of the package
	PricingType *PricingType `json:"pricingType"`
	Product     *Product     `json:"product"`
	// The product id of the package
	ProductID *string `json:"productId"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// The status of the package
	Status PackageStatus `json:"status"`
	// List of sync states for the addon
	SyncStates []*SyncState `json:"syncStates"`
	// The type of the package
	Type string `json:"type"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The version number of the package
	VersionNumber int64 `json:"versionNumber"`
}

type AddonAggregateGroupBy struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	IsLatest      *bool          `json:"isLatest"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

// Archive addon input
type AddonArchiveInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Addon id
	RefID string `json:"refId"`
}

// List of active entities associated with an addon
type AddonAssociatedEntities struct {
	// List of package groups that have this addon
	PackageGroups []*AddonAssociatedPackageGroup `json:"packageGroups"`
	// List of published or draft plans
	Plans []*AddonAssociatedPlan `json:"plans"`
}

// Query associated entities input
type AddonAssociatedEntitiesInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Addon refId
	RefID string `json:"refId"`
}

// List of package groups associated with an addon
type AddonAssociatedPackageGroup struct {
	// Package group display name
	DisplayName string `json:"displayName"`
	// Package group id
	PackageGroupID string `json:"packageGroupId"`
}

// List of plans associated with an addon
type AddonAssociatedPlan struct {
	// Plan display name
	DisplayName string `json:"displayName"`
	// Plan refId
	RefID string `json:"refId"`
	// Plan status
	Status PackageStatus `json:"status"`
	// Plan version
	VersionNumber float64 `json:"versionNumber"`
}

type AddonAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type AddonChangeVariables struct {
	AddonRefID  string  `json:"addonRefId"`
	NewQuantity float64 `json:"newQuantity"`
}

func (AddonChangeVariables) IsScheduleVariables() {}

type AddonConnection struct {
	// Array of edges.
	Edges []*AddonEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type AddonCountAggregate struct {
	BillingID     *int64 `json:"billingId"`
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	DisplayName   *int64 `json:"displayName"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	IsLatest      *int64 `json:"isLatest"`
	PricingType   *int64 `json:"pricingType"`
	ProductID     *int64 `json:"productId"`
	RefID         *int64 `json:"refId"`
	Status        *int64 `json:"status"`
	UpdatedAt     *int64 `json:"updatedAt"`
	VersionNumber *int64 `json:"versionNumber"`
}

// Input for creating an addon
type AddonCreateInput struct {
	// The additional meta data of the package
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The AWS marketplace plan dimension of the package
	AwsMarketplacePlanDimension *string `json:"awsMarketplacePlanDimension,omitempty"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId,omitempty"`
	// List of addon ids this addon should be dependant on
	Dependencies []string `json:"dependencies,omitempty"`
	// The description of the package
	Description *string `json:"description,omitempty"`
	// The display name of the package
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// List of hidden widgets of the package
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets,omitempty"`
	// The maximum quantity of this addon that can be added to a subscription
	MaxQuantity *float64 `json:"maxQuantity,omitempty"`
	// The pricing type of the package
	PricingType *PricingType `json:"pricingType,omitempty"`
	// The product id of the package
	ProductID string `json:"productId"`
	// The unique identifier for the entity
	RefID *string `json:"refId,omitempty"`
	// The status of the package
	Status *PackageStatus `json:"status,omitempty"`
}

// Addon dependency change
type AddonDependencyChange struct {
	// The value after the change
	After *Addon `json:"after"`
	// The value before the change
	Before *Addon `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

type AddonEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Addon
	Node Addon `json:"node"`
}

type AddonFilter struct {
	And           []*AddonFilter                 `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison          `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison          `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*AddonFilter                 `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type AddonMaxAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonMinAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type AddonPriceOverrideChangeVariables struct {
	AddonRefID string  `json:"addonRefId"`
	FeatureID  *string `json:"featureId"`
}

func (AddonPriceOverrideChangeVariables) IsScheduleVariables() {}

type AddonSort struct {
	Direction SortDirection   `json:"direction"`
	Field     AddonSortFields `json:"field"`
	Nulls     *SortNulls      `json:"nulls,omitempty"`
}

type AddonSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

// Un-archive addon input
type AddonUnArchiveInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Add-on ID to unarchive
	ID string `json:"id"`
}

type AddonUpdateInput struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	BillingID          *string                `json:"billingId,omitempty"`
	// List of addon ids this addon should be dependant on
	Dependencies      []string     `json:"dependencies,omitempty"`
	Description       *string      `json:"description,omitempty"`
	DisplayName       *string      `json:"displayName,omitempty"`
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets,omitempty"`
	ID                string       `json:"id"`
	// The maximum quantity of this addon that can be added to a subscription
	MaxQuantity *float64       `json:"maxQuantity,omitempty"`
	Status      *PackageStatus `json:"status,omitempty"`
}

// Customers address
type Address struct {
	// Address line 1
	AddressLine1 *string `json:"addressLine1,omitempty"`
	// Address line 2
	AddressLine2 *string `json:"addressLine2,omitempty"`
	// City
	City *string `json:"city,omitempty"`
	// Country
	Country *string `json:"country,omitempty"`
	// Phone number
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// Postal code
	PostalCode *string `json:"postalCode,omitempty"`
	// State
	State *string `json:"state,omitempty"`
}

// Aggregated events by customer
type AggregatedEventsByCustomer struct {
	// Aggregated usage data for the customer
	AggregatedUsage []*CustomerAggregatedUsage `json:"aggregatedUsage"`
}

// Input parameters for aggregating events by customer
type AggregatedEventsByCustomerInput struct {
	// Meter aggregation
	Aggregation MeterAggregation `json:"aggregation"`
	// Customer id
	CustomerID *string `json:"customerId,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// List of event filters
	Filters []*MeterFilterDefinitionInput `json:"filters"`
}

// Defines how meter data should be aggregated using a specified aggregation function
type Aggregation struct {
	// The data field to which the aggregation function will be applied
	Field *string `json:"field"`
	// The aggregation function to apply to the data (e.g. SUM, AVG, COUNT)
	Function AggregationFunction `json:"function"`
}

// API key
type APIKey struct {
	// Unique identifier for the entity
	ID string `json:"id"`
	// The type of API key
	KeyType APIKeyType `json:"keyType"`
	// The token of the API key
	Token string `json:"token"`
}

type APIKeyFilter struct {
	And []*APIKeyFilter       `json:"and,omitempty"`
	ID  *UUIDFilterComparison `json:"id,omitempty"`
	Or  []*APIKeyFilter       `json:"or,omitempty"`
}

type APIKeySort struct {
	Direction SortDirection    `json:"direction"`
	Field     APIKeySortFields `json:"field"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

// Apply subscription response
type ApplySubscription struct {
	// The updated entitlements
	Entitlements []*Entitlement `json:"entitlements"`
	// The updated subscription
	Subscription *CustomerSubscription `json:"subscription"`
}

// Apply subscription changes input
type ApplySubscriptionInput struct {
	AdditionalMetaData map[string]interface{}    `json:"additionalMetaData,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon            *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	AwaitPaymentConfirmation *bool                    `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures         []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingCountryCode       *string                  `json:"billingCountryCode,omitempty"`
	BillingID                *string                  `json:"billingId,omitempty"`
	BillingInformation       *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod            *BillingPeriod           `json:"billingPeriod,omitempty"`
	// Budget configuration
	Budget *BudgetConfigurationInput `json:"budget,omitempty"`
	// Customer ID
	CustomerID string `json:"customerId"`
	// The minimum spend configuration
	MinimumSpend *SubscriptionMinimumSpendValueInput `json:"minimumSpend,omitempty"`
	// Paying customer ID
	PayingCustomerID *string `json:"payingCustomerId,omitempty"`
	// Subscription payment collection method
	PaymentCollectionMethod *PaymentCollectionMethod `json:"paymentCollectionMethod,omitempty"`
	// Payment method ID
	PaymentMethodID *string `json:"paymentMethodId,omitempty"`
	PlanID          string  `json:"planId"`
	// Override the price of the subscription
	PriceOverrides   []*PriceOverrideInput `json:"priceOverrides,omitempty"`
	PromotionCode    *string               `json:"promotionCode,omitempty"`
	ResourceID       *string               `json:"resourceId,omitempty"`
	SalesforceID     *string               `json:"salesforceId,omitempty"`
	ScheduleStrategy *ScheduleStrategy     `json:"scheduleStrategy,omitempty"`
	// Should skip trial
	SkipTrial                  *bool                            `json:"skipTrial,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

// Archive a coupon input
type ArchiveCouponInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
}

type ArchiveCustomerInput struct {
	// Customer slug
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Input for archiving an environment
type ArchiveEnvironmentInput struct {
	// Unique identifier for the entity
	ID *string `json:"id,omitempty"`
	// A unique identifier for the environment
	Slug *string `json:"slug,omitempty"`
}

// Input for archiving a feature group
type ArchiveFeatureGroupInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The feature group id
	FeatureGroupID string `json:"featureGroupId"`
}

// Input for archiving a feature
type ArchiveFeatureInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Unique identifier for the entity
	ID string `json:"id"`
}

// The input type for archiving a package group
type ArchivePackageGroup struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The id of the package group
	PackageGroupID string `json:"packageGroupId"`
}

// Input for archiving a plan
type ArchivePlanInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Plan ID to archive
	ID string `json:"id"`
}

// Result of an asynchronous import task
type AsyncTaskResult struct {
	// Unique identifier for the import task
	TaskID string `json:"taskId"`
}

// Input for attaching a payment method to a customer
type AttachCustomerPaymentMethodInput struct {
	// The currency to use for this payment method (only used for Zuora)
	BillingCurrency *Currency `json:"billingCurrency,omitempty"`
	// Customer slug
	CustomerID *string `json:"customerId,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The billing integration to use for this payment method
	IntegrationID *string `json:"integrationId,omitempty"`
	// Billing provider payment method id
	PaymentMethodID string `json:"paymentMethodId"`
	// Customer slug
	RefID *string `json:"refId,omitempty"`
	// The integration type to attach the payment method to
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

// An Auth0 application object
type Auth0ApplicationDto struct {
	// ID of the Auth0 application
	AppID string `json:"appId"`
	// Name of the Auth0 application
	Name string `json:"name"`
	// Type of the Auth0 application
	Type *Auth0ApplicationType `json:"type"`
}

// An Auth0 configuration object
type Auth0Credentials struct {
	// ID of the Auth0 application
	ApplicationID string `json:"applicationId"`
	// Name of the Auth0 application
	ApplicationName string `json:"applicationName"`
	// Type of the Auth0 application
	ApplicationType Auth0ApplicationType `json:"applicationType"`
	// Domain of the Auth0 client
	ClientDomain string `json:"clientDomain"`
	// ID of the Auth0 client
	ClientID string `json:"clientId"`
	// Secret of the Auth0 client
	ClientSecret string `json:"clientSecret"`
	// Initial plan ID for individual subscriptions
	IndividualInitialPlanID *string `json:"individualInitialPlanId"`
	// Setup for starting individual subscriptions
	IndividualSubscriptionStartSetup *SubscriptionStartSetup `json:"individualSubscriptionStartSetup"`
	// Initial plan ID for organization subscriptions
	OrganizationInitialPlanID *string `json:"organizationInitialPlanId"`
	// Setup for starting organization subscriptions
	OrganizationSubscriptionStartSetup *SubscriptionStartSetup `json:"organizationSubscriptionStartSetup"`
}

func (Auth0Credentials) IsCredentials() {}

// Input configuration for Auth0 integration
type Auth0CredentialsInput struct {
	// ID of the Auth0 application
	ApplicationID string `json:"applicationId"`
	// Name of the Auth0 application
	ApplicationName string `json:"applicationName"`
	// Type of the Auth0 application
	ApplicationType Auth0ApplicationType `json:"applicationType"`
	// Domain of the Auth0 client
	ClientDomain string `json:"clientDomain"`
	// ID of the Auth0 client
	ClientID string `json:"clientId"`
	// Secret of the Auth0 client
	ClientSecret string `json:"clientSecret"`
	// Initial plan ID for individual subscriptions
	IndividualInitialPlanID *string `json:"individualInitialPlanId,omitempty"`
	// Setup for starting individual subscriptions
	IndividualSubscriptionStartSetup *SubscriptionStartSetup `json:"individualSubscriptionStartSetup,omitempty"`
	// Initial plan ID for organization subscriptions
	OrganizationInitialPlanID *string `json:"organizationInitialPlanId,omitempty"`
	// Setup for starting organization subscriptions
	OrganizationSubscriptionStartSetup *SubscriptionStartSetup `json:"organizationSubscriptionStartSetup,omitempty"`
}

// Auto cancellation rule - when subscription for source plan is cancelled, other subscriptions to target plan would be cancelled as well
type AutoCancellationRule struct {
	// Source plan
	SourcePlan Plan `json:"sourcePlan"`
	// Target plan
	TargetPlan Plan `json:"targetPlan"`
}

// Input for auto cancellation rule
type AutoCancellationRuleInput struct {
	// ID of the source plan
	SourcePlanID string `json:"sourcePlanId"`
	// ID of the target plan
	TargetPlanID string `json:"targetPlanId"`
}

// AWS Marketplace product dimension (maps to Stigg plan)
type AwsDimension struct {
	// Detailed description of the dimension offering
	Description string `json:"description"`
	// Unique identifier for the dimension in AWS
	Key string `json:"key"`
	// Dimension name in AWS Marketplace
	Name string `json:"name"`
	// Mapped Stigg plan ID for feature access control
	StiggPlanID *string `json:"stiggPlanId"`
	// Mapped Stigg plan name for entitlement management
	StiggPlanName *string `json:"stiggPlanName"`
	// Dimension type (e.g., Contracts)
	Type string `json:"type"`
	// Unit of measurement for the dimension
	Unit string `json:"unit"`
}

// AWS Marketplace integration configuration for SaaS contract pricing model
type AwsMarketplaceCredentials struct {
	// AWS IAM role ARN with StiggAWSMarketplaceAccess policy attached
	AwsRoleArn string `json:"awsRoleArn"`
}

func (AwsMarketplaceCredentials) IsCredentials() {}

// AWS Marketplace integration configuration for SaaS contract pricing model
type AwsMarketplaceCredentialsInput struct {
	// AWS IAM role ARN with StiggAWSMarketplaceAccess policy attached
	AwsRoleArn string `json:"awsRoleArn"`
}

// AWS Marketplace SaaS product configuration
type AwsProduct struct {
	// Product description as shown in AWS Marketplace catalog
	Description string `json:"description"`
	// Product logo URL in AWS Marketplace listing
	LogoURL *string `json:"logoUrl"`
	// AWS Marketplace product code identifier
	ProductCode string `json:"productCode"`
	// Unique identifier for the product in Stigg
	ProductID string `json:"productId"`
	// Mapped Stigg product ID for entitlement management
	StiggProductID *string `json:"stiggProductId"`
	// Reference ID for the mapped Stigg product
	StiggProductRefID *string `json:"stiggProductRefId"`
	// Product name as displayed in AWS Marketplace
	Title string `json:"title"`
	// Product visibility status in AWS Marketplace catalog
	Visibility string `json:"visibility"`
}

type BaseError struct {
	Code string `json:"code"`
}

// Base plan change
type BasePlanChange struct {
	// The value after the change
	After *Addon `json:"after"`
	// The value before the change
	Before *Addon `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Google BigQuery integration configuration object
type BigQueryCredentials struct {
	// Airbyte connection ID for BigQuery
	AirbyteConnectionID *string `json:"airbyteConnectionId"`
	// Airbyte destination ID for BigQuery
	AirbyteDestinationID *string `json:"airbyteDestinationId"`
	// JSON credentials for Google BigQuery
	CredentialsJSON string `json:"credentialsJson"`
	// ID of the BigQuery dataset
	DatasetID string `json:"datasetId"`
	// Location of the BigQuery dataset
	DatasetLocation string `json:"datasetLocation"`
	// Name of the Google Cloud Storage bucket
	GcsBucketName string `json:"gcsBucketName"`
	// Path within the Google Cloud Storage bucket
	GcsBucketPath string `json:"gcsBucketPath"`
	// Access ID for the HMAC key
	HmacKeyAccessID string `json:"hmacKeyAccessId"`
	// Secret for the HMAC key
	HmacKeySecret string `json:"hmacKeySecret"`
	// ID of the Google Cloud project
	ProjectID string `json:"projectId"`
}

func (BigQueryCredentials) IsCredentials() {}

// Input configuration for Google BigQuery integration
type BigQueryCredentialsInput struct {
	// JSON credentials for Google BigQuery
	CredentialsJSON string `json:"credentialsJson"`
	// ID of the BigQuery dataset
	DatasetID string `json:"datasetId"`
	// Location of the BigQuery dataset
	DatasetLocation string `json:"datasetLocation"`
	// Name of the Google Cloud Storage bucket
	GcsBucketName string `json:"gcsBucketName"`
	// Path within the Google Cloud Storage bucket
	GcsBucketPath string `json:"gcsBucketPath"`
	// Access ID for the HMAC key
	HmacKeyAccessID string `json:"hmacKeyAccessId"`
	// Secret for the HMAC key
	HmacKeySecret string `json:"hmacKeySecret"`
	// ID of the Google Cloud project
	ProjectID string `json:"projectId"`
}

type BillableFeature struct {
	FeatureID string  `json:"featureId"`
	Quantity  float64 `json:"quantity"`
}

type BillableFeatureInput struct {
	FeatureID string  `json:"featureId"`
	Quantity  float64 `json:"quantity"`
}

type BillingAddress struct {
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	Line1      *string `json:"line1,omitempty"`
	Line2      *string `json:"line2,omitempty"`
	PostalCode *string `json:"postalCode,omitempty"`
	State      *string `json:"state,omitempty"`
}

type BillingCadenceFilterComparison struct {
	Eq       *BillingCadence  `json:"eq,omitempty"`
	Gt       *BillingCadence  `json:"gt,omitempty"`
	Gte      *BillingCadence  `json:"gte,omitempty"`
	ILike    *BillingCadence  `json:"iLike,omitempty"`
	In       []BillingCadence `json:"in,omitempty"`
	Is       *bool            `json:"is,omitempty"`
	IsNot    *bool            `json:"isNot,omitempty"`
	Like     *BillingCadence  `json:"like,omitempty"`
	Lt       *BillingCadence  `json:"lt,omitempty"`
	Lte      *BillingCadence  `json:"lte,omitempty"`
	Neq      *BillingCadence  `json:"neq,omitempty"`
	NotILike *BillingCadence  `json:"notILike,omitempty"`
	NotIn    []BillingCadence `json:"notIn,omitempty"`
	NotLike  *BillingCadence  `json:"notLike,omitempty"`
}

type BillingModelFilterComparison struct {
	Eq       *BillingModel  `json:"eq,omitempty"`
	Gt       *BillingModel  `json:"gt,omitempty"`
	Gte      *BillingModel  `json:"gte,omitempty"`
	ILike    *BillingModel  `json:"iLike,omitempty"`
	In       []BillingModel `json:"in,omitempty"`
	Is       *bool          `json:"is,omitempty"`
	IsNot    *bool          `json:"isNot,omitempty"`
	Like     *BillingModel  `json:"like,omitempty"`
	Lt       *BillingModel  `json:"lt,omitempty"`
	Lte      *BillingModel  `json:"lte,omitempty"`
	Neq      *BillingModel  `json:"neq,omitempty"`
	NotILike *BillingModel  `json:"notILike,omitempty"`
	NotIn    []BillingModel `json:"notIn,omitempty"`
	NotLike  *BillingModel  `json:"notLike,omitempty"`
}

type BillingPeriodChangeVariables struct {
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
}

func (BillingPeriodChangeVariables) IsScheduleVariables() {}

type BillingPeriodFilterComparison struct {
	Eq       *BillingPeriod  `json:"eq,omitempty"`
	Gt       *BillingPeriod  `json:"gt,omitempty"`
	Gte      *BillingPeriod  `json:"gte,omitempty"`
	ILike    *BillingPeriod  `json:"iLike,omitempty"`
	In       []BillingPeriod `json:"in,omitempty"`
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Like     *BillingPeriod  `json:"like,omitempty"`
	Lt       *BillingPeriod  `json:"lt,omitempty"`
	Lte      *BillingPeriod  `json:"lte,omitempty"`
	Neq      *BillingPeriod  `json:"neq,omitempty"`
	NotILike *BillingPeriod  `json:"notILike,omitempty"`
	NotIn    []BillingPeriod `json:"notIn,omitempty"`
	NotLike  *BillingPeriod  `json:"notLike,omitempty"`
}

type BooleanFieldComparison struct {
	Is    *bool `json:"is,omitempty"`
	IsNot *bool `json:"isNot,omitempty"`
}

// Budget configuration
type BudgetConfiguration struct {
	// Indicates the behavior of the budget when the limit is exceeded. If true, the limit is a soft limit, if false, the limit is a hard limit. Default is false.
	HasSoftLimit bool `json:"hasSoftLimit"`
	// The maximum spending limit
	Limit float64 `json:"limit"`
}

// Budget configuration input
type BudgetConfigurationInput struct {
	// Indicates the behavior of the budget when the limit is exceeded. If true, the limit is a soft limit, if false, the limit is a hard limit. Default is false.
	HasSoftLimit bool `json:"hasSoftLimit"`
	// The maximum spending limit
	Limit float64 `json:"limit"`
}

type CannotDeleteCustomerError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CannotDeleteFeatureError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type ChangingPayingCustomerIsNotSupportedError struct {
	Code                    string `json:"code"`
	CurrentPayingCustomerID string `json:"currentPayingCustomerId"`
	IsValidationError       bool   `json:"isValidationError"`
	NewPayingCustomerID     string `json:"newPayingCustomerId"`
}

// Input for triggering an immediate usage charge for a subscription
type ChargeSubscriptionUsage struct {
	// The ID of the invoice in the billing integration. If null then no invoice was created
	InvoiceBillingID *string `json:"invoiceBillingId"`
	// The date from which the usage was calculated to
	PeriodEnd string `json:"periodEnd"`
	// The date from which the usage was calculated from
	PeriodStart string `json:"periodStart"`
	// The subscription reference id for which the usage was charged
	SubscriptionID string `json:"subscriptionId"`
	// An array of the usage items which were charged
	UsageCharged []*UsageCharged `json:"usageCharged"`
}

// Input for triggering an immediate usage charge for a subscription
type ChargeSubscriptionUsageInput struct {
	// The id of the subscriptions environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The subscription reference id to charge usage for
	SubscriptionID string `json:"subscriptionId"`
	// The end date until which to calculate the usage
	UntilDate *string `json:"untilDate,omitempty"`
}

// Checkout billing integration
type CheckoutBillingIntegration struct {
	// The billing vendor identifier
	BillingIdentifier BillingVendorIdentifier `json:"billingIdentifier"`
	// The billing credentials
	Credentials CheckoutCredentials `json:"credentials"`
}

// Color settings for the checkout widget.
type CheckoutColorPalette struct {
	// Main background color of the checkout UI.
	BackgroundColor *string `json:"backgroundColor"`
	// Color used for borders and dividers in the checkout widget.
	BorderColor *string `json:"borderColor"`
	// Primary accent color used in the checkout UI.
	Primary *string `json:"primary"`
	// Background color for the order summary section.
	SummaryBackgroundColor *string `json:"summaryBackgroundColor"`
	// Text color used throughout the checkout widget.
	TextColor *string `json:"textColor"`
}

// Checkout-specific widget configuration.
type CheckoutConfiguration struct {
	// Dynamic content configuration like optional data fields.
	Content *CheckoutContent `json:"content"`
	// Custom CSS styles to override default checkout UI styles.
	CustomCSS *string `json:"customCss"`
	// Custom color palette used in the checkout UI.
	Palette *CheckoutColorPalette `json:"palette"`
	// Font and text styling used in the checkout widget.
	Typography *TypographyConfiguration `json:"typography"`
}

// Input for setting up the checkout widget’s design.
type CheckoutConfigurationInput struct {
	// Additional content settings such as form fields.
	Content *CheckoutContentInput `json:"content,omitempty"`
	// Custom styles to override default checkout appearance.
	CustomCSS *string `json:"customCss,omitempty"`
	// Color palette settings for the checkout process.
	Palette *CheckoutPaletteInput `json:"palette,omitempty"`
	// Typography options for headings and text in checkout.
	Typography *TypographyConfigurationInput `json:"typography,omitempty"`
}

// Content-related settings for the checkout experience.
type CheckoutContent struct {
	// Specifies whether the customers phone number should be collected during checkout.
	CollectPhoneNumber *bool `json:"collectPhoneNumber"`
}

// Input for content customization in the checkout process.
type CheckoutContentInput struct {
	// Indicates whether the checkout form should ask for a phone number.
	CollectPhoneNumber *bool `json:"collectPhoneNumber,omitempty"`
}

// Checkout credentials
type CheckoutCredentials struct {
	// The account ID
	AccountID string `json:"accountId"`
	// The public key
	PublicKey string `json:"publicKey"`
}

type CheckoutOptions struct {
	AllowPromoCodes       *bool   `json:"allowPromoCodes,omitempty"`
	AllowTaxIDCollection  *bool   `json:"allowTaxIdCollection,omitempty"`
	CancelURL             string  `json:"cancelUrl"`
	CollectBillingAddress *bool   `json:"collectBillingAddress,omitempty"`
	CollectPhoneNumber    *bool   `json:"collectPhoneNumber,omitempty"`
	ReferenceID           *string `json:"referenceId,omitempty"`
	SuccessURL            string  `json:"successUrl"`
}

// Input for customizing checkout color scheme.
type CheckoutPaletteInput struct {
	// Background color of the widget.
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// Color applied to widget borders or separators.
	BorderColor *string `json:"borderColor,omitempty"`
	// Primary accent color used throughout the widget.
	Primary *string `json:"primary,omitempty"`
	// Background color for the order summary section during checkout.
	SummaryBackgroundColor *string `json:"summaryBackgroundColor,omitempty"`
	// Default color used for text content.
	TextColor *string `json:"textColor,omitempty"`
}

// Checkout state response
type CheckoutState struct {
	// The current active subscription
	ActiveSubscription *CustomerSubscription `json:"activeSubscription"`
	// Current billing integration
	BillingIntegration CheckoutBillingIntegration `json:"billingIntegration"`
	// The checkout configuration
	Configuration *CheckoutConfiguration `json:"configuration"`
	// The customer
	Customer Customer `json:"customer"`
	// The selected plan
	Plan Plan `json:"plan"`
	// The resource
	Resource *CustomerResource `json:"resource"`
	// The billing integration setup secret
	SetupSecret string `json:"setupSecret"`
}

// Checkout state input
type CheckoutStateInput struct {
	// The billing country code of the customer to checkout
	BillingCountryCode *string `json:"billingCountryCode,omitempty"`
	// Customer ID
	CustomerID string `json:"customerId"`
	// The plan ID to checkout
	PlanID string `json:"planId"`
	// The Plan Product ID to checkout
	ProductID *string `json:"productId,omitempty"`
	// The resource ID to checkout
	ResourceID *string `json:"resourceId,omitempty"`
}

// Input for clearing a customers persistent cache.
type ClearCustomerPersistentCacheInput struct {
	// The unique identifier of the customer whose cache should be cleared.
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The resource ID scoped to the customer.
	ResourceID *string `json:"resourceId,omitempty"`
}

// Coupons
type Coupon struct {
	// Metadata associated with the entity
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// Fixed amount discounts in different currencies
	AmountsOff []*Money `json:"amountsOff"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The URL to the entity in the billing provider
	BillingLinkURL *string `json:"billingLinkUrl"`
	// Timestamp of when the record was created
	CreatedAt string      `json:"createdAt"`
	Customers []*Customer `json:"customers"`
	// Description of the coupon
	Description *string `json:"description"`
	// Discount value of the coupon (deprecated)
	DiscountValue float64 `json:"discountValue"`
	// Duration of the coupon validity in months
	DurationInMonths *float64     `json:"durationInMonths"`
	Environment      *Environment `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Name of the coupon
	Name string `json:"name"`
	// Percentage discount off the original price
	PercentOff *float64 `json:"percentOff"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// The source of the coupon
	Source CouponSource `json:"source"`
	// Current status of the coupon
	Status     CouponStatus `json:"status"`
	SyncStates []*SyncState `json:"syncStates"`
	// Type of the coupon (percentage or fixed amount)
	Type CouponType `json:"type"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
}

type CouponAggregateGroupBy struct {
	BillingID     *string       `json:"billingId"`
	CreatedAt     *string       `json:"createdAt"`
	Description   *string       `json:"description"`
	EnvironmentID *string       `json:"environmentId"`
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Source        *CouponSource `json:"source"`
	Status        *CouponStatus `json:"status"`
	Type          *CouponType   `json:"type"`
	UpdatedAt     *string       `json:"updatedAt"`
}

// Coupon change variables
type CouponChangeVariables struct {
	// Coupon reference ID
	CouponID string `json:"couponId"`
}

func (CouponChangeVariables) IsScheduleVariables() {}

type CouponConnection struct {
	// Array of edges.
	Edges []*CouponEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CouponCountAggregate struct {
	BillingID     *int64 `json:"billingId"`
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Name          *int64 `json:"name"`
	RefID         *int64 `json:"refId"`
	Source        *int64 `json:"source"`
	Status        *int64 `json:"status"`
	Type          *int64 `json:"type"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type CouponEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Coupon
	Node Coupon `json:"node"`
}

type CouponFilter struct {
	And           []*CouponFilter               `json:"and,omitempty"`
	BillingID     *StringFieldComparison        `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison          `json:"createdAt,omitempty"`
	Customers     *CouponFilterCustomerFilter   `json:"customers,omitempty"`
	Description   *StringFieldComparison        `json:"description,omitempty"`
	EnvironmentID *UUIDFilterComparison         `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison         `json:"id,omitempty"`
	Name          *StringFieldComparison        `json:"name,omitempty"`
	Or            []*CouponFilter               `json:"or,omitempty"`
	RefID         *StringFieldComparison        `json:"refId,omitempty"`
	Source        *CouponSourceFilterComparison `json:"source,omitempty"`
	Status        *CouponStatusFilterComparison `json:"status,omitempty"`
	Type          *CouponTypeFilterComparison   `json:"type,omitempty"`
	UpdatedAt     *DateFieldComparison          `json:"updatedAt,omitempty"`
}

type CouponFilterCustomerFilter struct {
	And                  []*CouponFilterCustomerFilter        `json:"and,omitempty"`
	BillingID            *StringFieldComparison               `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                 `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison               `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison               `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison               `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison               `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                 `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison               `json:"email,omitempty"`
	EnvironmentID        *UUIDFilterComparison                `json:"environmentId,omitempty"`
	ID                   *UUIDFilterComparison                `json:"id,omitempty"`
	Name                 *StringFieldComparison               `json:"name,omitempty"`
	Or                   []*CouponFilterCustomerFilter        `json:"or,omitempty"`
	RefID                *StringFieldComparison               `json:"refId,omitempty"`
	SalesforceID         *StringFieldComparison               `json:"salesforceId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                 `json:"updatedAt,omitempty"`
}

type CouponMaxAggregate struct {
	BillingID     *string       `json:"billingId"`
	CreatedAt     *string       `json:"createdAt"`
	Description   *string       `json:"description"`
	EnvironmentID *string       `json:"environmentId"`
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Source        *CouponSource `json:"source"`
	Status        *CouponStatus `json:"status"`
	Type          *CouponType   `json:"type"`
	UpdatedAt     *string       `json:"updatedAt"`
}

type CouponMinAggregate struct {
	BillingID     *string       `json:"billingId"`
	CreatedAt     *string       `json:"createdAt"`
	Description   *string       `json:"description"`
	EnvironmentID *string       `json:"environmentId"`
	ID            *string       `json:"id"`
	Name          *string       `json:"name"`
	RefID         *string       `json:"refId"`
	Source        *CouponSource `json:"source"`
	Status        *CouponStatus `json:"status"`
	Type          *CouponType   `json:"type"`
	UpdatedAt     *string       `json:"updatedAt"`
}

type CouponSort struct {
	Direction SortDirection    `json:"direction"`
	Field     CouponSortFields `json:"field"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

type CouponSourceFilterComparison struct {
	Eq *CouponSource  `json:"eq,omitempty"`
	In []CouponSource `json:"in,omitempty"`
}

type CouponStatusFilterComparison struct {
	Eq       *CouponStatus  `json:"eq,omitempty"`
	Gt       *CouponStatus  `json:"gt,omitempty"`
	Gte      *CouponStatus  `json:"gte,omitempty"`
	ILike    *CouponStatus  `json:"iLike,omitempty"`
	In       []CouponStatus `json:"in,omitempty"`
	Is       *bool          `json:"is,omitempty"`
	IsNot    *bool          `json:"isNot,omitempty"`
	Like     *CouponStatus  `json:"like,omitempty"`
	Lt       *CouponStatus  `json:"lt,omitempty"`
	Lte      *CouponStatus  `json:"lte,omitempty"`
	Neq      *CouponStatus  `json:"neq,omitempty"`
	NotILike *CouponStatus  `json:"notILike,omitempty"`
	NotIn    []CouponStatus `json:"notIn,omitempty"`
	NotLike  *CouponStatus  `json:"notLike,omitempty"`
}

type CouponTypeFilterComparison struct {
	Eq       *CouponType  `json:"eq,omitempty"`
	Gt       *CouponType  `json:"gt,omitempty"`
	Gte      *CouponType  `json:"gte,omitempty"`
	ILike    *CouponType  `json:"iLike,omitempty"`
	In       []CouponType `json:"in,omitempty"`
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Like     *CouponType  `json:"like,omitempty"`
	Lt       *CouponType  `json:"lt,omitempty"`
	Lte      *CouponType  `json:"lte,omitempty"`
	Neq      *CouponType  `json:"neq,omitempty"`
	NotILike *CouponType  `json:"notILike,omitempty"`
	NotIn    []CouponType `json:"notIn,omitempty"`
	NotLike  *CouponType  `json:"notLike,omitempty"`
}

// Create a new coupon input
type CreateCouponInput struct {
	// Metadata associated with the entity
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// Fixed amount discounts in different currencies
	AmountsOff []*MoneyInputDto `json:"amountsOff,omitempty"`
	// Description of the coupon
	Description *string `json:"description,omitempty"`
	// Discount value of the coupon (deprecated)
	DiscountValue *float64 `json:"discountValue,omitempty"`
	// Duration of the coupon validity in months
	DurationInMonths *float64 `json:"durationInMonths,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Name of the coupon
	Name string `json:"name"`
	// Percentage discount off the original price
	PercentOff *float64 `json:"percentOff,omitempty"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// Type of the coupon (percentage or fixed amount)
	Type *CouponType `json:"type,omitempty"`
}

// Input for creating a new environment
type CreateEnvironment struct {
	// The color used to distinguish this environment in the UI
	Color *string `json:"color,omitempty"`
	// The timestamp when the environment was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// Optional description of the environment
	Description *string `json:"description,omitempty"`
	// The name of the environment that will be displayed in the UI
	DisplayName *string `json:"displayName,omitempty"`
	// Whether client-side security hardening is enabled for this environment
	HardenClientAccessEnabled *bool `json:"hardenClientAccessEnabled,omitempty"`
	// Unique identifier for the entity
	ID *string `json:"id,omitempty"`
	// The current provisioning status of the environment
	ProvisionStatus *EnvironmentProvisionStatus `json:"provisionStatus,omitempty"`
	// A unique identifier for the environment
	Slug *string `json:"slug,omitempty"`
	// The type of environment (production or non-production)
	Type *EnvironmentType `json:"type,omitempty"`
}

// Additional options for environment creation
type CreateEnvironmentOptions struct {
	// Whether to automatically create a default product in the new environment
	CreateDefaultProduct *bool `json:"createDefaultProduct,omitempty"`
}

// Input parameters for creating a new experiment
type CreateExperimentInput struct {
	// Name for the control group
	ControlGroupName string `json:"controlGroupName"`
	// Description of the experiements
	Description *string `json:"description,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Name of the experiment
	Name string `json:"name"`
	// Internal identifier for the product experiment is associated with
	ProductID string `json:"productId"`
	// Product settings for the variant group
	ProductSettings *ProductSettingsInput `json:"productSettings,omitempty"`
	// Name for the variant group
	VariantGroupName string `json:"variantGroupName"`
	// Percentage of users in the variant group
	VariantPercentage float64 `json:"variantPercentage"`
}

// Input for creating a feature group
type CreateFeatureGroupInput struct {
	// The description of the feature group
	Description *string `json:"description,omitempty"`
	// The display name of the feature group
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The feature group id
	FeatureGroupID string `json:"featureGroupId"`
	// The features in the feature group
	Features []string `json:"features"`
}

type CreateHook struct {
	// A JSON containing the configuration for each event log type
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// Webhook description
	Description *string `json:"description,omitempty"`
	// The Webhook endpoint URL
	Endpoint *string `json:"endpoint,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The event types that the webhook will be triggered on
	EventLogTypes []EventLogType `json:"eventLogTypes,omitempty"`
	// Unique identifier for the entity
	ID *string `json:"id,omitempty"`
	// Secret key for the webhook
	SecretKey *string `json:"secretKey,omitempty"`
	// The status of the webhook
	Status *HookStatus `json:"status,omitempty"`
}

// Create integration input
type CreateIntegrationInput struct {
	// Auth0 integration configuration
	Auth0Credentials *Auth0CredentialsInput `json:"auth0Credentials,omitempty"`
	// Amazon Web Services Marketplace integration configuration
	AwsMarketplaceCredentials *AwsMarketplaceCredentialsInput `json:"awsMarketplaceCredentials,omitempty"`
	// Google BigQuery integration configuration
	BigQueryCredentials *BigQueryCredentialsInput `json:"bigQueryCredentials,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// HubSpot integration configuration
	HubspotCredentials *HubspotCredentialsInput `json:"hubspotCredentials,omitempty"`
	// The reference ID for the integration
	IntegrationID *string `json:"integrationId,omitempty"`
	// Whether the integration is the default integration
	IsDefault *bool `json:"isDefault,omitempty"`
	// OpenFGA integration configuration
	OpenFGACredentials *OpenFGACredentialsInput `json:"openFGACredentials,omitempty"`
	// Salesforce integration configuration
	SalesforceCredentials *SalesforceCredentialsInput `json:"salesforceCredentials,omitempty"`
	// Snowflake integration configuration
	SnowflakeCredentials *SnowflakeCredentialsInput `json:"snowflakeCredentials,omitempty"`
	// Stripe integration configuration
	StripeCredentials *StripeCredentialsInput `json:"stripeCredentials,omitempty"`
	// The vendor identifier of integration
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
	// Zuora integration configuration
	ZuoraCredentials *ZuoraCredentialsInput `json:"zuoraCredentials,omitempty"`
}

type CreateManyPackageEntitlementsInput struct {
	// Array of records to create
	PackageEntitlements []*PackageEntitlementInput `json:"packageEntitlements"`
}

type CreateManyPromotionalEntitlementsInput struct {
	// Array of records to create
	PromotionalEntitlements []*PromotionalEntitlementInput `json:"promotionalEntitlements"`
}

// A meter configuration that tracks and measures usage-based functionality
type CreateMeter struct {
	// Configuration specifying how to aggregate the meter data
	Aggregation MeterAggregation `json:"aggregation"`
	// List of filters that will be applied to the data
	Filters []*MeterFilterDefinitionInput `json:"filters"`
}

// Input for creating a single environment
type CreateOneEnvironmentInput struct {
	// The environment configuration details
	Environment CreateEnvironment `json:"environment"`
	// Additional options for environment creation
	Options *CreateEnvironmentOptions `json:"options,omitempty"`
}

type CreateOneHookInput struct {
	// The record to create
	Hook CreateHook `json:"hook"`
}

type CreateOneIntegrationInput struct {
	// The record to create
	Integration CreateIntegrationInput `json:"integration"`
}

// Input for creating a single product
type CreateOneProductInput struct {
	// Record to create
	Product ProductCreateInput `json:"product"`
}

// Create or update AWS Marketplace product input
type CreateOrUpdateAwsMarketplaceProductInput struct {
	// Additional metadata for the product
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// Auto cancellation rules
	AutoCancellationRules []*AutoCancellationRuleInput `json:"autoCancellationRules,omitempty"`
	// Mapping between AWS dimensions and Stigg plans for entitlements
	AwsDimensionsMapping []*DimensionsMappingInput `json:"awsDimensionsMapping"`
	// AWS Marketplace product identifier
	AwsProductID *string `json:"awsProductId,omitempty"`
	// Description of the product
	Description *string `json:"description,omitempty"`
	// Display name of the product
	DisplayName *string `json:"displayName,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Indicates if multiple subscriptions to this product are allowed
	MultipleSubscriptions *bool `json:"multipleSubscriptions,omitempty"`
	// Stigg product ID to be mapped to AWS Marketplace
	ProductID *string `json:"productId,omitempty"`
	// Settings for the product
	ProductSettings *ProductSettingsInput `json:"productSettings,omitempty"`
	// The unique identifier for the entity
	RefID *string `json:"refId,omitempty"`
	// Usage reset cutoff rule
	UsageResetCutoffRule *SubscriptionUpdateUsageResetCutoffRuleInput `json:"usageResetCutoffRule,omitempty"`
}

// The input type for creating a package group
type CreatePackageGroup struct {
	// The description of the package group
	Description *string `json:"description,omitempty"`
	// The display name of the package group
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The id of the package group
	PackageGroupID string `json:"packageGroupId"`
	// The id of the related product
	ProductID string `json:"productId"`
}

// Create workflow trigger input
type CreateWorkflowTriggerInput struct {
	// A JSON containing the configuration for each event log type
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	// Workflow trigger endpoint
	Endpoint string `json:"endpoint"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Event log types
	EventLogTypes []EventLogType `json:"eventLogTypes"`
	// Workflow trigger id
	TriggerID *string `json:"triggerId,omitempty"`
}

type CursorPaging struct {
	// Paginate after opaque cursor
	After *string `json:"after,omitempty"`
	// Paginate before opaque cursor
	Before *string `json:"before,omitempty"`
	// Paginate first
	First *int64 `json:"first,omitempty"`
	// Paginate last
	Last *int64 `json:"last,omitempty"`
}

// Stigg customer object
type Customer struct {
	// Additional metadata
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// The AWS Marketplace integration id
	AwsMarketplaceCustomerID *string `json:"awsMarketplaceCustomerId"`
	// The billing currency of the customer
	BillingCurrency *Currency `json:"billingCurrency"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The URL to the entity in the billing provider
	BillingLinkURL *string `json:"billingLinkUrl"`
	Coupon         *Coupon `json:"coupon"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Company ID in Hubspot integration
	CrmHubspotCompanyID *string `json:"crmHubspotCompanyId"`
	// Company URL in Hubspot integration
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
	// The unique identifier for the customer in Hubspot integration
	CrmID *string `json:"crmId"`
	// Customer slug
	CustomerID string `json:"customerId"`
	// The expiration month of the default payment method
	DefaultPaymentExpirationMonth *int64 `json:"defaultPaymentExpirationMonth"`
	// The expiration year of the default payment method
	DefaultPaymentExpirationYear *int64 `json:"defaultPaymentExpirationYear"`
	// The default payment method id
	DefaultPaymentMethodID *string `json:"defaultPaymentMethodId"`
	// The last 4 digits of the default payment method
	DefaultPaymentMethodLast4Digits *string `json:"defaultPaymentMethodLast4Digits"`
	// The default payment method type
	DefaultPaymentMethodType *PaymentMethodType `json:"defaultPaymentMethodType"`
	// Timestamp of when the record was deleted
	DeletedAt *string `json:"deletedAt"`
	// Whether the customer is eligible for a trial
	EligibleForTrial []*EligibleForTrial `json:"eligibleForTrial"`
	// The email of the customer
	Email       *string      `json:"email"`
	Environment *Environment `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Whether the customer is excluded from the experiment
	ExcludeFromExperiment *bool       `json:"excludeFromExperiment"`
	Experiment            *Experiment `json:"experiment"`
	// Experiment info
	ExperimentInfo *ExperimentInfo `json:"experimentInfo"`
	// Wether the customer has an active resource
	HasActiveResource bool `json:"hasActiveResource"`
	// Wether the customer has an active subscription
	HasActiveSubscription bool `json:"hasActiveSubscription"`
	// Whether the customer has an attached payment method
	HasPaymentMethod bool `json:"hasPaymentMethod"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The name of the customer
	Name                    *string                   `json:"name"`
	PromotionalEntitlements []*PromotionalEntitlement `json:"promotionalEntitlements"`
	// Customer slug
	RefID string `json:"refId"`
	// The unique identifier for the customer in Salesforce integration
	SalesforceID *string `json:"salesforceId"`
	// Customer related aggregations
	Statistics    *CustomerStatistics     `json:"statistics"`
	Subscriptions []*CustomerSubscription `json:"subscriptions"`
	// List of integration sync states
	SyncStates []*SyncState `json:"syncStates"`
	// Total active promotional entitlement count
	TotalActivePromotionalEntitlements float64 `json:"totalActivePromotionalEntitlements"`
	// Total active subscription count
	TotalActiveSubscription float64 `json:"totalActiveSubscription"`
	// List of already trialed plans
	TrialedPlans []*TrialedPlan `json:"trialedPlans"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
}

type CustomerAggregateGroupBy struct {
	BillingID            *string `json:"billingId"`
	CreatedAt            *string `json:"createdAt"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
	CrmID                *string `json:"crmId"`
	CustomerID           *string `json:"customerId"`
	DeletedAt            *string `json:"deletedAt"`
	Email                *string `json:"email"`
	EnvironmentID        *string `json:"environmentId"`
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	RefID                *string `json:"refId"`
	SalesforceID         *string `json:"salesforceId"`
	SearchQuery          *string `json:"searchQuery"`
	UpdatedAt            *string `json:"updatedAt"`
}

// Aggregated events by customer
type CustomerAggregatedUsage struct {
	// Customer id
	CustomerID string `json:"customerId"`
	// Usage
	Usage float64 `json:"usage"`
}

// Update customer billing information
type CustomerBillingInfo struct {
	// Customer billing address
	BillingAddress *Address `json:"billingAddress,omitempty"`
	// Customers selected currency
	Currency *Currency `json:"currency,omitempty"`
	// Customer name
	CustomerName *string `json:"customerName,omitempty"`
	// The billing integration to use for this customer
	IntegrationID *string `json:"integrationId,omitempty"`
	// Invoice custom fields
	InvoiceCustomFields map[string]interface{} `json:"invoiceCustomFields,omitempty"`
	// Language to use for this customer
	Language *string `json:"language,omitempty"`
	// Additional metadata
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// Billing provider payment method id, attached to this customer
	PaymentMethodID *string `json:"paymentMethodId,omitempty"`
	// Customer shipping address
	ShippingAddress *Address `json:"shippingAddress,omitempty"`
	// Tax IDs
	TaxIds []*TaxExempt `json:"taxIds,omitempty"`
	// Timezone to use for this customer
	Timezone *string `json:"timezone,omitempty"`
}

type CustomerConnection struct {
	// Array of edges.
	Edges []*CustomerEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerCountAggregate struct {
	BillingID            *int64 `json:"billingId"`
	CreatedAt            *int64 `json:"createdAt"`
	CrmHubspotCompanyID  *int64 `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *int64 `json:"crmHubspotCompanyUrl"`
	CrmID                *int64 `json:"crmId"`
	CustomerID           *int64 `json:"customerId"`
	DeletedAt            *int64 `json:"deletedAt"`
	Email                *int64 `json:"email"`
	EnvironmentID        *int64 `json:"environmentId"`
	ID                   *int64 `json:"id"`
	Name                 *int64 `json:"name"`
	RefID                *int64 `json:"refId"`
	SalesforceID         *int64 `json:"salesforceId"`
	SearchQuery          *int64 `json:"searchQuery"`
	UpdatedAt            *int64 `json:"updatedAt"`
}

type CustomerEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Customer
	Node Customer `json:"node"`
}

type CustomerFilter struct {
	And                     []*CustomerFilter                           `json:"and,omitempty"`
	BillingID               *StringFieldComparison                      `json:"billingId,omitempty"`
	CreatedAt               *DateFieldComparison                        `json:"createdAt,omitempty"`
	CrmHubspotCompanyID     *StringFieldComparison                      `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL    *StringFieldComparison                      `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                   *StringFieldComparison                      `json:"crmId,omitempty"`
	CustomerID              *StringFieldComparison                      `json:"customerId,omitempty"`
	DeletedAt               *DateFieldComparison                        `json:"deletedAt,omitempty"`
	Email                   *StringFieldComparison                      `json:"email,omitempty"`
	EnvironmentID           *UUIDFilterComparison                       `json:"environmentId,omitempty"`
	ID                      *UUIDFilterComparison                       `json:"id,omitempty"`
	Name                    *StringFieldComparison                      `json:"name,omitempty"`
	Or                      []*CustomerFilter                           `json:"or,omitempty"`
	PromotionalEntitlements *CustomerFilterPromotionalEntitlementFilter `json:"promotionalEntitlements,omitempty"`
	RefID                   *StringFieldComparison                      `json:"refId,omitempty"`
	SalesforceID            *StringFieldComparison                      `json:"salesforceId,omitempty"`
	SearchQuery             *CustomerSearchQueryFilterComparison        `json:"searchQuery,omitempty"`
	Subscriptions           *CustomerFilterCustomerSubscriptionFilter   `json:"subscriptions,omitempty"`
	UpdatedAt               *DateFieldComparison                        `json:"updatedAt,omitempty"`
}

type CustomerFilterCustomerSubscriptionFilter struct {
	And                       []*CustomerFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingCycleAnchor        *DateFieldComparison                        `json:"billingCycleAnchor,omitempty"`
	BillingID                 *StringFieldComparison                      `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison   `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                        `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                        `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                      `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                      `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                        `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                        `json:"currentBillingPeriodStart,omitempty"`
	CustomerID                *UUIDFilterComparison                       `json:"customerId,omitempty"`
	EffectiveEndDate          *DateFieldComparison                        `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                        `json:"endDate,omitempty"`
	EnvironmentID             *UUIDFilterComparison                       `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison                       `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                      `json:"oldBillingId,omitempty"`
	Or                        []*CustomerFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PayingCustomerID          *UUIDFilterComparison                       `json:"payingCustomerId,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison          `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                      `json:"refId,omitempty"`
	ResourceID                *UUIDFilterComparison                       `json:"resourceId,omitempty"`
	SalesforceID              *StringFieldComparison                      `json:"salesforceId,omitempty"`
	StartDate                 *DateFieldComparison                        `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison         `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                      `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                        `json:"trialEndDate,omitempty"`
}

type CustomerFilterPromotionalEntitlementFilter struct {
	And           []*CustomerFilterPromotionalEntitlementFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	EnvironmentID *UUIDFilterComparison                         `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison                         `json:"id,omitempty"`
	Or            []*CustomerFilterPromotionalEntitlementFilter `json:"or,omitempty"`
	Status        *PromotionalEntitlementStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
}

// Create a new customer
type CustomerInput struct {
	// Additional metadata
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The AWS Marketplace integration id
	AwsMarketplaceCustomerID *string `json:"awsMarketplaceCustomerId,omitempty"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId,omitempty"`
	// Customer billing information
	BillingInformation *CustomerBillingInfo `json:"billingInformation,omitempty"`
	// Customer level coupon
	CouponRefID *string `json:"couponRefId,omitempty"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// The unique identifier for the customer in Hubspot integration
	CrmID *string `json:"crmId,omitempty"`
	// Customer slug
	CustomerID *string `json:"customerId,omitempty"`
	// The email of the customer
	Email *string `json:"email,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The name of the customer
	Name *string `json:"name,omitempty"`
	// Customer slug
	RefID *string `json:"refId,omitempty"`
	// The unique identifier for the customer in Salesforce integration
	SalesforceID *string `json:"salesforceId,omitempty"`
	// Wether or not to sync free subscriptions to the billing provider
	ShouldSyncFree *bool `json:"shouldSyncFree,omitempty"`
}

type CustomerMaxAggregate struct {
	BillingID            *string `json:"billingId"`
	CreatedAt            *string `json:"createdAt"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
	CrmID                *string `json:"crmId"`
	CustomerID           *string `json:"customerId"`
	DeletedAt            *string `json:"deletedAt"`
	Email                *string `json:"email"`
	EnvironmentID        *string `json:"environmentId"`
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	RefID                *string `json:"refId"`
	SalesforceID         *string `json:"salesforceId"`
	SearchQuery          *string `json:"searchQuery"`
	UpdatedAt            *string `json:"updatedAt"`
}

type CustomerMinAggregate struct {
	BillingID            *string `json:"billingId"`
	CreatedAt            *string `json:"createdAt"`
	CrmHubspotCompanyID  *string `json:"crmHubspotCompanyId"`
	CrmHubspotCompanyURL *string `json:"crmHubspotCompanyUrl"`
	CrmID                *string `json:"crmId"`
	CustomerID           *string `json:"customerId"`
	DeletedAt            *string `json:"deletedAt"`
	Email                *string `json:"email"`
	EnvironmentID        *string `json:"environmentId"`
	ID                   *string `json:"id"`
	Name                 *string `json:"name"`
	RefID                *string `json:"refId"`
	SalesforceID         *string `json:"salesforceId"`
	SearchQuery          *string `json:"searchQuery"`
	UpdatedAt            *string `json:"updatedAt"`
}

type CustomerNoBillingID struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type CustomerNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

// A brief explanation of the specific customer portal session.
type CustomerPortal struct {
	// The customers billing contact and payment method details.
	BillingInformation CustomerPortalBillingInformation `json:"billingInformation"`
	// A link to the external billing portal.
	BillingPortalURL *string `json:"billingPortalUrl"`
	// Indicates whether the customer is allowed to upgrade their subscription.
	CanUpgradeSubscription bool `json:"canUpgradeSubscription"`
	// Optional configuration object for customizing how the customer portal behaves or appears
	Configuration *CustomerPortalConfiguration `json:"configuration"`
	// All effective entitlements granted through the customers subscription.
	Entitlements []*Entitlement `json:"entitlements"`
	// A list of promotional entitlements granted directly to the customer. These provide bonus or trial access to features.
	PromotionalEntitlements []*CustomerPortalPromotionalEntitlement `json:"promotionalEntitlements"`
	// The ID of the resource that the portal session is scoped to.
	Resource *CustomerResource `json:"resource"`
	// Indicates whether to show the Stigg watermark on the checkout widget.
	ShowWatermark bool `json:"showWatermark"`
	// List of the customers active subscriptions.
	Subscriptions []*CustomerPortalSubscription `json:"subscriptions"`
}

type CustomerPortalAddon struct {
	AddonID     string  `json:"addonId"`
	Description *string `json:"description"`
	DisplayName string  `json:"displayName"`
	Quantity    int64   `json:"quantity"`
}

// A brief explanation of the specific billing profile.
type CustomerPortalBillingInformation struct {
	// The expiration month of the default payment method
	DefaultPaymentExpirationMonth *int64 `json:"defaultPaymentExpirationMonth"`
	// The expiration year of the default payment method
	DefaultPaymentExpirationYear *int64 `json:"defaultPaymentExpirationYear"`
	// The default payment method id
	DefaultPaymentMethodID *string `json:"defaultPaymentMethodId"`
	// The last 4 digits of the default payment method
	DefaultPaymentMethodLast4Digits *string `json:"defaultPaymentMethodLast4Digits"`
	// The default payment method type
	DefaultPaymentMethodType *PaymentMethodType `json:"defaultPaymentMethodType"`
	// The email of the customer
	Email *string `json:"email"`
	// The name of the customer
	Name *string `json:"name"`
}

// Color palette settings for the customer portal.
type CustomerPortalColorsPalette struct {
	// Main background color of the customer portal.
	BackgroundColor *string `json:"backgroundColor"`
	// Color used for UI borders.
	BorderColor *string `json:"borderColor"`
	// Background color for the current plan section.
	CurrentPlanBackground *string `json:"currentPlanBackground"`
	// Background color for the current plan section.
	IconsColor *string `json:"iconsColor"`
	// Background color used in the paywall section inside the customer portal.
	PaywallBackgroundColor *string `json:"paywallBackgroundColor"`
	// Primary accent color for the portal.
	Primary *string `json:"primary"`
	// Color used for text in the customer portal.
	TextColor *string `json:"textColor"`
}

// Input for customizing customer portal color palette.
type CustomerPortalColorsPaletteInput struct {
	// Background color of the widget.
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// Color applied to widget borders or separators.
	BorderColor *string `json:"borderColor,omitempty"`
	// Background color for the customer’s current plan section in the paywall.
	CurrentPlanBackground *string `json:"currentPlanBackground,omitempty"`
	// Color used for icons in the customer portal.
	IconsColor *string `json:"iconsColor,omitempty"`
	// Background color for embedded paywall sections inside the customer portal.
	PaywallBackgroundColor *string `json:"paywallBackgroundColor,omitempty"`
	// Primary accent color used throughout the widget.
	Primary *string `json:"primary,omitempty"`
	// Default color used for text content.
	TextColor *string `json:"textColor,omitempty"`
}

// Styling and layout configuration for the customer portal widget.
type CustomerPortalConfiguration struct {
	// Custom CSS overrides for the customer portal widget.
	CustomCSS *string `json:"customCss"`
	// Custom color palette for the customer portal UI.
	Palette *CustomerPortalColorsPalette `json:"palette"`
	// Font and text style settings for the customer portal.
	Typography *TypographyConfiguration `json:"typography"`
}

// Input for configuring the customer portal appearance.
type CustomerPortalConfigurationInput struct {
	// Custom CSS rules to override default styling in the portal.
	CustomCSS *string `json:"customCss,omitempty"`
	// Color palette customization for the portal UI.
	Palette *CustomerPortalColorsPaletteInput `json:"palette,omitempty"`
	// Font styling settings for the customer portal.
	Typography *TypographyConfigurationInput `json:"typography,omitempty"`
}

// Optional explanation or context for why this portal session is being initialized.
type CustomerPortalInput struct {
	// Unique identifier of the customer.
	CustomerID string `json:"customerId"`
	// The ID of the product context under which the portal is rendered.
	ProductID *string `json:"productId,omitempty"`
	// Unique identifier of a resource if the subscription or entitlements are scoped to a specific resource.
	ResourceID *string `json:"resourceId,omitempty"`
}

type CustomerPortalPricingFeature struct {
	// The description for the feature
	Description *string `json:"description"`
	// The display name for the feature
	DisplayName string `json:"displayName"`
	// The type of the feature
	FeatureType FeatureType `json:"featureType"`
	// The units for the feature
	FeatureUnits *string `json:"featureUnits"`
	// The plural units for the feature
	FeatureUnitsPlural *string `json:"featureUnitsPlural"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The meter type for the feature
	MeterType *MeterType `json:"meterType"`
	// The unique identifier for the feature
	RefID string `json:"refId"`
}

// General description of the promotional entitlement. Use descriptionField instead to avoid key collisions.
type CustomerPortalPromotionalEntitlement struct {
	// The main descriptive text for the entitlement, explaining what benefit is granted.
	Description *string `json:"description"`
	// The name of the promotional entitlement as it should appear in the Stigg portal.
	DisplayName string `json:"displayName"`
	// The date and time when the promotional entitlement expires and is no longer effective.
	EndDate *string `json:"endDate"`
	// Indicates that the entitlements usage limit is not strictly enforced — customers can exceed it, but their usage is still tracked.
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Indicates whether this promotional entitlement grants unlimited usage.
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage"`
	// The time interval after which usage resets automatically.
	Period PromotionalEntitlementPeriod `json:"period"`
	// The date and time when the promotional entitlement becomes active.
	StartDate string `json:"startDate"`
	// The maximum allowed usage for this promotional entitlement, which only applies to metered features.
	UsageLimit *float64 `json:"usageLimit"`
}

type CustomerPortalSubscription struct {
	Addons             []*CustomerPortalAddon             `json:"addons"`
	BillingPeriodRange *DateRange                         `json:"billingPeriodRange"`
	PlanID             string                             `json:"planId"`
	PlanName           string                             `json:"planName"`
	Prices             []*CustomerPortalSubscriptionPrice `json:"prices"`
	Pricing            CustomerPortalSubscriptionPricing  `json:"pricing"`
	PricingType        PricingType                        `json:"pricingType"`
	ScheduledUpdates   []*SubscriptionScheduledUpdate     `json:"scheduledUpdates"`
	Status             SubscriptionStatus                 `json:"status"`
	SubscriptionID     string                             `json:"subscriptionId"`
	TotalPrice         *CustomerSubscriptionTotalPrice    `json:"totalPrice"`
	TrialRemainingDays *int64                             `json:"trialRemainingDays"`
}

type CustomerPortalSubscriptionPrice struct {
	BillingModel  *BillingModel  `json:"billingModel"`
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	// The number of units per block
	BlockSize *float64                      `json:"blockSize"`
	Feature   *CustomerPortalPricingFeature `json:"feature"`
	Price     *Money                        `json:"price"`
}

type CustomerPortalSubscriptionPricing struct {
	BillingCountryCode      *string                       `json:"billingCountryCode"`
	BillingModel            *BillingModel                 `json:"billingModel"`
	BillingPeriod           *BillingPeriod                `json:"billingPeriod"`
	Feature                 *CustomerPortalPricingFeature `json:"feature"`
	Price                   *Money                        `json:"price"`
	PricingType             PricingType                   `json:"pricingType"`
	UnitQuantity            *int64                        `json:"unitQuantity"`
	UsageBasedEstimatedBill *float64                      `json:"usageBasedEstimatedBill"`
}

// Resource object that belongs to a customer
type CustomerResource struct {
	// Timestamp of when the record was created
	CreatedAt string   `json:"createdAt"`
	Customer  Customer `json:"customer"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Resource slug
	ResourceID    string                  `json:"resourceId"`
	Subscriptions []*CustomerSubscription `json:"subscriptions"`
}

type CustomerResourceAggregateGroupBy struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ResourceID    *string `json:"resourceId"`
}

type CustomerResourceConnection struct {
	// Array of edges.
	Edges []*CustomerResourceEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerResourceCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ResourceID    *int64 `json:"resourceId"`
}

type CustomerResourceEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the CustomerResource
	Node CustomerResource `json:"node"`
}

type CustomerResourceFilter struct {
	And           []*CustomerResourceFilter                         `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                              `json:"createdAt,omitempty"`
	Customer      *CustomerResourceFilterCustomerFilter             `json:"customer,omitempty"`
	EnvironmentID *UUIDFilterComparison                             `json:"environmentId,omitempty"`
	Or            []*CustomerResourceFilter                         `json:"or,omitempty"`
	ResourceID    *StringFieldComparison                            `json:"resourceId,omitempty"`
	Subscriptions *CustomerResourceFilterCustomerSubscriptionFilter `json:"subscriptions,omitempty"`
}

type CustomerResourceFilterCustomerFilter struct {
	And                  []*CustomerResourceFilterCustomerFilter `json:"and,omitempty"`
	BillingID            *StringFieldComparison                  `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                    `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                  `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                  `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison                  `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison                  `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                    `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison                  `json:"email,omitempty"`
	EnvironmentID        *UUIDFilterComparison                   `json:"environmentId,omitempty"`
	ID                   *UUIDFilterComparison                   `json:"id,omitempty"`
	Name                 *StringFieldComparison                  `json:"name,omitempty"`
	Or                   []*CustomerResourceFilterCustomerFilter `json:"or,omitempty"`
	RefID                *StringFieldComparison                  `json:"refId,omitempty"`
	SalesforceID         *StringFieldComparison                  `json:"salesforceId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison    `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                    `json:"updatedAt,omitempty"`
}

type CustomerResourceFilterCustomerSubscriptionFilter struct {
	And                       []*CustomerResourceFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingCycleAnchor        *DateFieldComparison                                `json:"billingCycleAnchor,omitempty"`
	BillingID                 *StringFieldComparison                              `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison           `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                              `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                              `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                `json:"currentBillingPeriodStart,omitempty"`
	CustomerID                *UUIDFilterComparison                               `json:"customerId,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                `json:"endDate,omitempty"`
	EnvironmentID             *UUIDFilterComparison                               `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison                               `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                              `json:"oldBillingId,omitempty"`
	Or                        []*CustomerResourceFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PayingCustomerID          *UUIDFilterComparison                               `json:"payingCustomerId,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                  `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                        `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                              `json:"refId,omitempty"`
	ResourceID                *UUIDFilterComparison                               `json:"resourceId,omitempty"`
	SalesforceID              *StringFieldComparison                              `json:"salesforceId,omitempty"`
	StartDate                 *DateFieldComparison                                `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                 `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                              `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                `json:"trialEndDate,omitempty"`
}

type CustomerResourceMaxAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ResourceID    *string `json:"resourceId"`
}

type CustomerResourceMinAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ResourceID    *string `json:"resourceId"`
}

type CustomerResourceSort struct {
	Direction SortDirection              `json:"direction"`
	Field     CustomerResourceSortFields `json:"field"`
	Nulls     *SortNulls                 `json:"nulls,omitempty"`
}

type CustomerSearchQueryFilterComparison struct {
	ILike *string `json:"iLike,omitempty"`
}

type CustomerSort struct {
	Direction SortDirection      `json:"direction"`
	Field     CustomerSortFields `json:"field"`
	Nulls     *SortNulls         `json:"nulls,omitempty"`
}

// Customer statistics
type CustomerStatistics struct {
	// Active subscriptions count by pricing type
	ActiveSubscriptionsByPricingType []*SubscriptionPricingTypeStatistics `json:"activeSubscriptionsByPricingType"`
}

type CustomerSubscription struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	Addons             []*SubscriptionAddon   `json:"addons"`
	// Billing cycle anchor date
	BillingCycleAnchor *string `json:"billingCycleAnchor"`
	BillingID          *string `json:"billingId"`
	BillingLinkURL     *string `json:"billingLinkUrl"`
	BillingSyncError   *string `json:"billingSyncError"`
	// Budget configuration
	Budget *BudgetConfiguration `json:"budget"`
	// Indicates if the budget has been exceeded
	BudgetExceeded   *bool                     `json:"budgetExceeded"`
	CancelReason     *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate *string                   `json:"cancellationDate"`
	// Active coupon for this subscription
	Coupon *SubscriptionCoupon `json:"coupon"`
	// List of coupons for this subscription
	Coupons                   []*SubscriptionCoupon       `json:"coupons"`
	CreatedAt                 *string                     `json:"createdAt"`
	CrmID                     *string                     `json:"crmId"`
	CrmLinkURL                *string                     `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                     `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                     `json:"currentBillingPeriodStart"`
	Customer                  Customer                    `json:"customer"`
	CustomerID                *string                     `json:"customerId"`
	EffectiveEndDate          *string                     `json:"effectiveEndDate"`
	EndDate                   *string                     `json:"endDate"`
	Environment               Environment                 `json:"environment"`
	EnvironmentID             string                      `json:"environmentId"`
	Experiment                *Experiment                 `json:"experiment"`
	ExperimentInfo            *ExperimentInfo             `json:"experimentInfo"`
	FreeItems                 []*FreeSubscriptionItem     `json:"freeItems"`
	FutureUpdates             []*SubscriptionFutureUpdate `json:"futureUpdates"`
	ID                        string                      `json:"id"`
	IsCustomPriceSubscription *bool                       `json:"isCustomPriceSubscription"`
	LastUsageInvoice          *SubscriptionInvoice        `json:"lastUsageInvoice"`
	LatestInvoice             *SubscriptionInvoice        `json:"latestInvoice"`
	// Minimum spend configuration
	MinimumSpend          *SubscriptionMinimumSpend `json:"minimumSpend"`
	OldBillingID          *string                   `json:"oldBillingId"`
	OutdatedPricePackages []string                  `json:"outdatedPricePackages"`
	PayingCustomer        *Customer                 `json:"payingCustomer"`
	PayingCustomerID      *string                   `json:"payingCustomerId"`
	PaymentCollection     PaymentCollection         `json:"paymentCollection"`
	// Payment collection method of the subscription
	PaymentCollectionMethod  *PaymentCollectionMethod        `json:"paymentCollectionMethod"`
	Plan                     Plan                            `json:"plan"`
	Prices                   []*SubscriptionPrice            `json:"prices"`
	PricingType              PricingType                     `json:"pricingType"`
	RefID                    string                          `json:"refId"`
	Resource                 *CustomerResource               `json:"resource"`
	ResourceID               *string                         `json:"resourceId"`
	SalesforceID             *string                         `json:"salesforceId"`
	ScheduledUpdates         []*SubscriptionScheduledUpdate  `json:"scheduledUpdates"`
	StartDate                string                          `json:"startDate"`
	Status                   SubscriptionStatus              `json:"status"`
	SubscriptionEntitlements []*SubscriptionEntitlement      `json:"subscriptionEntitlements"`
	SubscriptionID           string                          `json:"subscriptionId"`
	SyncStates               []*SyncState                    `json:"syncStates"`
	TotalPrice               *CustomerSubscriptionTotalPrice `json:"totalPrice"`
	// Trial configuration
	TrialConfiguration *TrialConfiguration `json:"trialConfiguration"`
	TrialEndDate       *string             `json:"trialEndDate"`
	WasInTrial         *bool               `json:"wasInTrial"`
}

type CustomerSubscriptionAggregateGroupBy struct {
	BillingCycleAnchor        *string                   `json:"billingCycleAnchor"`
	BillingID                 *string                   `json:"billingId"`
	CancelReason              *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate          *string                   `json:"cancellationDate"`
	CreatedAt                 *string                   `json:"createdAt"`
	CrmID                     *string                   `json:"crmId"`
	CrmLinkURL                *string                   `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                   `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                   `json:"currentBillingPeriodStart"`
	CustomerID                *string                   `json:"customerId"`
	EffectiveEndDate          *string                   `json:"effectiveEndDate"`
	EndDate                   *string                   `json:"endDate"`
	EnvironmentID             *string                   `json:"environmentId"`
	ID                        *string                   `json:"id"`
	OldBillingID              *string                   `json:"oldBillingId"`
	PayingCustomerID          *string                   `json:"payingCustomerId"`
	PaymentCollection         *PaymentCollection        `json:"paymentCollection"`
	PricingType               *PricingType              `json:"pricingType"`
	RefID                     *string                   `json:"refId"`
	ResourceID                *string                   `json:"resourceId"`
	SalesforceID              *string                   `json:"salesforceId"`
	StartDate                 *string                   `json:"startDate"`
	Status                    *SubscriptionStatus       `json:"status"`
	SubscriptionID            *string                   `json:"subscriptionId"`
	TrialEndDate              *string                   `json:"trialEndDate"`
}

type CustomerSubscriptionConnection struct {
	// Array of edges.
	Edges []*CustomerSubscriptionEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type CustomerSubscriptionCountAggregate struct {
	BillingCycleAnchor        *int64 `json:"billingCycleAnchor"`
	BillingID                 *int64 `json:"billingId"`
	CancelReason              *int64 `json:"cancelReason"`
	CancellationDate          *int64 `json:"cancellationDate"`
	CreatedAt                 *int64 `json:"createdAt"`
	CrmID                     *int64 `json:"crmId"`
	CrmLinkURL                *int64 `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *int64 `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *int64 `json:"currentBillingPeriodStart"`
	CustomerID                *int64 `json:"customerId"`
	EffectiveEndDate          *int64 `json:"effectiveEndDate"`
	EndDate                   *int64 `json:"endDate"`
	EnvironmentID             *int64 `json:"environmentId"`
	ID                        *int64 `json:"id"`
	OldBillingID              *int64 `json:"oldBillingId"`
	PayingCustomerID          *int64 `json:"payingCustomerId"`
	PaymentCollection         *int64 `json:"paymentCollection"`
	PricingType               *int64 `json:"pricingType"`
	RefID                     *int64 `json:"refId"`
	ResourceID                *int64 `json:"resourceId"`
	SalesforceID              *int64 `json:"salesforceId"`
	StartDate                 *int64 `json:"startDate"`
	Status                    *int64 `json:"status"`
	SubscriptionID            *int64 `json:"subscriptionId"`
	TrialEndDate              *int64 `json:"trialEndDate"`
}

type CustomerSubscriptionEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the CustomerSubscription
	Node CustomerSubscription `json:"node"`
}

type CustomerSubscriptionFilter struct {
	Addons                    *CustomerSubscriptionFilterSubscriptionAddonFilter       `json:"addons,omitempty"`
	And                       []*CustomerSubscriptionFilter                            `json:"and,omitempty"`
	BillingCycleAnchor        *DateFieldComparison                                     `json:"billingCycleAnchor,omitempty"`
	BillingID                 *StringFieldComparison                                   `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison                `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                     `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                     `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                                   `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                                   `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                     `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                     `json:"currentBillingPeriodStart,omitempty"`
	Customer                  *CustomerSubscriptionFilterCustomerFilter                `json:"customer,omitempty"`
	CustomerID                *UUIDFilterComparison                                    `json:"customerId,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                     `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                     `json:"endDate,omitempty"`
	EnvironmentID             *UUIDFilterComparison                                    `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison                                    `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                                   `json:"oldBillingId,omitempty"`
	Or                        []*CustomerSubscriptionFilter                            `json:"or,omitempty"`
	PayingCustomer            *CustomerSubscriptionFilterCustomerFilter                `json:"payingCustomer,omitempty"`
	PayingCustomerID          *UUIDFilterComparison                                    `json:"payingCustomerId,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                       `json:"paymentCollection,omitempty"`
	Plan                      *CustomerSubscriptionFilterPlanFilter                    `json:"plan,omitempty"`
	Prices                    *CustomerSubscriptionFilterSubscriptionPriceFilter       `json:"prices,omitempty"`
	PricingType               *PricingTypeFilterComparison                             `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                                   `json:"refId,omitempty"`
	Resource                  *CustomerSubscriptionFilterCustomerResourceFilter        `json:"resource,omitempty"`
	ResourceID                *UUIDFilterComparison                                    `json:"resourceId,omitempty"`
	SalesforceID              *StringFieldComparison                                   `json:"salesforceId,omitempty"`
	StartDate                 *DateFieldComparison                                     `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                      `json:"status,omitempty"`
	SubscriptionEntitlements  *CustomerSubscriptionFilterSubscriptionEntitlementFilter `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID            *StringFieldComparison                                   `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                     `json:"trialEndDate,omitempty"`
}

type CustomerSubscriptionFilterCustomerFilter struct {
	And                  []*CustomerSubscriptionFilterCustomerFilter `json:"and,omitempty"`
	BillingID            *StringFieldComparison                      `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                        `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                      `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                      `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison                      `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison                      `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                        `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison                      `json:"email,omitempty"`
	EnvironmentID        *UUIDFilterComparison                       `json:"environmentId,omitempty"`
	ID                   *UUIDFilterComparison                       `json:"id,omitempty"`
	Name                 *StringFieldComparison                      `json:"name,omitempty"`
	Or                   []*CustomerSubscriptionFilterCustomerFilter `json:"or,omitempty"`
	RefID                *StringFieldComparison                      `json:"refId,omitempty"`
	SalesforceID         *StringFieldComparison                      `json:"salesforceId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison        `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                        `json:"updatedAt,omitempty"`
}

type CustomerSubscriptionFilterCustomerResourceFilter struct {
	And           []*CustomerSubscriptionFilterCustomerResourceFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                                `json:"createdAt,omitempty"`
	EnvironmentID *UUIDFilterComparison                               `json:"environmentId,omitempty"`
	Or            []*CustomerSubscriptionFilterCustomerResourceFilter `json:"or,omitempty"`
	ResourceID    *StringFieldComparison                              `json:"resourceId,omitempty"`
}

type CustomerSubscriptionFilterPlanFilter struct {
	And           []*CustomerSubscriptionFilterPlanFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison                  `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison                    `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                  `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                  `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison                   `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison                   `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison                 `json:"isLatest,omitempty"`
	Or            []*CustomerSubscriptionFilterPlanFilter `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison            `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison                  `json:"productId,omitempty"`
	RefID         *StringFieldComparison                  `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison          `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                    `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison                     `json:"versionNumber,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionAddonFilter struct {
	And       []*CustomerSubscriptionFilterSubscriptionAddonFilter `json:"and,omitempty"`
	CreatedAt *DateFieldComparison                                 `json:"createdAt,omitempty"`
	ID        *UUIDFilterComparison                                `json:"id,omitempty"`
	Or        []*CustomerSubscriptionFilterSubscriptionAddonFilter `json:"or,omitempty"`
	Quantity  *NumberFieldComparison                               `json:"quantity,omitempty"`
	UpdatedAt *DateFieldComparison                                 `json:"updatedAt,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionEntitlementFilter struct {
	And            []*CustomerSubscriptionFilterSubscriptionEntitlementFilter `json:"and,omitempty"`
	CreatedAt      *DateFieldComparison                                       `json:"createdAt,omitempty"`
	EnvironmentID  *UUIDFilterComparison                                      `json:"environmentId,omitempty"`
	ID             *UUIDFilterComparison                                      `json:"id,omitempty"`
	Or             []*CustomerSubscriptionFilterSubscriptionEntitlementFilter `json:"or,omitempty"`
	SubscriptionID *StringFieldComparison                                     `json:"subscriptionId,omitempty"`
	UpdatedAt      *DateFieldComparison                                       `json:"updatedAt,omitempty"`
}

type CustomerSubscriptionFilterSubscriptionPriceFilter struct {
	And          []*CustomerSubscriptionFilterSubscriptionPriceFilter `json:"and,omitempty"`
	BillingModel *BillingModelFilterComparison                        `json:"billingModel,omitempty"`
	CreatedAt    *DateFieldComparison                                 `json:"createdAt,omitempty"`
	FeatureID    *StringFieldComparison                               `json:"featureId,omitempty"`
	HasSoftLimit *BooleanFieldComparison                              `json:"hasSoftLimit,omitempty"`
	ID           *UUIDFilterComparison                                `json:"id,omitempty"`
	Or           []*CustomerSubscriptionFilterSubscriptionPriceFilter `json:"or,omitempty"`
	UpdatedAt    *DateFieldComparison                                 `json:"updatedAt,omitempty"`
	UsageLimit   *NumberFieldComparison                               `json:"usageLimit,omitempty"`
}

type CustomerSubscriptionMaxAggregate struct {
	BillingCycleAnchor        *string                   `json:"billingCycleAnchor"`
	BillingID                 *string                   `json:"billingId"`
	CancelReason              *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate          *string                   `json:"cancellationDate"`
	CreatedAt                 *string                   `json:"createdAt"`
	CrmID                     *string                   `json:"crmId"`
	CrmLinkURL                *string                   `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                   `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                   `json:"currentBillingPeriodStart"`
	CustomerID                *string                   `json:"customerId"`
	EffectiveEndDate          *string                   `json:"effectiveEndDate"`
	EndDate                   *string                   `json:"endDate"`
	EnvironmentID             *string                   `json:"environmentId"`
	ID                        *string                   `json:"id"`
	OldBillingID              *string                   `json:"oldBillingId"`
	PayingCustomerID          *string                   `json:"payingCustomerId"`
	PaymentCollection         *PaymentCollection        `json:"paymentCollection"`
	PricingType               *PricingType              `json:"pricingType"`
	RefID                     *string                   `json:"refId"`
	ResourceID                *string                   `json:"resourceId"`
	SalesforceID              *string                   `json:"salesforceId"`
	StartDate                 *string                   `json:"startDate"`
	Status                    *SubscriptionStatus       `json:"status"`
	SubscriptionID            *string                   `json:"subscriptionId"`
	TrialEndDate              *string                   `json:"trialEndDate"`
}

type CustomerSubscriptionMinAggregate struct {
	BillingCycleAnchor        *string                   `json:"billingCycleAnchor"`
	BillingID                 *string                   `json:"billingId"`
	CancelReason              *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate          *string                   `json:"cancellationDate"`
	CreatedAt                 *string                   `json:"createdAt"`
	CrmID                     *string                   `json:"crmId"`
	CrmLinkURL                *string                   `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string                   `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string                   `json:"currentBillingPeriodStart"`
	CustomerID                *string                   `json:"customerId"`
	EffectiveEndDate          *string                   `json:"effectiveEndDate"`
	EndDate                   *string                   `json:"endDate"`
	EnvironmentID             *string                   `json:"environmentId"`
	ID                        *string                   `json:"id"`
	OldBillingID              *string                   `json:"oldBillingId"`
	PayingCustomerID          *string                   `json:"payingCustomerId"`
	PaymentCollection         *PaymentCollection        `json:"paymentCollection"`
	PricingType               *PricingType              `json:"pricingType"`
	RefID                     *string                   `json:"refId"`
	ResourceID                *string                   `json:"resourceId"`
	SalesforceID              *string                   `json:"salesforceId"`
	StartDate                 *string                   `json:"startDate"`
	Status                    *SubscriptionStatus       `json:"status"`
	SubscriptionID            *string                   `json:"subscriptionId"`
	TrialEndDate              *string                   `json:"trialEndDate"`
}

type CustomerSubscriptionSort struct {
	Direction SortDirection                  `json:"direction"`
	Field     CustomerSubscriptionSortFields `json:"field"`
	Nulls     *SortNulls                     `json:"nulls,omitempty"`
}

type CustomerSubscriptionTotalPrice struct {
	AddonsTotal Money `json:"addonsTotal"`
	SubTotal    Money `json:"subTotal"`
	Total       Money `json:"total"`
}

type DateFieldComparison struct {
	Between    *DateFieldComparisonBetween `json:"between,omitempty"`
	Eq         *string                     `json:"eq,omitempty"`
	Gt         *string                     `json:"gt,omitempty"`
	Gte        *string                     `json:"gte,omitempty"`
	In         []string                    `json:"in,omitempty"`
	Is         *bool                       `json:"is,omitempty"`
	IsNot      *bool                       `json:"isNot,omitempty"`
	Lt         *string                     `json:"lt,omitempty"`
	Lte        *string                     `json:"lte,omitempty"`
	Neq        *string                     `json:"neq,omitempty"`
	NotBetween *DateFieldComparisonBetween `json:"notBetween,omitempty"`
	NotIn      []string                    `json:"notIn,omitempty"`
}

type DateFieldComparisonBetween struct {
	Lower string `json:"lower"`
	Upper string `json:"upper"`
}

// Represents a date range with a start and end date
type DateRange struct {
	// The end date of the range
	End *string `json:"end"`
	// The start date of the range
	Start *string `json:"start"`
}

// Input type for default SSO roles
type DefaultSSORolesInput struct {
	// Account level access of the user
	AccountRole AccountAccessRole `json:"accountRole"`
	// Environment level access of the user
	NonProductionRole EnvironmentAccessRole `json:"nonProductionRole"`
	// Environment level access of the user
	ProductionRole EnvironmentAccessRole `json:"productionRole"`
}

// Default configuration for a trial
type DefaultTrialConfig struct {
	// Budget configuration
	Budget *BudgetConfiguration `json:"budget"`
	// The duration of the trial in the specified units
	Duration float64 `json:"duration"`
	// Trial end behavior
	TrialEndBehavior *TrialEndBehavior `json:"trialEndBehavior"`
	// The time unit for the trial duration (days or months)
	Units TrialPeriodUnits `json:"units"`
}

// Default trial config change
type DefaultTrialConfigChange struct {
	// The value after the change
	After *DefaultTrialConfig `json:"after"`
	// The value before the change
	Before *DefaultTrialConfig `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Default configuration for a trial
type DefaultTrialConfigInputDto struct {
	// Budget configuration
	Budget *BudgetConfigurationInput `json:"budget,omitempty"`
	// The duration of the trial in the specified units
	Duration *float64 `json:"duration,omitempty"`
	// Trial end behavior
	TrialEndBehavior *TrialEndBehavior `json:"trialEndBehavior,omitempty"`
	// The time unit for the trial duration (days or months)
	Units *TrialPeriodUnits `json:"units,omitempty"`
}

// The input for delegating a subscription to a customer
type DelegateSubscriptionToCustomerInput struct {
	// The customer ID which will manage the subscription (the paying customer of the subscription will not change)
	DestinationCustomerID *string `json:"destinationCustomerId,omitempty"`
	// The environment ID of the subscription to delegate
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The ID of the subscription to delegate
	SubscriptionID string `json:"subscriptionId"`
}

// Input for deleting a feature
type DeleteFeatureInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Unique identifier for the entity
	ID string `json:"id"`
}

type DeleteOneHookInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOneIntegrationInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePackageEntitlementInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

type DeleteOnePriceInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

// Input for deleting a product
type DeleteOneProductInput struct {
	// Unique identifier for the entity
	ID string `json:"id"`
}

type DeleteOnePromotionalEntitlementInput struct {
	// The id of the record to delete.
	ID string `json:"id"`
}

// Delete workflow trigger input
type DeleteWorkflowTriggerInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Workflow trigger id
	WorkflowTriggerID string `json:"workflowTriggerId"`
}

// Remove a payment method from a customer
type DetachCustomerPaymentMethodInput struct {
	// Customer slug
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Configuration for mapping AWS Marketplace dimensions to Stigg plans
type DimensionsMappingInput struct {
	// AWS dimension key for the mapping
	Key string `json:"key"`
	// Corresponding Stigg plan name for feature management
	PlanName string `json:"planName"`
	// Reference ID of the corresponding Stigg plan
	PlanRefID string `json:"planRefId"`
}

// Discard Package Draft Input
type DiscardPackageDraftInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
}

// Input for checking if a feature exists
type DoesFeatureExist struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The unique identifier for the feature
	RefID string `json:"refId"`
}

type DowngradeChangeVariables struct {
	AddonRefIds        *string                         `json:"addonRefIds"`
	Addons             []*PlanChangeAddon              `json:"addons"`
	BillableFeatures   []*BillableFeature              `json:"billableFeatures"`
	BillingPeriod      *BillingPeriod                  `json:"billingPeriod"`
	DowngradePlanRefID string                          `json:"downgradePlanRefId"`
	PriceOverrides     []*PriceOverrideChangeVariables `json:"priceOverrides"`
}

func (DowngradeChangeVariables) IsScheduleVariables() {}

// Input for dumping two environments for comparison before a merge
type DumpEnvironmentForForMergeComparisonInput struct {
	// Slug of the destination environment
	DestinationEnvironmentSlug string `json:"destinationEnvironmentSlug"`
	// Merge configuration
	MergeConfiguration *EnvironmentMergeConfigurationInput `json:"mergeConfiguration,omitempty"`
	// Slug of the source environment
	SourceEnvironmentSlug string `json:"sourceEnvironmentSlug"`
}

// DTO representing the pre-merge and post-merge dumps of environments for comparison
type DumpEnvironmentForMergeComparison struct {
	// The anticipated state of the environment after the merge operation would be applied
	PostMergeDump map[string]interface{} `json:"postMergeDump"`
	// The state of the environment before the merge operation is applied
	PreMergeDump map[string]interface{} `json:"preMergeDump"`
}

// Input type for dumpEnvironmentProductCatalog mutation
type DumpEnvironmentProductCatalogInput struct {
	// The slug of the environment to dump
	EnvironmentSlug string `json:"environmentSlug"`
}

// Input for duplicating a product
type DuplicateProductInput struct {
	// Description of the new product
	Description *string `json:"description,omitempty"`
	// Display name of the new product
	DisplayName *string `json:"displayName,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// ID of the product to duplicate
	SourceProductID string `json:"sourceProductId"`
}

type DuplicatedEntityNotAllowedError struct {
	Code              string `json:"code"`
	EntityName        string `json:"entityName"`
	Identifier        string `json:"identifier"`
	IsValidationError bool   `json:"isValidationError"`
}

type EditAllowedOnDraftPackageOnlyError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

// The input type for editing a package group details
type EditPackageGroupDetailsInput struct {
	// The description of the package group
	Description *string `json:"description,omitempty"`
	// The display name of the package group
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The id of the package group
	PackageGroupID string `json:"packageGroupId"`
}

// Information on a product this customer is eligible for a trial
type EligibleForTrial struct {
	// Wether the customer is eligible for a trial
	Eligible bool `json:"eligible"`
	// Internal product id
	ProductID *string `json:"productId"`
	// Product slug, as defined by the user
	ProductRefID *string `json:"productRefId"`
}

// Represents an entitlement granted to a customer, including its usage and reset configuration.
type Entitlement struct {
	// Optional message explaining why access to the feature is denied.
	AccessDeniedReason *AccessDeniedReason `json:"accessDeniedReason"`
	// The amount of the feature the customer has used so far in the current period.
	CurrentUsage *float64 `json:"currentUsage"`
	CustomerID   *string  `json:"customerId"`
	// A custom name to override the default display name for this entitlement.
	DisplayNameOverride *string `json:"displayNameOverride"`
	// Timestamp of the last update to the entitlement grant or configuration.
	EntitlementUpdatedAt *string `json:"entitlementUpdatedAt"`
	// List of enum values applicable to this entitlement, if it is an enum feature.
	EnumValues []string `json:"enumValues"`
	// The feature this entitlement corresponds to.
	Feature *EntitlementFeature `json:"feature"`
	// Indicates whether the usage limit is soft — usage can exceed the limit, but will be tracked.
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Indicates whether this entitlement grants unlimited usage with no enforced cap.
	HasUnlimitedUsage bool `json:"hasUnlimitedUsage"`
	// Indicates whether this entitlement should be hidden in customer-facing widgets.
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	// Indicates whether the entitlement is currently granted to the customer.
	IsGranted bool `json:"isGranted"`
	// The ID of the meter tracking usage for this entitlement.
	MeterID       *string `json:"meterId"`
	NextResetDate *string `json:"nextResetDate"`
	// The amount of usage requested by the customer.
	RequestedUsage *float64 `json:"requestedUsage"`
	// The values requested by the customer, if applicable.
	RequestedValues []string `json:"requestedValues"`
	// The interval at which usage resets automatically, such as monthly or yearly.
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// Detailed configuration object specifying the usage reset schedule.
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	ResourceID               *string                  `json:"resourceId"`
	// The maximum allowed usage for this entitlement before restrictions apply.
	UsageLimit *float64 `json:"usageLimit"`
	// The anchor for calculating the usage period for metered entitlements with a reset period configured
	UsagePeriodAnchor *string `json:"usagePeriodAnchor"`
	// The end date of the usage period for metered entitlements with a reset period configured
	UsagePeriodEnd *string `json:"usagePeriodEnd"`
	// The start date of the usage period for metered entitlements with a reset period configured
	UsagePeriodStart *string `json:"usagePeriodStart"`
	// Timestamp of the last update to the usage value.
	UsageUpdatedAt *string `json:"usageUpdatedAt"`
}

// Input used to report that an entitlement check was performed for a customer.
type EntitlementCheckRequested struct {
	// Identifier of the customer for whom the entitlement check was made.
	CustomerID string `json:"customerId"`
	// Result object of an entitlement access check.
	EntitlementCheckResult EntitlementCheckResult `json:"entitlementCheckResult"`
	// The environment context in which the check occurred.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The internal ID of the feature linked to this entitlement.
	FeatureID string `json:"featureId"`
	// The amount of usage requested by the customer.
	RequestedUsage *float64 `json:"requestedUsage,omitempty"`
	// The values requested by the customer, if applicable.
	RequestedValues []string `json:"requestedValues,omitempty"`
	// The specific resource identifier scoped for the entitlement check.
	ResourceID *string `json:"resourceId,omitempty"`
}

// Result object of an entitlement access check.
type EntitlementCheckResult struct {
	// Optional message explaining why access to the feature is denied.
	AccessDeniedReason *AccessDeniedReason `json:"accessDeniedReason,omitempty"`
	// The amount of the feature the customer has used so far in the current period.
	CurrentUsage *float64 `json:"currentUsage,omitempty"`
	// List of enum values applicable to this entitlement, if it is an enum feature.
	EnumValues []string `json:"enumValues,omitempty"`
	// Indicates whether the customer currently has access to the feature.
	HasAccess bool `json:"hasAccess"`
	// Indicates whether the usage limit is soft — usage can exceed the limit, but will be tracked.
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Indicates whether this entitlement grants unlimited usage with no enforced cap.
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Configuration for monthly usage reset.
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The next date when the entitlement usage resets.
	NextResetDate *string `json:"nextResetDate,omitempty"`
	// The amount of usage requested by the customer.
	RequestedUsage *float64 `json:"requestedUsage,omitempty"`
	// The values requested by the customer, if applicable.
	RequestedValues []string `json:"requestedValues,omitempty"`
	// The interval at which usage resets automatically, such as monthly or yearly.
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The maximum allowed usage for this entitlement before restrictions apply.
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// Configuration for weekly usage reset.
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// Configuration for yearly usage reset.
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type EntitlementFeature struct {
	// Any additional metadata attached to this entitlement.
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	Description        *string                `json:"description"`
	// The human-readable name of the entitlement, shown in UI elements.
	DisplayName string `json:"displayName"`
	// The configuration data for the enum feature
	EnumConfiguration []*EnumConfigurationEntity `json:"enumConfiguration"`
	// The current status of the feature.
	FeatureStatus FeatureStatus `json:"featureStatus"`
	// The type of feature associated with the entitlement.
	FeatureType FeatureType `json:"featureType"`
	// The singular unit label for the feature.
	FeatureUnits *string `json:"featureUnits"`
	// The plural unit label for the feature.
	FeatureUnitsPlural *string `json:"featureUnitsPlural"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The type of meter associated with the entitlement.
	MeterType *MeterType `json:"meterType"`
	// The unique reference ID of the entitlement.
	RefID string `json:"refId"`
	// Unit transformation to be applied to the reported usage
	UnitTransformation *UnitTransformation `json:"unitTransformation"`
}

type EntitlementLimitExceededError struct {
	Code              string `json:"code"`
	Feature           string `json:"feature"`
	IsValidationError bool   `json:"isValidationError"`
}

// Options for configuring how an entitlement is tracked or applied.
type EntitlementOptions struct {
	// The amount of usage requested by the customer.
	RequestedUsage *float64 `json:"requestedUsage,omitempty"`
	// The values requested by the customer, if applicable.
	RequestedValues []string `json:"requestedValues,omitempty"`
	// Not in use anymore
	ShouldTrack *bool `json:"shouldTrack,omitempty"`
}

// Summary of all entitlements affecting a given feature for a customer.
type EntitlementSummary struct {
	// The number of addon units applied to the feature entitlement.
	AddonQuantity *float64 `json:"addonQuantity"`
	// The entitlement granted through a feature package.
	FeaturePackageEntitlement *PackageEntitlement `json:"featurePackageEntitlement"`
	// The entitlement granted via a promotional offer or override.
	FeaturePromotionalEntitlement *PromotionalEntitlement `json:"featurePromotionalEntitlement"`
	// Indicates whether this entitlement is currently active and in effect.
	IsEffectiveEntitlement bool `json:"isEffectiveEntitlement"`
	// The subscription plan associated with the entitlement.
	Plan *Plan `json:"plan"`
	// The entitlement derived from the pricing configuration of the subscription.
	PriceEntitlement *PriceEntitlement `json:"priceEntitlement"`
	// The customer subscription context in which the entitlement was granted.
	Subscription *CustomerSubscription `json:"subscription"`
}

// A data structure that combines raw entitlement data with its computed summary.
type EntitlementWithSummary struct {
	// Optional message explaining why access to the feature is denied.
	AccessDeniedReason *AccessDeniedReason `json:"accessDeniedReason"`
	// The amount of the feature the customer has used so far in the current period.
	CurrentUsage *float64 `json:"currentUsage"`
	CustomerID   *string  `json:"customerId"`
	// A custom name to override the default display name for this entitlement.
	DisplayNameOverride *string `json:"displayNameOverride"`
	// Timestamp of the last update to the entitlement grant or configuration.
	EntitlementUpdatedAt *string `json:"entitlementUpdatedAt"`
	// List of enum values applicable to this entitlement, if it is an enum feature.
	EnumValues []string `json:"enumValues"`
	// The feature this entitlement corresponds to.
	Feature *EntitlementFeature `json:"feature"`
	// Indicates whether the usage limit is soft — usage can exceed the limit, but will be tracked.
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Indicates whether this entitlement grants unlimited usage with no enforced cap.
	HasUnlimitedUsage bool `json:"hasUnlimitedUsage"`
	// Indicates whether this entitlement should be hidden in customer-facing widgets.
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	// Indicates whether the entitlement is currently granted to the customer.
	IsGranted bool `json:"isGranted"`
	// The ID of the meter tracking usage for this entitlement.
	MeterID       *string `json:"meterId"`
	NextResetDate *string `json:"nextResetDate"`
	// The amount of usage requested by the customer.
	RequestedUsage *float64 `json:"requestedUsage"`
	// The values requested by the customer, if applicable.
	RequestedValues []string `json:"requestedValues"`
	// The interval at which usage resets automatically, such as monthly or yearly.
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// Detailed configuration object specifying the usage reset schedule.
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	ResourceID               *string                  `json:"resourceId"`
	// List of entitlement summaries per feature, including source and effective values.
	Summaries []*EntitlementSummary `json:"summaries"`
	// The maximum allowed usage for this entitlement before restrictions apply.
	UsageLimit *float64 `json:"usageLimit"`
	// The anchor for calculating the usage period for metered entitlements with a reset period configured
	UsagePeriodAnchor *string `json:"usagePeriodAnchor"`
	// The end date of the usage period for metered entitlements with a reset period configured
	UsagePeriodEnd *string `json:"usagePeriodEnd"`
	// The start date of the usage period for metered entitlements with a reset period configured
	UsagePeriodStart *string `json:"usagePeriodStart"`
	// Timestamp of the last update to the usage value.
	UsageUpdatedAt *string `json:"usageUpdatedAt"`
}

// Event payload for when entitlements are updated for a customer.
type EntitlementsUpdated struct {
	// The unique identifier for the account
	AccountID string `json:"accountId"`
	// Identifier of the customer whose entitlements have changed.
	CustomerID string `json:"customerId"`
	// The updated list of entitlements for the customer.
	Entitlements []*Entitlement `json:"entitlements"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The resource the entitlement update is scoped to.
	ResourceID *string `json:"resourceId"`
}

// Feature enum configuration entity
type EnumConfigurationEntity struct {
	// The deletion date for soft-deleted enum configuration entities
	DeletedAt *string `json:"deletedAt"`
	// The display name for the enum configuration entity
	DisplayName string `json:"displayName"`
	// The unique value identifier for the enum configuration entity
	Value string `json:"value"`
}

// Feature enum configuration entity
type EnumConfigurationEntityInput struct {
	// The display name for the enum configuration entity
	DisplayName string `json:"displayName"`
	// The unique value identifier for the enum configuration entity
	Value string `json:"value"`
}

// An environment object
type Environment struct {
	Account *Account  `json:"account"`
	APIKeys []*APIKey `json:"apiKeys"`
	// The color associated with the environment, used for UI representation
	Color *string `json:"color"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The description of the environment
	Description *string `json:"description"`
	// The display name of the environment
	DisplayName string `json:"displayName"`
	// Whether hardened client access is enabled for the environment
	HardenClientAccessEnabled bool `json:"hardenClientAccessEnabled"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Whether the environment is a sandbox environment
	IsSandbox bool `json:"isSandbox"`
	// The date when the environment will be permanently deleted, if applicable
	PermanentDeletionDate *string `json:"permanentDeletionDate"`
	// The provisioning status of the environment, e.g. "PROVISIONED" or "PROVISIONING"
	ProvisionStatus *EnvironmentProvisionStatus `json:"provisionStatus"`
	// The signing token for the environment, used for secure communication
	SigningToken string `json:"signingToken"`
	// The slug of the environment, used in URLs
	Slug string `json:"slug"`
	// The type of the environment, e.g. "DEVELOPMENT", "PRODUCTION", or "SANDBOX"
	Type EnvironmentType `json:"type"`
}

type EnvironmentAggregateGroupBy struct {
	CreatedAt             *string `json:"createdAt"`
	DisplayName           *string `json:"displayName"`
	ID                    *string `json:"id"`
	PermanentDeletionDate *string `json:"permanentDeletionDate"`
	Slug                  *string `json:"slug"`
}

type EnvironmentConnection struct {
	// Array of edges.
	Edges []*EnvironmentEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type EnvironmentCountAggregate struct {
	CreatedAt             *int64 `json:"createdAt"`
	DisplayName           *int64 `json:"displayName"`
	ID                    *int64 `json:"id"`
	PermanentDeletionDate *int64 `json:"permanentDeletionDate"`
	Slug                  *int64 `json:"slug"`
}

type EnvironmentEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Environment
	Node Environment `json:"node"`
}

type EnvironmentFilter struct {
	And                   []*EnvironmentFilter   `json:"and,omitempty"`
	CreatedAt             *DateFieldComparison   `json:"createdAt,omitempty"`
	DisplayName           *StringFieldComparison `json:"displayName,omitempty"`
	ID                    *UUIDFilterComparison  `json:"id,omitempty"`
	Or                    []*EnvironmentFilter   `json:"or,omitempty"`
	PermanentDeletionDate *DateFieldComparison   `json:"permanentDeletionDate,omitempty"`
	Slug                  *StringFieldComparison `json:"slug,omitempty"`
}

// Input for updating an existing environment
type EnvironmentInput struct {
	// The color used to distinguish this environment in the UI
	Color *string `json:"color,omitempty"`
	// Optional description of the environment
	Description *string `json:"description,omitempty"`
	// The name of the environment that will be displayed in the UI
	DisplayName *string `json:"displayName,omitempty"`
	// Whether client-side security hardening is enabled for this environment
	HardenClientAccessEnabled *bool `json:"hardenClientAccessEnabled,omitempty"`
	// The current provisioning status of the environment
	ProvisionStatus *EnvironmentProvisionStatus `json:"provisionStatus,omitempty"`
}

type EnvironmentMaxAggregate struct {
	CreatedAt             *string `json:"createdAt"`
	DisplayName           *string `json:"displayName"`
	ID                    *string `json:"id"`
	PermanentDeletionDate *string `json:"permanentDeletionDate"`
	Slug                  *string `json:"slug"`
}

// Configuration options for customizing an environment merge or comparison process
type EnvironmentMergeConfigurationInput struct {
	// Whether to include coupons in the merge or comparison. Defaults to true if not specified
	IncludeCoupons *bool `json:"includeCoupons,omitempty"`
}

type EnvironmentMinAggregate struct {
	CreatedAt             *string `json:"createdAt"`
	DisplayName           *string `json:"displayName"`
	ID                    *string `json:"id"`
	PermanentDeletionDate *string `json:"permanentDeletionDate"`
	Slug                  *string `json:"slug"`
}

type EnvironmentMissingError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type EnvironmentSort struct {
	Direction SortDirection         `json:"direction"`
	Field     EnvironmentSortFields `json:"field"`
	Nulls     *SortNulls            `json:"nulls,omitempty"`
}

type EstimateSubscriptionInput struct {
	Addons []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon      *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	BillableFeatures   []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingCountryCode *string                  `json:"billingCountryCode,omitempty"`
	BillingInformation *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod      *BillingPeriod           `json:"billingPeriod,omitempty"`
	CustomerID         string                   `json:"customerId"`
	EnvironmentID      *string                  `json:"environmentId,omitempty"`
	// The customer that will pay for the subscription
	PayingCustomerID *string  `json:"payingCustomerId,omitempty"`
	PlanID           string   `json:"planId"`
	PriceUnitAmount  *float64 `json:"priceUnitAmount,omitempty"`
	PromotionCode    *string  `json:"promotionCode,omitempty"`
	ResourceID       *string  `json:"resourceId,omitempty"`
	SkipTrial        *bool    `json:"skipTrial,omitempty"`
	StartDate        *string  `json:"startDate,omitempty"`
	// trial configuration to override the default values from plan if exists
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

type EstimateSubscriptionUpdateInput struct {
	Addons []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon    *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	BillableFeatures []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	EnvironmentID    *string                  `json:"environmentId,omitempty"`
	PromotionCode    *string                  `json:"promotionCode,omitempty"`
	SubscriptionID   string                   `json:"subscriptionId"`
	UnitQuantity     *float64                 `json:"unitQuantity,omitempty"`
}

// Event actor information
type EventActorInfo struct {
	// Actor email
	Email *string `json:"email"`
	// Actor IP address
	IPAddress *string `json:"ipAddress"`
	// Actor name
	Name *string `json:"name"`
	// Type of the actor (e.g., service, user, system, workflow)
	Type *EventActor `json:"type"`
	// Workflow execution ID
	WorkflowExecutionID *string `json:"workflowExecutionId"`
	// Workflow execution time
	WorkflowExecutionTime *string `json:"workflowExecutionTime"`
	// Workflow ID
	WorkflowID *string `json:"workflowId"`
	// Workflow name
	WorkflowName *string `json:"workflowName"`
}

// Event log information
type EventLog struct {
	// The unique identifier for the account
	AccountID string `json:"accountId"`
	// Actor information
	Actor *EventActorInfo `json:"actor"`
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// The entity id of this event
	EntityID *string `json:"entityId"`
	// The event entity type
	EntityType *EventEntityType `json:"entityType"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The type of the event
	EventLogType EventLogType `json:"eventLogType"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The parent entity id of this events entity
	ParentEntityID *string `json:"parentEntityId"`
	// The payload of the event
	Payload map[string]interface{} `json:"payload"`
	// Request information
	Request *EventRequest `json:"request"`
	// List of webhooks endpoints this event was configured to be sent to
	Webhooks []*EventWebhook `json:"webhooks"`
}

type EventLogAggregateGroupBy struct {
	CreatedAt      *string       `json:"createdAt"`
	EntityID       *string       `json:"entityId"`
	EnvironmentID  *string       `json:"environmentId"`
	EventLogType   *EventLogType `json:"eventLogType"`
	ID             *string       `json:"id"`
	ParentEntityID *string       `json:"parentEntityId"`
}

type EventLogConnection struct {
	// Array of edges.
	Edges []*EventLogEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type EventLogCountAggregate struct {
	CreatedAt      *int64 `json:"createdAt"`
	EntityID       *int64 `json:"entityId"`
	EnvironmentID  *int64 `json:"environmentId"`
	EventLogType   *int64 `json:"eventLogType"`
	ID             *int64 `json:"id"`
	ParentEntityID *int64 `json:"parentEntityId"`
}

type EventLogCreatedAtFilterComparison struct {
	Gte *string `json:"gte,omitempty"`
	Lte *string `json:"lte,omitempty"`
}

type EventLogEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the EventLog
	Node EventLog `json:"node"`
}

type EventLogEntityIDFilterComparison struct {
	Eq *string  `json:"eq,omitempty"`
	In []string `json:"in,omitempty"`
}

type EventLogEnvironmentIDFilterComparison struct {
	Eq *string `json:"eq,omitempty"`
}

type EventLogEventLogTypeFilterComparison struct {
	Eq    *EventLogType  `json:"eq,omitempty"`
	In    []EventLogType `json:"in,omitempty"`
	Neq   *EventLogType  `json:"neq,omitempty"`
	NotIn []EventLogType `json:"notIn,omitempty"`
}

type EventLogFilter struct {
	And            []*EventLogFilter                       `json:"and,omitempty"`
	CreatedAt      *EventLogCreatedAtFilterComparison      `json:"createdAt,omitempty"`
	EntityID       *EventLogEntityIDFilterComparison       `json:"entityId,omitempty"`
	EnvironmentID  EventLogEnvironmentIDFilterComparison   `json:"environmentId"`
	EventLogType   *EventLogEventLogTypeFilterComparison   `json:"eventLogType,omitempty"`
	ID             *EventLogIDFilterComparison             `json:"id,omitempty"`
	Or             []*EventLogFilter                       `json:"or,omitempty"`
	ParentEntityID *EventLogParentEntityIDFilterComparison `json:"parentEntityId,omitempty"`
}

type EventLogIDFilterComparison struct {
	Eq *string `json:"eq,omitempty"`
}

type EventLogMaxAggregate struct {
	CreatedAt      *string       `json:"createdAt"`
	EntityID       *string       `json:"entityId"`
	EnvironmentID  *string       `json:"environmentId"`
	EventLogType   *EventLogType `json:"eventLogType"`
	ID             *string       `json:"id"`
	ParentEntityID *string       `json:"parentEntityId"`
}

type EventLogMinAggregate struct {
	CreatedAt      *string       `json:"createdAt"`
	EntityID       *string       `json:"entityId"`
	EnvironmentID  *string       `json:"environmentId"`
	EventLogType   *EventLogType `json:"eventLogType"`
	ID             *string       `json:"id"`
	ParentEntityID *string       `json:"parentEntityId"`
}

type EventLogParentEntityIDFilterComparison struct {
	Eq *string  `json:"eq,omitempty"`
	In []string `json:"in,omitempty"`
}

type EventLogSort struct {
	Direction SortDirection      `json:"direction"`
	Field     EventLogSortFields `json:"field"`
	Nulls     *SortNulls         `json:"nulls,omitempty"`
}

// Event request properties
type EventRequest struct {
	// The request body
	Body map[string]interface{} `json:"body"`
	// The request response
	Response map[string]interface{} `json:"response"`
	// The request trace ID
	TraceID *string `json:"traceId"`
}

// An event webhook entity
type EventWebhook struct {
	// The endpoint of the webhook
	Endpoint string `json:"endpoint"`
	// Unique identifier for the entity
	ID string `json:"id"`
}

// Events fields
type EventsFields struct {
	// Fields included in the events data
	Fields map[string]interface{} `json:"fields"`
}

// Input parameters for retrieving events fields
type EventsFieldsInput struct {
	// Customer id
	CustomerID *string `json:"customerId,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Reference identifier for the feature
	FeatureID *string `json:"featureId,omitempty"`
	// Filters to apply to the events fields
	Filters []*MeterFilterDefinitionInput `json:"filters,omitempty"`
	// Meter id
	MeterID *string `json:"meterId,omitempty"`
	// Resource id
	ResourceID *string `json:"resourceId,omitempty"`
	// Exclude fields with more than this number of unique values
	UniqueValuesLimit *float64 `json:"uniqueValuesLimit,omitempty"`
}

// An experiment for A/B testing
type Experiment struct {
	// Name for the control group
	ControlGroupName string `json:"controlGroupName"`
	// Timestamp of when the record was created
	CreatedAt string    `json:"createdAt"`
	Customers *Customer `json:"customers"`
	// Description of the experiements
	Description *string      `json:"description"`
	Environment *Environment `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The product settings for the control group
	InitialProductSettings *ProductSettings `json:"initialProductSettings"`
	// Name of the experiment
	Name    string   `json:"name"`
	Product *Product `json:"product"`
	// Internal identifier for the product experiment is associated with
	ProductID string `json:"productId"`
	// Product settings for the variant group
	ProductSettings ProductSettings `json:"productSettings"`
	// The unique identifier for the experiment
	RefID string `json:"refId"`
	// Start date of the experiment
	StartedAt *string `json:"startedAt"`
	// The status of the experiment
	Status ExperimentStatus `json:"status"`
	// Stop date of the experiment
	StoppedAt *string `json:"stoppedAt"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
	// Name for the variant group
	VariantGroupName string `json:"variantGroupName"`
	// Percentage of users in the variant group
	VariantPercentage float64 `json:"variantPercentage"`
}

type ExperimentAggregateGroupBy struct {
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	ProductID     *string           `json:"productId"`
	RefID         *string           `json:"refId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentConnection struct {
	// Array of edges.
	Edges []*ExperimentEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type ExperimentCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Name          *int64 `json:"name"`
	ProductID     *int64 `json:"productId"`
	RefID         *int64 `json:"refId"`
	Status        *int64 `json:"status"`
}

type ExperimentEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Experiment
	Node Experiment `json:"node"`
}

type ExperimentFilter struct {
	And           []*ExperimentFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison              `json:"createdAt,omitempty"`
	Customers     *ExperimentFilterCustomerFilter   `json:"customers,omitempty"`
	EnvironmentID *UUIDFilterComparison             `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison             `json:"id,omitempty"`
	Name          *StringFieldComparison            `json:"name,omitempty"`
	Or            []*ExperimentFilter               `json:"or,omitempty"`
	ProductID     *StringFieldComparison            `json:"productId,omitempty"`
	RefID         *StringFieldComparison            `json:"refId,omitempty"`
	Status        *ExperimentStatusFilterComparison `json:"status,omitempty"`
}

type ExperimentFilterCustomerFilter struct {
	And                  []*ExperimentFilterCustomerFilter    `json:"and,omitempty"`
	BillingID            *StringFieldComparison               `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                 `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison               `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison               `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison               `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison               `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                 `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison               `json:"email,omitempty"`
	EnvironmentID        *UUIDFilterComparison                `json:"environmentId,omitempty"`
	ID                   *UUIDFilterComparison                `json:"id,omitempty"`
	Name                 *StringFieldComparison               `json:"name,omitempty"`
	Or                   []*ExperimentFilterCustomerFilter    `json:"or,omitempty"`
	RefID                *StringFieldComparison               `json:"refId,omitempty"`
	SalesforceID         *StringFieldComparison               `json:"salesforceId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                 `json:"updatedAt,omitempty"`
}

type ExperimentMaxAggregate struct {
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	ProductID     *string           `json:"productId"`
	RefID         *string           `json:"refId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentMinAggregate struct {
	CreatedAt     *string           `json:"createdAt"`
	EnvironmentID *string           `json:"environmentId"`
	ID            *string           `json:"id"`
	Name          *string           `json:"name"`
	ProductID     *string           `json:"productId"`
	RefID         *string           `json:"refId"`
	Status        *ExperimentStatus `json:"status"`
}

type ExperimentSort struct {
	Direction SortDirection        `json:"direction"`
	Field     ExperimentSortFields `json:"field"`
	Nulls     *SortNulls           `json:"nulls,omitempty"`
}

// Statistics and metrics for the experiment
type ExperimentStats struct {
	// Number of paid subscriptions in the control group
	ControlPaidSubscriptions float64 `json:"controlPaidSubscriptions"`
	// Total number of subscriptions in the control group
	ControlSubscriptions float64 `json:"controlSubscriptions"`
	// Number of paid subscriptions in the variant group
	VariantPaidSubscriptions float64 `json:"variantPaidSubscriptions"`
	// Total number of subscriptions in the variant group
	VariantSubscriptions float64 `json:"variantSubscriptions"`
}

// Query parameters for retrieving experiment statistics
type ExperimentStatsQuery struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The unique identifier for the experiment
	ExperimentRefID string `json:"experimentRefId"`
}

type ExperimentStatusFilterComparison struct {
	Eq       *ExperimentStatus  `json:"eq,omitempty"`
	Gt       *ExperimentStatus  `json:"gt,omitempty"`
	Gte      *ExperimentStatus  `json:"gte,omitempty"`
	ILike    *ExperimentStatus  `json:"iLike,omitempty"`
	In       []ExperimentStatus `json:"in,omitempty"`
	Is       *bool              `json:"is,omitempty"`
	IsNot    *bool              `json:"isNot,omitempty"`
	Like     *ExperimentStatus  `json:"like,omitempty"`
	Lt       *ExperimentStatus  `json:"lt,omitempty"`
	Lte      *ExperimentStatus  `json:"lte,omitempty"`
	Neq      *ExperimentStatus  `json:"neq,omitempty"`
	NotILike *ExperimentStatus  `json:"notILike,omitempty"`
	NotIn    []ExperimentStatus `json:"notIn,omitempty"`
	NotLike  *ExperimentStatus  `json:"notLike,omitempty"`
}

type FailedToImportCustomerError struct {
	BillingID         string   `json:"billingId"`
	Code              string   `json:"code"`
	FailedBillingIds  []string `json:"failedBillingIds"`
	FailedCustomerIds []string `json:"failedCustomerIds"`
	IsValidationError bool     `json:"isValidationError"`
}

// Feature DTO
type Feature struct {
	Account *Account `json:"account"`
	// The additional metadata for the feature
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The description for the feature
	Description *string `json:"description"`
	// The display name for the feature
	DisplayName string `json:"displayName"`
	// The configuration data for the enum feature
	EnumConfiguration []*EnumConfigurationEntity `json:"enumConfiguration"`
	Environment       *Environment               `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The status of the feature
	FeatureStatus FeatureStatus `json:"featureStatus"`
	// The type of the feature
	FeatureType FeatureType `json:"featureType"`
	// The units for the feature
	FeatureUnits *string `json:"featureUnits"`
	// The plural units for the feature
	FeatureUnitsPlural *string `json:"featureUnitsPlural"`
	// Whether the feature has entitlements
	HasEntitlements *bool `json:"hasEntitlements"`
	// Whether the feature has a meter
	HasMeter *bool `json:"hasMeter"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Get the meter for the feature
	Meter *Meter `json:"meter"`
	// The meter type for the feature
	MeterType *MeterType `json:"meterType"`
	// The unique identifier for the feature
	RefID string `json:"refId"`
	// Unit transformation to be applied to the reported usage
	UnitTransformation *UnitTransformation `json:"unitTransformation"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
	// The enum values used by plans or add-ons
	UsedEnumValues []string `json:"usedEnumValues"`
}

type FeatureAggregateGroupBy struct {
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	FeatureType   *FeatureType   `json:"featureType"`
	ID            *string        `json:"id"`
	MeterType     *MeterType     `json:"meterType"`
	RefID         *string        `json:"refId"`
	UpdatedAt     *string        `json:"updatedAt"`
}

// Input for getting the associated latest packages for a feature
type FeatureAssociatedLatestPackages struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The ID of the feature
	FeatureID string `json:"featureId"`
}

type FeatureConnection struct {
	// Array of edges.
	Edges []*FeatureEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type FeatureCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	DisplayName   *int64 `json:"displayName"`
	EnvironmentID *int64 `json:"environmentId"`
	FeatureStatus *int64 `json:"featureStatus"`
	FeatureType   *int64 `json:"featureType"`
	ID            *int64 `json:"id"`
	MeterType     *int64 `json:"meterType"`
	RefID         *int64 `json:"refId"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type FeatureEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Feature
	Node Feature `json:"node"`
}

type FeatureFilter struct {
	And           []*FeatureFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison          `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison   `json:"featureType,omitempty"`
	ID            *UUIDFilterComparison          `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison     `json:"meterType,omitempty"`
	Or            []*FeatureFilter               `json:"or,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
}

// A set of features grouped together
type FeatureGroup struct {
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// The description of the feature group
	Description *string `json:"description"`
	// The display name of the feature group
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The feature group id
	FeatureGroupID string `json:"featureGroupId"`
	// The features in the feature group
	Features []*Feature `json:"features"`
	// The internal id of the feature group
	ID string `json:"id"`
	// Indicates if this is the latest version of the feature group
	IsLatest bool `json:"isLatest"`
	// The status of the feature group (published, archived)
	Status FeatureGroupStatus `json:"status"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
	// The version number of the feature group
	VersionNumber int64 `json:"versionNumber"`
}

type FeatureGroupAggregateGroupBy struct {
	CreatedAt      *string             `json:"createdAt"`
	DisplayName    *string             `json:"displayName"`
	EnvironmentID  *string             `json:"environmentId"`
	FeatureGroupID *string             `json:"featureGroupId"`
	ID             *string             `json:"id"`
	IsLatest       *bool               `json:"isLatest"`
	Status         *FeatureGroupStatus `json:"status"`
	UpdatedAt      *string             `json:"updatedAt"`
	VersionNumber  *int64              `json:"versionNumber"`
}

type FeatureGroupAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type FeatureGroupConnection struct {
	// Array of edges.
	Edges []*FeatureGroupEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type FeatureGroupCountAggregate struct {
	CreatedAt      *int64 `json:"createdAt"`
	DisplayName    *int64 `json:"displayName"`
	EnvironmentID  *int64 `json:"environmentId"`
	FeatureGroupID *int64 `json:"featureGroupId"`
	ID             *int64 `json:"id"`
	IsLatest       *int64 `json:"isLatest"`
	Status         *int64 `json:"status"`
	UpdatedAt      *int64 `json:"updatedAt"`
	VersionNumber  *int64 `json:"versionNumber"`
}

type FeatureGroupEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the FeatureGroup
	Node FeatureGroup `json:"node"`
}

type FeatureGroupFilter struct {
	And            []*FeatureGroupFilter               `json:"and,omitempty"`
	CreatedAt      *DateFieldComparison                `json:"createdAt,omitempty"`
	DisplayName    *StringFieldComparison              `json:"displayName,omitempty"`
	EnvironmentID  *UUIDFilterComparison               `json:"environmentId,omitempty"`
	FeatureGroupID *StringFieldComparison              `json:"featureGroupId,omitempty"`
	ID             *UUIDFilterComparison               `json:"id,omitempty"`
	IsLatest       *BooleanFieldComparison             `json:"isLatest,omitempty"`
	Or             []*FeatureGroupFilter               `json:"or,omitempty"`
	Status         *FeatureGroupStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt      *DateFieldComparison                `json:"updatedAt,omitempty"`
	VersionNumber  *IntFieldComparison                 `json:"versionNumber,omitempty"`
}

type FeatureGroupMaxAggregate struct {
	CreatedAt      *string             `json:"createdAt"`
	DisplayName    *string             `json:"displayName"`
	EnvironmentID  *string             `json:"environmentId"`
	FeatureGroupID *string             `json:"featureGroupId"`
	ID             *string             `json:"id"`
	Status         *FeatureGroupStatus `json:"status"`
	UpdatedAt      *string             `json:"updatedAt"`
	VersionNumber  *int64              `json:"versionNumber"`
}

type FeatureGroupMinAggregate struct {
	CreatedAt      *string             `json:"createdAt"`
	DisplayName    *string             `json:"displayName"`
	EnvironmentID  *string             `json:"environmentId"`
	FeatureGroupID *string             `json:"featureGroupId"`
	ID             *string             `json:"id"`
	Status         *FeatureGroupStatus `json:"status"`
	UpdatedAt      *string             `json:"updatedAt"`
	VersionNumber  *int64              `json:"versionNumber"`
}

type FeatureGroupSort struct {
	Direction SortDirection          `json:"direction"`
	Field     FeatureGroupSortFields `json:"field"`
	Nulls     *SortNulls             `json:"nulls,omitempty"`
}

type FeatureGroupStatusFilterComparison struct {
	Eq       *FeatureGroupStatus  `json:"eq,omitempty"`
	Gt       *FeatureGroupStatus  `json:"gt,omitempty"`
	Gte      *FeatureGroupStatus  `json:"gte,omitempty"`
	ILike    *FeatureGroupStatus  `json:"iLike,omitempty"`
	In       []FeatureGroupStatus `json:"in,omitempty"`
	Is       *bool                `json:"is,omitempty"`
	IsNot    *bool                `json:"isNot,omitempty"`
	Like     *FeatureGroupStatus  `json:"like,omitempty"`
	Lt       *FeatureGroupStatus  `json:"lt,omitempty"`
	Lte      *FeatureGroupStatus  `json:"lte,omitempty"`
	Neq      *FeatureGroupStatus  `json:"neq,omitempty"`
	NotILike *FeatureGroupStatus  `json:"notILike,omitempty"`
	NotIn    []FeatureGroupStatus `json:"notIn,omitempty"`
	NotLike  *FeatureGroupStatus  `json:"notLike,omitempty"`
}

type FeatureGroupSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

// Input for creating a feature
type FeatureInput struct {
	// The additional metadata for the feature
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The description for the feature
	Description *string `json:"description,omitempty"`
	// The display name for the feature
	DisplayName string `json:"displayName"`
	// The configuration data for the feature
	EnumConfiguration []*EnumConfigurationEntityInput `json:"enumConfiguration,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The status of the feature
	FeatureStatus *FeatureStatus `json:"featureStatus,omitempty"`
	// The type of the feature
	FeatureType FeatureType `json:"featureType"`
	// The units for the feature
	FeatureUnits *string `json:"featureUnits,omitempty"`
	// The plural units for the feature
	FeatureUnitsPlural *string `json:"featureUnitsPlural,omitempty"`
	// Input for creating a meter
	Meter *CreateMeter `json:"meter,omitempty"`
	// The meter type for the feature
	MeterType *MeterType `json:"meterType,omitempty"`
	// The unique identifier for the feature
	RefID string `json:"refId"`
	// Unit transformation to be applied to the reported usage
	UnitTransformation *UnitTransformationInput `json:"unitTransformation,omitempty"`
}

type FeatureMaxAggregate struct {
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	FeatureType   *FeatureType   `json:"featureType"`
	ID            *string        `json:"id"`
	MeterType     *MeterType     `json:"meterType"`
	RefID         *string        `json:"refId"`
	UpdatedAt     *string        `json:"updatedAt"`
}

type FeatureMinAggregate struct {
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	FeatureStatus *FeatureStatus `json:"featureStatus"`
	FeatureType   *FeatureType   `json:"featureType"`
	ID            *string        `json:"id"`
	MeterType     *MeterType     `json:"meterType"`
	RefID         *string        `json:"refId"`
	UpdatedAt     *string        `json:"updatedAt"`
}

type FeatureNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type FeatureSort struct {
	Direction SortDirection     `json:"direction"`
	Field     FeatureSortFields `json:"field"`
	Nulls     *SortNulls        `json:"nulls,omitempty"`
}

type FeatureStatusFilterComparison struct {
	Eq       *FeatureStatus  `json:"eq,omitempty"`
	Gt       *FeatureStatus  `json:"gt,omitempty"`
	Gte      *FeatureStatus  `json:"gte,omitempty"`
	ILike    *FeatureStatus  `json:"iLike,omitempty"`
	In       []FeatureStatus `json:"in,omitempty"`
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Like     *FeatureStatus  `json:"like,omitempty"`
	Lt       *FeatureStatus  `json:"lt,omitempty"`
	Lte      *FeatureStatus  `json:"lte,omitempty"`
	Neq      *FeatureStatus  `json:"neq,omitempty"`
	NotILike *FeatureStatus  `json:"notILike,omitempty"`
	NotIn    []FeatureStatus `json:"notIn,omitempty"`
	NotLike  *FeatureStatus  `json:"notLike,omitempty"`
}

type FeatureTypeFilterComparison struct {
	Eq       *FeatureType  `json:"eq,omitempty"`
	Gt       *FeatureType  `json:"gt,omitempty"`
	Gte      *FeatureType  `json:"gte,omitempty"`
	ILike    *FeatureType  `json:"iLike,omitempty"`
	In       []FeatureType `json:"in,omitempty"`
	Is       *bool         `json:"is,omitempty"`
	IsNot    *bool         `json:"isNot,omitempty"`
	Like     *FeatureType  `json:"like,omitempty"`
	Lt       *FeatureType  `json:"lt,omitempty"`
	Lte      *FeatureType  `json:"lte,omitempty"`
	Neq      *FeatureType  `json:"neq,omitempty"`
	NotILike *FeatureType  `json:"notILike,omitempty"`
	NotIn    []FeatureType `json:"notIn,omitempty"`
	NotLike  *FeatureType  `json:"notLike,omitempty"`
}

// Query for fetching a single entitlement for a specific feature and customer.
type FetchEntitlementQuery struct {
	// Identifier of the customer.
	CustomerID string `json:"customerId"`
	// The environment identifier used to resolve the entitlement context.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The internal ID of the feature linked to this entitlement.
	FeatureID string `json:"featureId"`
	// Options for configuring how an entitlement is tracked or applied.
	Options *EntitlementOptions `json:"options,omitempty"`
	// The scoped resource Identifier.
	ResourceID *string `json:"resourceId,omitempty"`
}

// Query for retrieving all entitlements for a customer in a specific environment.
type FetchEntitlementsQuery struct {
	// Identifier of the customer.
	CustomerID string `json:"customerId"`
	// The environment context for entitlement resolution.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The scoped resource Identifier.
	ResourceID *string `json:"resourceId,omitempty"`
}

// Typography settings for a single font variant.
type FontVariant struct {
	// Font size for the variant.
	FontSize *float64 `json:"fontSize"`
	// Font weight, such as normal or bold.
	FontWeight *FontWeight `json:"fontWeight"`
}

// Input for defining font style for a text variant.
type FontVariantInput struct {
	// Size of the text in px or rem.
	FontSize *float64 `json:"fontSize,omitempty"`
	// Weight of the font, such as normal or bold.
	FontWeight *FontWeight `json:"fontWeight,omitempty"`
}

// Free subscription item
type FreeSubscriptionItem struct {
	// The add-on id
	AddonID string `json:"addonId"`
	// The quantity of free items
	Quantity float64 `json:"quantity"`
}

type GetActiveSubscriptionsInput struct {
	CustomerID    string   `json:"customerId"`
	EnvironmentID *string  `json:"environmentId,omitempty"`
	ResourceID    *string  `json:"resourceId,omitempty"`
	ResourceIds   []string `json:"resourceIds,omitempty"`
}

// Input configuration for retrieving Auth0 applications
type GetAuth0ApplicationsInput struct {
	// Domain of the Auth0 client
	ClientDomain string `json:"clientDomain"`
	// ID of the Auth0 client
	ClientID string `json:"clientId"`
	// Secret of the Auth0 client
	ClientSecret string `json:"clientSecret"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// AWS external ID for secure cross-account access
type GetAwsExternalIDResult struct {
	// Generated external ID for AWS IAM role trust relationship
	ExternalID string `json:"externalId"`
}

// Get a customer by slug
type GetCustomerByRefIDInput struct {
	// Customer slug
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Get Package By Ref Id Input
type GetPackageByRefIDInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// The version number of the package
	VersionNumber *float64 `json:"versionNumber,omitempty"`
}

// The input type for getting a package group
type GetPackageGroup struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The id of the package group to filter by
	PackageGroupID string `json:"packageGroupId"`
	// The version number of the package group to filter by
	VersionNumber *float64 `json:"versionNumber,omitempty"`
}

// Input for fetching the paywall
type GetPaywallInput struct {
	// The country code for billing, e.g. US
	BillingCountryCode *string `json:"billingCountryCode,omitempty"`
	// Context for the paywall, e.g. "checkout" or "subscription"
	Context *WidgetType `json:"context,omitempty"`
	// The customer ID for whom the paywall is being fetched
	CustomerID *string `json:"customerId,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Whether to fetch prices for all countries or just the specified billing country
	FetchAllCountriesPrices *bool `json:"fetchAllCountriesPrices,omitempty"`
	// Whether to include hidden plans in the paywall
	IncludeHiddenPlans *bool `json:"includeHiddenPlans,omitempty"`
	// The product ID for which the paywall is being fetched
	ProductID *string `json:"productId,omitempty"`
	// The resource ID for which the paywall is being fetched
	ResourceID *string `json:"resourceId,omitempty"`
}

// Get subscription input
type GetSubscriptionInput struct {
	// The environment ID the subscription belongs to
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The subscription ID to retrieve
	SubscriptionID string `json:"subscriptionId"`
}

// Input object used to retrieve current widget configuration for the environment.
type GetWidgetConfigurationInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Get workflow triggers input
type GetWorkflowTriggersInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Trigger id
	TriggerID *string `json:"triggerId,omitempty"`
	// Workflow trigger id
	WorkflowTriggerID *string `json:"workflowTriggerId,omitempty"`
}

// Grant promotional entitlement input
type GrantPromotionalEntitlementInput struct {
	// The custom end date of the promotional entitlement
	CustomEndDate *string `json:"customEndDate,omitempty"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Whether the entitlement is visible
	IsVisible *bool `json:"isVisible,omitempty"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The grant period of the promotional entitlement
	Period PromotionalEntitlementPeriod `json:"period"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the entitlement, defined when reset period is yearly
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

// Grant multiple promotional entitlements input
type GrantPromotionalEntitlementsInput struct {
	// The unique identifier of the entitlement customer
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Promotional entitlements to grant
	PromotionalEntitlements []*GrantPromotionalEntitlementInput `json:"promotionalEntitlements"`
}

// Group info
type GroupInfo struct {
	// The key representing the group
	Key string `json:"key"`
	// The value associated with the group key
	Value string `json:"value"`
}

// Group usage history
type GroupUsageHistory struct {
	// Information about the group
	GroupInfo []*GroupInfo `json:"groupInfo"`
	// List of usage measurements for the group
	UsageMeasurements []*UsageMeasurementPoint `json:"usageMeasurements"`
}

// Hidden from widgets change
type HiddenFromWidgetsChange struct {
	// The value after the change
	After []WidgetType `json:"after"`
	// The value before the change
	Before []WidgetType `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Webhook
type Hook struct {
	Account *Account `json:"account"`
	// A JSON containing the configuration for each event log type
	Configuration map[string]interface{} `json:"configuration"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Webhook description
	Description *string `json:"description"`
	// The Webhook endpoint URL
	Endpoint    string       `json:"endpoint"`
	Environment *Environment `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The event types that the webhook will be triggered on
	EventLogTypes []EventLogType `json:"eventLogTypes"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Secret key for the webhook
	SecretKey *string `json:"secretKey"`
	// The status of the webhook
	Status HookStatus `json:"status"`
}

type HookAggregateGroupBy struct {
	CreatedAt     *string     `json:"createdAt"`
	Endpoint      *string     `json:"endpoint"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *HookStatus `json:"status"`
}

type HookConnection struct {
	// Array of edges.
	Edges []*HookEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type HookCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	Endpoint      *int64 `json:"endpoint"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
}

type HookDeleteResponse struct {
	// A JSON containing the configuration for each event log type
	Configuration map[string]interface{} `json:"configuration"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Webhook description
	Description *string `json:"description"`
	// The Webhook endpoint URL
	Endpoint *string `json:"endpoint"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// The event types that the webhook will be triggered on
	EventLogTypes []EventLogType `json:"eventLogTypes"`
	// Unique identifier for the entity
	ID *string `json:"id"`
	// Secret key for the webhook
	SecretKey *string `json:"secretKey"`
	// The status of the webhook
	Status *HookStatus `json:"status"`
}

type HookEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Hook
	Node Hook `json:"node"`
}

type HookFilter struct {
	And           []*HookFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison        `json:"createdAt,omitempty"`
	Endpoint      *StringFieldComparison      `json:"endpoint,omitempty"`
	EnvironmentID *UUIDFilterComparison       `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison       `json:"id,omitempty"`
	Or            []*HookFilter               `json:"or,omitempty"`
	Status        *HookStatusFilterComparison `json:"status,omitempty"`
}

type HookMaxAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	Endpoint      *string     `json:"endpoint"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *HookStatus `json:"status"`
}

type HookMinAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	Endpoint      *string     `json:"endpoint"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *HookStatus `json:"status"`
}

type HookSort struct {
	Direction SortDirection  `json:"direction"`
	Field     HookSortFields `json:"field"`
	Nulls     *SortNulls     `json:"nulls,omitempty"`
}

type HookStatusFilterComparison struct {
	Eq       *HookStatus  `json:"eq,omitempty"`
	Gt       *HookStatus  `json:"gt,omitempty"`
	Gte      *HookStatus  `json:"gte,omitempty"`
	ILike    *HookStatus  `json:"iLike,omitempty"`
	In       []HookStatus `json:"in,omitempty"`
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Like     *HookStatus  `json:"like,omitempty"`
	Lt       *HookStatus  `json:"lt,omitempty"`
	Lte      *HookStatus  `json:"lte,omitempty"`
	Neq      *HookStatus  `json:"neq,omitempty"`
	NotILike *HookStatus  `json:"notILike,omitempty"`
	NotIn    []HookStatus `json:"notIn,omitempty"`
	NotLike  *HookStatus  `json:"notLike,omitempty"`
}

// HubSpot integration configuration object
type HubspotCredentials struct {
	// Domain of the HubSpot account
	HubDomain string `json:"hubDomain"`
}

func (HubspotCredentials) IsCredentials() {}

// Input configuration for HubSpot integration
type HubspotCredentialsInput struct {
	// Authorization code for HubSpot
	AuthorizationCode string `json:"authorizationCode"`
	// Refresh token for HubSpot
	RefreshToken *string `json:"refreshToken,omitempty"`
}

type IdentityForbiddenError struct {
	AccessedField        string `json:"accessedField"`
	Code                 string `json:"code"`
	CurrentIdentityType  string `json:"currentIdentityType"`
	IsValidationError    bool   `json:"isValidationError"`
	RequiredIdentityType string `json:"requiredIdentityType"`
}

type ImmediateSubscriptionPreviewInvoice struct {
	Credits         *SubscriptionPreviewCredits  `json:"credits"`
	Discount        *Money                       `json:"discount"`
	DiscountDetails *SubscriptionPreviewDiscount `json:"discountDetails"`
	// The minimum spend adjustment applied to the invoice
	MinimumSpendAdjustment Money                          `json:"minimumSpendAdjustment"`
	Proration              *SubscriptionPreviewProrations `json:"proration"`
	SubTotal               Money                          `json:"subTotal"`
	Tax                    *Money                         `json:"tax"`
	TaxDetails             *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total                  Money                          `json:"total"`
	TotalExcludingTax      Money                          `json:"totalExcludingTax"`
}

type ImportAlreadyInProgressError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

// Input for importing a bulk of customers
type ImportCustomerBulkInput struct {
	// List of customers to import
	Customers []*ImportCustomerInput `json:"customers"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Input for importing a customer
type ImportCustomerInput struct {
	// Additional metadata
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// Id in the billing provider
	BillingID *string `json:"billingId,omitempty"`
	// Customer slug
	CustomerID *string `json:"customerId,omitempty"`
	// Customer email
	Email *string `json:"email,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Customer name
	Name *string `json:"name,omitempty"`
	// Payment method Id in the billing provider
	PaymentMethodID *string `json:"paymentMethodId,omitempty"`
	// Customer slug
	RefID *string `json:"refId,omitempty"`
	// The unique identifier for the customer in Salesforce integration
	SalesforceID *string `json:"salesforceId,omitempty"`
	// Indicates the last update of the customer. In case there's already existing customer that was updated after that date, it will skip import this customer
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Input parameters for importing product catalog from an integration
type ImportIntegrationCatalogInput struct {
	// Billing model configuration for the imported product
	BillingModel *BillingModel `json:"billingModel,omitempty"`
	// Mode for selecting plans to import (blacklist or whitelist)
	EntitySelectionMode EntitySelectionMode `json:"entitySelectionMode"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Singular name for the feature unit
	FeatureUnitName *string `json:"featureUnitName,omitempty"`
	// Plural name for the feature unit
	FeatureUnitPluralName *string `json:"featureUnitPluralName,omitempty"`
	// List of plan IDs to exclude when using blacklist mode
	PlansSelectionBlacklist []string `json:"plansSelectionBlacklist,omitempty"`
	// List of plan IDs to include when using whitelist mode
	PlansSelectionWhitelist []string `json:"plansSelectionWhitelist,omitempty"`
	// Product ID to import from the integration
	ProductID string `json:"productId"`
	// List of addon billing IDs to import
	SelectedAddonBillingIds []string `json:"selectedAddonBillingIds"`
	// The vendor identifier of integration
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

// Input parameters for importing customers from an integration
type ImportIntegrationCustomersInput struct {
	// List of customer IDs to exclude when using blacklist mode
	CustomersSelectionBlacklist []string `json:"customersSelectionBlacklist,omitempty"`
	// List of customer IDs to include when using whitelist mode
	CustomersSelectionWhitelist []string `json:"customersSelectionWhitelist,omitempty"`
	// Mode for selecting customers to import (blacklist or whitelist)
	EntitySelectionMode EntitySelectionMode `json:"entitySelectionMode"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Product ID to import customers from
	ProductID string `json:"productId"`
	// The vendor identifier of integration
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

// Import task
type ImportIntegrationTask struct {
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The number of customers in the import task
	CustomersCount int64 `json:"customersCount"`
	// The end date of the task
	EndDate *string `json:"endDate"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The import errors for the import task
	ImportErrors []*ImportSubTaskError `json:"importErrors"`
	// The number of products in the import task
	ProductsCount int64 `json:"productsCount"`
	// The progress of the task as a percentage, a number between 0 and 100
	Progress int64 `json:"progress"`
	// The start date of the task
	StartDate *string `json:"startDate"`
	// The status of the task
	Status TaskStatus `json:"status"`
	// The type of the task
	TaskType TaskType `json:"taskType"`
	// The total number of import subtasks
	TotalSubtasksCount int64 `json:"totalSubtasksCount"`
}

type ImportIntegrationTaskAggregateGroupBy struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type ImportIntegrationTaskConnection struct {
	// Array of edges.
	Edges []*ImportIntegrationTaskEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type ImportIntegrationTaskCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
	TaskType      *int64 `json:"taskType"`
}

type ImportIntegrationTaskEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the ImportIntegrationTask
	Node ImportIntegrationTask `json:"node"`
}

type ImportIntegrationTaskFilter struct {
	And           []*ImportIntegrationTaskFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison         `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison          `json:"id,omitempty"`
	Or            []*ImportIntegrationTaskFilter `json:"or,omitempty"`
	Status        *TaskStatusFilterComparison    `json:"status,omitempty"`
	TaskType      *TaskTypeFilterComparison      `json:"taskType,omitempty"`
}

type ImportIntegrationTaskMaxAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type ImportIntegrationTaskMinAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type ImportIntegrationTaskSort struct {
	Direction SortDirection                   `json:"direction"`
	Field     ImportIntegrationTaskSortFields `json:"field"`
	Nulls     *SortNulls                      `json:"nulls,omitempty"`
}

// Import subtask error
type ImportSubTaskError struct {
	// The error message of the import subtask
	Error string `json:"error"`
	// The id of the import subtask
	ID string `json:"id"`
}

type ImportSubscriptionInput struct {
	AdditionalMetaData       map[string]interface{}          `json:"additionalMetaData,omitempty"`
	Addons                   []*SubscriptionAddonInput       `json:"addons,omitempty"`
	BillableFeatures         []*BillableFeatureInput         `json:"billableFeatures,omitempty"`
	BillingID                *string                         `json:"billingId,omitempty"`
	BillingPeriod            *BillingPeriod                  `json:"billingPeriod,omitempty"`
	CustomerID               string                          `json:"customerId"`
	EndDate                  *string                         `json:"endDate,omitempty"`
	PlanID                   string                          `json:"planId"`
	ResourceID               *string                         `json:"resourceId,omitempty"`
	SalesforceID             *string                         `json:"salesforceId,omitempty"`
	StartDate                *string                         `json:"startDate,omitempty"`
	SubscriptionEntitlements []*SubscriptionEntitlementInput `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID           *string                         `json:"subscriptionId,omitempty"`
	UnitQuantity             *float64                        `json:"unitQuantity,omitempty"`
	// Indicates the last update of the subscription. In case there's already existing subscription that was updated after that date, it will skip import this subscription
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

type ImportSubscriptionsBulkInput struct {
	EnvironmentID *string                    `json:"environmentId,omitempty"`
	Subscriptions []*ImportSubscriptionInput `json:"subscriptions"`
}

type IncompatibleSubscriptionAddonError struct {
	Code                string   `json:"code"`
	IsValidationError   bool     `json:"isValidationError"`
	NonCompatibleAddons []string `json:"nonCompatibleAddons"`
	PlanDisplayName     string   `json:"planDisplayName"`
}

// Response for initializing a Stripe payment method form
type InitAddStripeCustomerPaymentMethod struct {
	// The client secret for the payment method form
	PaymentIntentClientSecret string `json:"paymentIntentClientSecret"`
}

// Input for initializing a payment method form for a customer
type InitAddStripeCustomerPaymentMethodInput struct {
	// Customer slug
	CustomerRefID string `json:"customerRefId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The billing integration to use for this payment method
	IntegrationID *string `json:"integrationId,omitempty"`
}

type InitStripePaymentMethodError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type IntFieldComparison struct {
	Between    *IntFieldComparisonBetween `json:"between,omitempty"`
	Eq         *int64                     `json:"eq,omitempty"`
	Gt         *int64                     `json:"gt,omitempty"`
	Gte        *int64                     `json:"gte,omitempty"`
	In         []int64                    `json:"in,omitempty"`
	Is         *bool                      `json:"is,omitempty"`
	IsNot      *bool                      `json:"isNot,omitempty"`
	Lt         *int64                     `json:"lt,omitempty"`
	Lte        *int64                     `json:"lte,omitempty"`
	Neq        *int64                     `json:"neq,omitempty"`
	NotBetween *IntFieldComparisonBetween `json:"notBetween,omitempty"`
	NotIn      []int64                    `json:"notIn,omitempty"`
}

type IntFieldComparisonBetween struct {
	Lower int64 `json:"lower"`
	Upper int64 `json:"upper"`
}

// An integration object
type Integration struct {
	Account *Account `json:"account"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Configuration for the integration
	Credentials Credentials  `json:"credentials"`
	Environment *Environment `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The reference ID for the integration
	IntegrationID *string `json:"integrationId"`
	// Whether the integration is the default integration
	IsDefault *bool `json:"isDefault"`
	// The vendor identifier of integration
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
	// The type of integration
	VendorType VendorType `json:"vendorType"`
}

type IntegrationAggregateGroupBy struct {
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	ID               *string           `json:"id"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
	VendorType       *VendorType       `json:"vendorType"`
}

type IntegrationConnection struct {
	// Array of edges.
	Edges []*IntegrationEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type IntegrationCountAggregate struct {
	CreatedAt        *int64 `json:"createdAt"`
	EnvironmentID    *int64 `json:"environmentId"`
	ID               *int64 `json:"id"`
	VendorIdentifier *int64 `json:"vendorIdentifier"`
	VendorType       *int64 `json:"vendorType"`
}

type IntegrationDeleteResponse struct {
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Configuration for the integration
	Credentials Credentials `json:"credentials"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// Unique identifier for the entity
	ID *string `json:"id"`
	// The reference ID for the integration
	IntegrationID *string `json:"integrationId"`
	// Whether the integration is the default integration
	IsDefault *bool `json:"isDefault"`
	// The vendor identifier of integration
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
	// The type of integration
	VendorType *VendorType `json:"vendorType"`
}

type IntegrationEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Integration
	Node Integration `json:"node"`
}

type IntegrationFilter struct {
	And              []*IntegrationFilter                   `json:"and,omitempty"`
	CreatedAt        *DateFieldComparison                   `json:"createdAt,omitempty"`
	EnvironmentID    *UUIDFilterComparison                  `json:"environmentId,omitempty"`
	ID               *UUIDFilterComparison                  `json:"id,omitempty"`
	Or               []*IntegrationFilter                   `json:"or,omitempty"`
	VendorIdentifier *VendorIdentifierFilterComparison      `json:"vendorIdentifier,omitempty"`
	VendorType       *IntegrationVendorTypeFilterComparison `json:"vendorType,omitempty"`
}

type IntegrationMaxAggregate struct {
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	ID               *string           `json:"id"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
	VendorType       *VendorType       `json:"vendorType"`
}

type IntegrationMinAggregate struct {
	CreatedAt        *string           `json:"createdAt"`
	EnvironmentID    *string           `json:"environmentId"`
	ID               *string           `json:"id"`
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier"`
	VendorType       *VendorType       `json:"vendorType"`
}

type IntegrationSort struct {
	Direction SortDirection         `json:"direction"`
	Field     IntegrationSortFields `json:"field"`
	Nulls     *SortNulls            `json:"nulls,omitempty"`
}

type IntegrationVendorTypeFilterComparison struct {
	Eq    *VendorType  `json:"eq,omitempty"`
	In    []VendorType `json:"in,omitempty"`
	Neq   *VendorType  `json:"neq,omitempty"`
	NotIn []VendorType `json:"notIn,omitempty"`
}

type InvalidArgumentError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidCancellationDate struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type InvalidEntitlementResetPeriodError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidMemberDeleteError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type InvalidSubscriptionStatus struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

// Input for inviting members
type InviteMembersInput struct {
	// Account level access of the user, defaults to member role
	AccountRole *AccountAccessRole `json:"accountRole,omitempty"`
	// List of emails to invite
	Invites []string `json:"invites"`
	// Environment level access of the user, defaults to read-only role
	NonProductionRole *EnvironmentAccessRole `json:"nonProductionRole,omitempty"`
	// Environment level access of the user, defaults to read-only role
	ProductionRole *EnvironmentAccessRole `json:"productionRole,omitempty"`
}

type InvoiceLine struct {
	Amount      float64 `json:"amount"`
	Currency    string  `json:"currency"`
	Description *string `json:"description"`
	Proration   bool    `json:"proration"`
	Quantity    *int64  `json:"quantity"`
}

// AWS Marketplace product dimensions response
type ListAwsProductDimensionsDto struct {
	// List of available dimensions for the AWS product
	Dimensions []*AwsDimension `json:"dimensions"`
}

// Input for retrieving AWS Marketplace product dimensions
type ListAwsProductDimensionsInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// AWS product ID to fetch dimensions for
	ProductID string `json:"productId"`
}

// Input parameters for listing available AWS Marketplace products
type ListAwsProductsInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Response containing available AWS Marketplace products
type ListAwsProductsResult struct {
	// Array of available AWS Marketplace product configurations
	Products []*AwsProduct `json:"products"`
}

// Input for triggering the subscription invoice as paid
type MarkInvoiceAsPaidInput struct {
	// Environment ID
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The subscription entity id to trigger mark invoice as paid
	SubscriptionID string `json:"subscriptionId"`
}

// DTO for a member
type Member struct {
	// Get the access roles assigned to the member
	AccessRoles *AccessRoles `json:"accessRoles"`
	Account     Account      `json:"account"`
	// The date and time when the member was created
	CreatedAt *string `json:"createdAt"`
	// The Cube.js token associated with the member
	CubejsToken *string `json:"cubejsToken"`
	// The customer token associated with the member
	CustomerToken *string `json:"customerToken"`
	// The email address of the member
	Email string `json:"email"`
	// Indicates if the member has hidden the getting started page
	HideGettingStartedPage *bool `json:"hideGettingStartedPage"`
	// The unique identifier of the member
	ID string `json:"id"`
	// The status of the member, e.g. "active" or "inactive"
	MemberStatus MemberStatus `json:"memberStatus"`
	// The service API key associated with the member
	ServiceAPIKey *string `json:"serviceApiKey"`
	User          *User   `json:"user"`
	// The id of the user associated with this member
	UserID string `json:"userId"`
}

type MemberAggregateGroupBy struct {
	CreatedAt *string `json:"createdAt"`
	Email     *string `json:"email"`
	ID        *string `json:"id"`
}

type MemberConnection struct {
	// Array of edges.
	Edges []*MemberEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type MemberCountAggregate struct {
	CreatedAt *int64 `json:"createdAt"`
	Email     *int64 `json:"email"`
	ID        *int64 `json:"id"`
}

type MemberEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Member
	Node Member `json:"node"`
}

type MemberFilter struct {
	And       []*MemberFilter         `json:"and,omitempty"`
	CreatedAt *DateFieldComparison    `json:"createdAt,omitempty"`
	Email     *StringFieldComparison  `json:"email,omitempty"`
	ID        *UUIDFilterComparison   `json:"id,omitempty"`
	Or        []*MemberFilter         `json:"or,omitempty"`
	User      *MemberFilterUserFilter `json:"user,omitempty"`
}

type MemberFilterUserFilter struct {
	And   []*MemberFilterUserFilter `json:"and,omitempty"`
	Email *StringFieldComparison    `json:"email,omitempty"`
	ID    *UUIDFilterComparison     `json:"id,omitempty"`
	Name  *StringFieldComparison    `json:"name,omitempty"`
	Or    []*MemberFilterUserFilter `json:"or,omitempty"`
}

type MemberInvitationError struct {
	Code   string `json:"code"`
	Reason string `json:"reason"`
}

type MemberMaxAggregate struct {
	CreatedAt *string `json:"createdAt"`
	Email     *string `json:"email"`
	ID        *string `json:"id"`
}

type MemberMinAggregate struct {
	CreatedAt *string `json:"createdAt"`
	Email     *string `json:"email"`
	ID        *string `json:"id"`
}

type MemberNotFoundError struct {
	Code string `json:"code"`
}

type MemberSort struct {
	Direction SortDirection    `json:"direction"`
	Field     MemberSortFields `json:"field"`
	Nulls     *SortNulls       `json:"nulls,omitempty"`
}

// Response DTO for inviting members
type MembersInviteResponse struct {
	// List of emails that failed to be invited
	FailedInvites []string `json:"failedInvites"`
	// List of emails that were skipped during the invite process
	SkippedInvites []string `json:"skippedInvites"`
	// List of successfully invited members
	SuccessInvites []string `json:"successInvites"`
}

// DTO representing the result of an environment merge operation
type MergeEnvironment struct {
	// Slug of the environment that was created or merged into
	EnvironmentSlug string `json:"environmentSlug"`
	// List of task IDs related to the asynchronous merge process
	TaskIds []string `json:"taskIds"`
}

// Input type for mergeEnvironment mutation
type MergeEnvironmentInput struct {
	// Name for the new environment if destinationEnvironmentSlug is not provided
	DestinationEnvironmentName *string `json:"destinationEnvironmentName,omitempty"`
	// Slug of the destination environment to merge into. If not provided, a new environment will be created
	DestinationEnvironmentSlug *string `json:"destinationEnvironmentSlug,omitempty"`
	// Type for the new environment if destinationEnvironmentSlug is not provided
	DestinationEnvironmentType *EnvironmentType `json:"destinationEnvironmentType,omitempty"`
	// Optional configuration to customize the merge process
	MergeConfiguration *EnvironmentMergeConfigurationInput `json:"mergeConfiguration,omitempty"`
	// How to migrate customers to newer plan version of updated plans. Default is not to migrate existing customers
	MigrationType *PublishMigrationType `json:"migrationType,omitempty"`
	// Slug of the source environment to merge from. Either this or sourceTemplate must be provided
	SourceEnvironmentSlug *string `json:"sourceEnvironmentSlug,omitempty"`
	// A template dump of the source environment. Either this or sourceEnvironmentSlug must be provided
	SourceTemplate map[string]interface{} `json:"sourceTemplate,omitempty"`
}

// A meter configuration that tracks and measures usage-based functionality
type Meter struct {
	// Configuration specifying how to aggregate the meter data
	Aggregation Aggregation `json:"aggregation"`
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// List of filters that will be applied to the data
	Filters []*MeterFilterDefinition `json:"filters"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
}

// Defines how meter data should be aggregated using a specified aggregation function
type MeterAggregation struct {
	// The data field to which the aggregation function will be applied
	Field *string `json:"field,omitempty"`
	// The aggregation function to apply to the data (e.g. SUM, AVG, COUNT)
	Function AggregationFunction `json:"function"`
}

// A condition that will be used to filter the data
type MeterCondition struct {
	// The field to filter on
	Field string `json:"field"`
	// The operation to perform on the field
	Operation ConditionOperation `json:"operation"`
	// The value of the field to filter on
	Value *string `json:"value"`
}

// A condition that will be used to filter the data
type MeterConditionInput struct {
	// The field to filter on
	Field string `json:"field"`
	// The operation to perform on the field
	Operation ConditionOperation `json:"operation"`
	// The value of the field to filter on
	Value *string `json:"value,omitempty"`
}

// A configuration defining how to filter the data
type MeterFilterDefinition struct {
	// List of conditions that will be applied to the data
	Conditions []*MeterCondition `json:"conditions"`
}

// A configuration defining how to filter the data
type MeterFilterDefinitionInput struct {
	// List of conditions that will be applied to the data
	Conditions []*MeterConditionInput `json:"conditions"`
}

type MeterTypeFilterComparison struct {
	Eq       *MeterType  `json:"eq,omitempty"`
	Gt       *MeterType  `json:"gt,omitempty"`
	Gte      *MeterType  `json:"gte,omitempty"`
	ILike    *MeterType  `json:"iLike,omitempty"`
	In       []MeterType `json:"in,omitempty"`
	Is       *bool       `json:"is,omitempty"`
	IsNot    *bool       `json:"isNot,omitempty"`
	Like     *MeterType  `json:"like,omitempty"`
	Lt       *MeterType  `json:"lt,omitempty"`
	Lte      *MeterType  `json:"lte,omitempty"`
	Neq      *MeterType  `json:"neq,omitempty"`
	NotILike *MeterType  `json:"notILike,omitempty"`
	NotIn    []MeterType `json:"notIn,omitempty"`
	NotLike  *MeterType  `json:"notLike,omitempty"`
}

type MeteringNotAvailableForFeatureTypeError struct {
	Code              string `json:"code"`
	FeatureType       string `json:"featureType"`
	IsValidationError bool   `json:"isValidationError"`
}

// Minimum spend configuration
type MinimumSpend struct {
	// Minimum spend billing period
	BillingPeriod BillingPeriod `json:"billingPeriod"`
	// The minimum spend limit
	Minimum Money `json:"minimum"`
}

// Minimum spend change
type MinimumSpendChange struct {
	// The value after the change
	After *MinimumSpend `json:"after"`
	// The value before the change
	Before *MinimumSpend `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Minimum spend input
type MinimumSpendInput struct {
	// The billing period of the price
	BillingPeriod BillingPeriod `json:"billingPeriod"`
	// The minimum spend value
	Minimum MoneyInputDto `json:"minimum"`
}

// Mock DTO for the paywall
type MockPaywall struct {
	// Mock paywall configuration
	Configuration *PaywallConfiguration `json:"configuration"`
	// List of mock plans available in the paywall
	Plans []*PaywallPlan `json:"plans"`
}

type Money struct {
	// The price amount
	Amount float64 `json:"amount"`
	// The price currency
	Currency Currency `json:"currency"`
}

// Money Input
type MoneyInputDto struct {
	// The price amount
	Amount float64 `json:"amount"`
	// The price currency
	Currency *Currency `json:"currency,omitempty"`
}

// Monthly reset period config
type MonthlyResetPeriodConfig struct {
	// Monthly according to configuration
	MonthlyAccordingTo *MonthlyAccordingTo `json:"monthlyAccordingTo"`
}

func (MonthlyResetPeriodConfig) IsResetPeriodConfiguration() {}

// Monthly reset period config input
type MonthlyResetPeriodConfigInput struct {
	// Monthly according to configuration
	AccordingTo MonthlyAccordingTo `json:"accordingTo"`
}

// Number change
type NumberChange struct {
	// The value after the change
	After *float64 `json:"after"`
	// The value before the change
	Before *float64 `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

type NumberFieldComparison struct {
	Between    *NumberFieldComparisonBetween `json:"between,omitempty"`
	Eq         *float64                      `json:"eq,omitempty"`
	Gt         *float64                      `json:"gt,omitempty"`
	Gte        *float64                      `json:"gte,omitempty"`
	In         []float64                     `json:"in,omitempty"`
	Is         *bool                         `json:"is,omitempty"`
	IsNot      *bool                         `json:"isNot,omitempty"`
	Lt         *float64                      `json:"lt,omitempty"`
	Lte        *float64                      `json:"lte,omitempty"`
	Neq        *float64                      `json:"neq,omitempty"`
	NotBetween *NumberFieldComparisonBetween `json:"notBetween,omitempty"`
	NotIn      []float64                     `json:"notIn,omitempty"`
}

type NumberFieldComparisonBetween struct {
	Lower float64 `json:"lower"`
	Upper float64 `json:"upper"`
}

// OpenFGA integration configuration object
type OpenFGACredentials struct {
	// Audience for the OpenFGA API
	APIAudience string `json:"apiAudience"`
	// Issuer of the OpenFGA API token
	APITokenIssuer string `json:"apiTokenIssuer"`
	// URL of the OpenFGA API
	APIURL string `json:"apiUrl"`
	// Client ID for the OpenFGA API
	ClientID string `json:"clientId"`
	// ID of the OpenFGA model
	ModelID string `json:"modelId"`
	// ID of the OpenFGA store
	StoreID string `json:"storeId"`
}

func (OpenFGACredentials) IsCredentials() {}

// Input configuration for OpenFGA integration
type OpenFGACredentialsInput struct {
	// Audience for the OpenFGA API
	APIAudience string `json:"apiAudience"`
	// Issuer of the OpenFGA API token
	APITokenIssuer string `json:"apiTokenIssuer"`
	// URL of the OpenFGA API
	APIURL string `json:"apiUrl"`
	// Client ID for the OpenFGA API
	ClientID string `json:"clientId"`
	// Client secret for OpenFGA
	ClientSecret string `json:"clientSecret"`
	// ID of the OpenFGA store
	StoreID *string `json:"storeId,omitempty"`
}

// Overage billing period change
type OverageBillingPeriodChange struct {
	// The value after the change
	After *OverageBillingPeriod `json:"after"`
	// The value before the change
	Before *OverageBillingPeriod `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Overage Entitlement Create Input
type OverageEntitlementCreateInput struct {
	// The behavior of the entitlement
	Behavior *EntitlementBehavior `json:"behavior,omitempty"`
	// The description of the entitlement
	Description *string `json:"description,omitempty"`
	// The display name override of the entitlement
	DisplayNameOverride *string `json:"displayNameOverride,omitempty"`
	// The enum values of the entitlement
	EnumValues []string `json:"enumValues,omitempty"`
	// Primary feature group ID (first in the array) associated with this entitlement
	FeatureGroupID *string `json:"featureGroupId,omitempty"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Whether the entitlement is hidden from widgets
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets,omitempty"`
	// Whether the entitlement is a custom entitlement
	IsCustom *bool `json:"isCustom,omitempty"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The order of the entitlement in the entitlement list
	Order *float64 `json:"order,omitempty"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the entitlement, defined when reset period is yearly
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

// Overage Pricing Model Create Input
type OveragePricingModelCreateInput struct {
	// The billing cadence of the base pricing model
	BillingCadence *BillingCadence `json:"billingCadence,omitempty"`
	// The billing model of the base pricing model
	BillingModel BillingModel `json:"billingModel"`
	// The entitlement of the overage pricing model
	Entitlement *OverageEntitlementCreateInput `json:"entitlement,omitempty"`
	// The feature id of the base pricing model
	FeatureID *string `json:"featureId,omitempty"`
	// The price periods of the base pricing model
	PricePeriods []*PricePeriodInput `json:"pricePeriods"`
}

type PackageAlreadyPublishedError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

// Package Changes
type PackageChanges struct {
	// The additional meta data of the package
	AdditionalMetaData *AdditionalMetaDataChange    `json:"additionalMetaData"`
	BasePlan           *BasePlanChange              `json:"basePlan"`
	CompatibleAddons   []*PlanCompatibleAddonChange `json:"compatibleAddons"`
	// Package groups
	CompatiblePackageGroups []*PlanCompatiblePackageGroupChange `json:"compatiblePackageGroups"`
	DefaultTrialConfig      *DefaultTrialConfigChange           `json:"defaultTrialConfig"`
	// Addon dependencies
	Dependencies []*AddonDependencyChange `json:"dependencies"`
	// The description of the package
	Description *StringChangeDto `json:"description"`
	// The display name of the package
	DisplayName *StringChangeDto `json:"displayName"`
	// List of entitlements of the package
	Entitlements []*PackageEntitlementChange `json:"entitlements"`
	// List of hidden widgets of the package
	HiddenFromWidgets *HiddenFromWidgetsChange `json:"hiddenFromWidgets"`
	// Max quantity for an addon
	MaxQuantity *NumberChange `json:"maxQuantity"`
	// Minimum spend limit
	MinimumSpend []*MinimumSpendChange `json:"minimumSpend"`
	// Configures when the overage charge is billed.
	OverageBillingPeriod *OverageBillingPeriodChange `json:"overageBillingPeriod"`
	// List of overage prices of the package
	OveragePrices []*PackagePriceChange `json:"overagePrices"`
	// List of prices of the package
	Prices []*PackagePriceChange `json:"prices"`
	// The pricing type of the package
	PricingType  *PricingTypeChange `json:"pricingType"`
	TotalChanges int64              `json:"totalChanges"`
}

// Package
type PackageDto struct {
	// The additional meta data of the package
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The billing link url of the package
	BillingLinkURL *string `json:"billingLinkUrl"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The description of the package
	Description *string `json:"description"`
	// The display name of the package
	DisplayName string `json:"displayName"`
	// The draft details of the package
	DraftDetails *PackageDraftDetails `json:"draftDetails"`
	// The draft summary of the package
	DraftSummary *PackageDraftSummary `json:"draftSummary"`
	// List of entitlements of the package
	Entitlements []*PackageEntitlement `json:"entitlements"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// List of hidden widgets of the package
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Indicates if the package is the latest version
	IsLatest *bool `json:"isLatest"`
	// The overage billing period of the package
	OverageBillingPeriod *OverageBillingPeriod `json:"overageBillingPeriod"`
	// List of overage prices of the package
	OveragePrices []*Price `json:"overagePrices"`
	// List of prices of the package
	Prices []*Price `json:"prices"`
	// The pricing type of the package
	PricingType *PricingType `json:"pricingType"`
	// The product id of the package
	ProductID *string `json:"productId"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// The status of the package
	Status PackageStatus `json:"status"`
	// List of sync states of the package
	SyncStates []*SyncState `json:"syncStates"`
	// The type of the package
	Type string `json:"type"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The version number of the package
	VersionNumber int64 `json:"versionNumber"`
}

type PackageDTOFilter struct {
	And           []*PackageDTOFilter            `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison          `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison          `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*PackageDTOFilter            `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PackageDTOSort struct {
	Direction SortDirection        `json:"direction"`
	Field     PackageDTOSortFields `json:"field"`
	Nulls     *SortNulls           `json:"nulls,omitempty"`
}

// Package Draft Details
type PackageDraftDetails struct {
	// List of affected child plans
	AffectedChildPlans []*Plan `json:"affectedChildPlans"`
	// The package changes
	Changes *PackageChanges `json:"changes"`
	// List of child plans with draft
	ChildPlansWithDraft []*Plan `json:"childPlansWithDraft"`
	// The number of customers affected by the package
	CustomersAffected *int64 `json:"customersAffected"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
	// The user who last updated the record
	UpdatedBy *string `json:"updatedBy"`
	// The version number of the package
	Version int64 `json:"version"`
}

// Package Draft Summary
type PackageDraftSummary struct {
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
	// The user who last updated the record
	UpdatedBy *string `json:"updatedBy"`
	// The version number of the package
	Version int64 `json:"version"`
}

// Package entitlement
type PackageEntitlement struct {
	// The behavior of the entitlement
	Behavior EntitlementBehavior `json:"behavior"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The description of the entitlement
	Description *string `json:"description"`
	// The display name override of the entitlement
	DisplayNameOverride *string `json:"displayNameOverride"`
	// The enum values of the entitlement
	EnumValues []string `json:"enumValues"`
	// The unique identifier for the environment
	EnvironmentID string  `json:"environmentId"`
	Feature       Feature `json:"feature"`
	// Primary feature group (first in the array) associated with this entitlement
	FeatureGroup *FeatureGroup `json:"featureGroup"`
	// Primary feature group ID (first in the array) associated with this entitlement
	FeatureGroupID *string `json:"featureGroupId"`
	// Feature group IDs associated with this entitlement
	FeatureGroupIds []string `json:"featureGroupIds"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage"`
	// Whether the entitlement is hidden from widgets
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	ID                string       `json:"id"`
	// Whether the entitlement is a custom entitlement
	IsCustom *bool  `json:"isCustom"`
	Meter    *Meter `json:"meter"`
	// The order of the entitlement in the entitlement list
	Order   *float64    `json:"order"`
	Package *PackageDto `json:"package"`
	// The unique identifier of the entitlement package
	PackageID string `json:"packageId"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// The reset period configuration of the entitlement
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit"`
}

type PackageEntitlementAggregateGroupBy struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	UpdatedAt     *string `json:"updatedAt"`
}

// Package entitlement change
type PackageEntitlementChange struct {
	// The value after the change
	After *PackageEntitlement `json:"after"`
	// The value before the change
	Before *PackageEntitlement `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

type PackageEntitlementConnection struct {
	// Array of edges.
	Edges []*PackageEntitlementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PackageEntitlementCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	PackageID     *int64 `json:"packageId"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type PackageEntitlementDeleteResponse struct {
	// The behavior of the entitlement
	Behavior *EntitlementBehavior `json:"behavior"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The description of the entitlement
	Description *string `json:"description"`
	// The display name override of the entitlement
	DisplayNameOverride *string `json:"displayNameOverride"`
	// The enum values of the entitlement
	EnumValues []string `json:"enumValues"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// Primary feature group (first in the array) associated with this entitlement
	FeatureGroup *FeatureGroup `json:"featureGroup"`
	// Primary feature group ID (first in the array) associated with this entitlement
	FeatureGroupID *string `json:"featureGroupId"`
	// Feature group IDs associated with this entitlement
	FeatureGroupIds []string `json:"featureGroupIds"`
	// The unique identifier of the entitlement feature
	FeatureID *string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage"`
	// Whether the entitlement is hidden from widgets
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	ID                *string      `json:"id"`
	// Whether the entitlement is a custom entitlement
	IsCustom *bool `json:"isCustom"`
	// The order of the entitlement in the entitlement list
	Order *float64 `json:"order"`
	// The unique identifier of the entitlement package
	PackageID *string `json:"packageId"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// The reset period configuration of the entitlement
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit"`
}

type PackageEntitlementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the PackageEntitlement
	Node PackageEntitlement `json:"node"`
}

type PackageEntitlementFilter struct {
	And           []*PackageEntitlementFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                      `json:"createdAt,omitempty"`
	EnvironmentID *UUIDFilterComparison                     `json:"environmentId,omitempty"`
	Feature       *PackageEntitlementFilterFeatureFilter    `json:"feature,omitempty"`
	ID            *UUIDFilterComparison                     `json:"id,omitempty"`
	Or            []*PackageEntitlementFilter               `json:"or,omitempty"`
	Package       *PackageEntitlementFilterPackageDTOFilter `json:"package,omitempty"`
	PackageID     *StringFieldComparison                    `json:"packageId,omitempty"`
	UpdatedAt     *DateFieldComparison                      `json:"updatedAt,omitempty"`
}

type PackageEntitlementFilterFeatureFilter struct {
	And           []*PackageEntitlementFilterFeatureFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                     `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                   `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                   `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison                    `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison           `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison             `json:"featureType,omitempty"`
	ID            *UUIDFilterComparison                    `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison               `json:"meterType,omitempty"`
	Or            []*PackageEntitlementFilterFeatureFilter `json:"or,omitempty"`
	RefID         *StringFieldComparison                   `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison                     `json:"updatedAt,omitempty"`
}

type PackageEntitlementFilterPackageDTOFilter struct {
	And           []*PackageEntitlementFilterPackageDTOFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison                      `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison                        `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                      `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                      `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison                       `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison                       `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison                     `json:"isLatest,omitempty"`
	Or            []*PackageEntitlementFilterPackageDTOFilter `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison                `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison                      `json:"productId,omitempty"`
	RefID         *StringFieldComparison                      `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison              `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                        `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison                         `json:"versionNumber,omitempty"`
}

// Package entitlement input
type PackageEntitlementInput struct {
	// The behavior of the entitlement
	Behavior *EntitlementBehavior `json:"behavior,omitempty"`
	// The description of the entitlement
	Description *string `json:"description,omitempty"`
	// The display name override of the entitlement
	DisplayNameOverride *string `json:"displayNameOverride,omitempty"`
	// The enum values of the entitlement
	EnumValues []string `json:"enumValues,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Primary feature group ID (first in the array) associated with this entitlement
	FeatureGroupID *string `json:"featureGroupId,omitempty"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Whether the entitlement is hidden from widgets
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets,omitempty"`
	// Whether the entitlement is a custom entitlement
	IsCustom *bool `json:"isCustom,omitempty"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The order of the entitlement in the entitlement list
	Order *float64 `json:"order,omitempty"`
	// The unique identifier of the entitlement package
	PackageID string `json:"packageId"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the entitlement, defined when reset period is yearly
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type PackageEntitlementMaxAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	UpdatedAt     *string `json:"updatedAt"`
}

type PackageEntitlementMinAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
	PackageID     *string `json:"packageId"`
	UpdatedAt     *string `json:"updatedAt"`
}

type PackageEntitlementSort struct {
	Direction SortDirection                `json:"direction"`
	Field     PackageEntitlementSortFields `json:"field"`
	Nulls     *SortNulls                   `json:"nulls,omitempty"`
}

// Package entitlement update input
type PackageEntitlementUpdateInput struct {
	// The behavior of the entitlement
	Behavior *EntitlementBehavior `json:"behavior,omitempty"`
	// The description of the entitlement
	Description *string `json:"description,omitempty"`
	// The display name override of the entitlement
	DisplayNameOverride *string `json:"displayNameOverride,omitempty"`
	// The enum values of the entitlement
	EnumValues []string `json:"enumValues,omitempty"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Whether the entitlement is hidden from widgets
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets,omitempty"`
	// Whether the entitlement is a custom entitlement
	IsCustom *bool `json:"isCustom,omitempty"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The order of the entitlement in the entitlement list
	Order *float64 `json:"order,omitempty"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the entitlement, defined when reset period is yearly
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

// A set of addons bundled together
type PackageGroup struct {
	Addons []*Addon `json:"addons"`
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// The description of the package group
	Description *string `json:"description"`
	// The display name of the package group
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Indicates if this is the latest version of the package group
	IsLatest bool `json:"isLatest"`
	// The id of the package group
	PackageGroupID string  `json:"packageGroupId"`
	Product        Product `json:"product"`
	// The id of the related product
	ProductID *string `json:"productId"`
	// The status of the package group (draft, published, archived)
	Status PackageGroupStatus `json:"status"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
	// The version number of the package group
	VersionNumber int64 `json:"versionNumber"`
}

type PackageGroupAggregateGroupBy struct {
	CreatedAt      *string             `json:"createdAt"`
	DisplayName    *string             `json:"displayName"`
	EnvironmentID  *string             `json:"environmentId"`
	IsLatest       *bool               `json:"isLatest"`
	PackageGroupID *string             `json:"packageGroupId"`
	ProductID      *string             `json:"productId"`
	Status         *PackageGroupStatus `json:"status"`
	UpdatedAt      *string             `json:"updatedAt"`
	VersionNumber  *int64              `json:"versionNumber"`
}

type PackageGroupAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type PackageGroupConnection struct {
	// Array of edges.
	Edges []*PackageGroupEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PackageGroupCountAggregate struct {
	CreatedAt      *int64 `json:"createdAt"`
	DisplayName    *int64 `json:"displayName"`
	EnvironmentID  *int64 `json:"environmentId"`
	IsLatest       *int64 `json:"isLatest"`
	PackageGroupID *int64 `json:"packageGroupId"`
	ProductID      *int64 `json:"productId"`
	Status         *int64 `json:"status"`
	UpdatedAt      *int64 `json:"updatedAt"`
	VersionNumber  *int64 `json:"versionNumber"`
}

type PackageGroupEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the PackageGroup
	Node PackageGroup `json:"node"`
}

type PackageGroupFilter struct {
	And            []*PackageGroupFilter               `json:"and,omitempty"`
	CreatedAt      *DateFieldComparison                `json:"createdAt,omitempty"`
	DisplayName    *StringFieldComparison              `json:"displayName,omitempty"`
	EnvironmentID  *UUIDFilterComparison               `json:"environmentId,omitempty"`
	IsLatest       *BooleanFieldComparison             `json:"isLatest,omitempty"`
	Or             []*PackageGroupFilter               `json:"or,omitempty"`
	PackageGroupID *StringFieldComparison              `json:"packageGroupId,omitempty"`
	Product        *PackageGroupFilterProductFilter    `json:"product,omitempty"`
	ProductID      *StringFieldComparison              `json:"productId,omitempty"`
	Status         *PackageGroupStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt      *DateFieldComparison                `json:"updatedAt,omitempty"`
	VersionNumber  *IntFieldComparison                 `json:"versionNumber,omitempty"`
}

type PackageGroupFilterProductFilter struct {
	And                       []*PackageGroupFilterProductFilter `json:"and,omitempty"`
	AwsMarketplaceProductCode *StringFieldComparison             `json:"awsMarketplaceProductCode,omitempty"`
	AwsMarketplaceProductID   *StringFieldComparison             `json:"awsMarketplaceProductId,omitempty"`
	CreatedAt                 *DateFieldComparison               `json:"createdAt,omitempty"`
	Description               *StringFieldComparison             `json:"description,omitempty"`
	DisplayName               *StringFieldComparison             `json:"displayName,omitempty"`
	EnvironmentID             *UUIDFilterComparison              `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison              `json:"id,omitempty"`
	IsDefaultProduct          *BooleanFieldComparison            `json:"isDefaultProduct,omitempty"`
	MultipleSubscriptions     *BooleanFieldComparison            `json:"multipleSubscriptions,omitempty"`
	Or                        []*PackageGroupFilterProductFilter `json:"or,omitempty"`
	RefID                     *StringFieldComparison             `json:"refId,omitempty"`
	UpdatedAt                 *DateFieldComparison               `json:"updatedAt,omitempty"`
}

type PackageGroupMaxAggregate struct {
	CreatedAt      *string             `json:"createdAt"`
	DisplayName    *string             `json:"displayName"`
	EnvironmentID  *string             `json:"environmentId"`
	PackageGroupID *string             `json:"packageGroupId"`
	ProductID      *string             `json:"productId"`
	Status         *PackageGroupStatus `json:"status"`
	UpdatedAt      *string             `json:"updatedAt"`
	VersionNumber  *int64              `json:"versionNumber"`
}

type PackageGroupMinAggregate struct {
	CreatedAt      *string             `json:"createdAt"`
	DisplayName    *string             `json:"displayName"`
	EnvironmentID  *string             `json:"environmentId"`
	PackageGroupID *string             `json:"packageGroupId"`
	ProductID      *string             `json:"productId"`
	Status         *PackageGroupStatus `json:"status"`
	UpdatedAt      *string             `json:"updatedAt"`
	VersionNumber  *int64              `json:"versionNumber"`
}

type PackageGroupSort struct {
	Direction SortDirection          `json:"direction"`
	Field     PackageGroupSortFields `json:"field"`
	Nulls     *SortNulls             `json:"nulls,omitempty"`
}

type PackageGroupStatusFilterComparison struct {
	Eq       *PackageGroupStatus  `json:"eq,omitempty"`
	Gt       *PackageGroupStatus  `json:"gt,omitempty"`
	Gte      *PackageGroupStatus  `json:"gte,omitempty"`
	ILike    *PackageGroupStatus  `json:"iLike,omitempty"`
	In       []PackageGroupStatus `json:"in,omitempty"`
	Is       *bool                `json:"is,omitempty"`
	IsNot    *bool                `json:"isNot,omitempty"`
	Like     *PackageGroupStatus  `json:"like,omitempty"`
	Lt       *PackageGroupStatus  `json:"lt,omitempty"`
	Lte      *PackageGroupStatus  `json:"lte,omitempty"`
	Neq      *PackageGroupStatus  `json:"neq,omitempty"`
	NotILike *PackageGroupStatus  `json:"notILike,omitempty"`
	NotIn    []PackageGroupStatus `json:"notIn,omitempty"`
	NotLike  *PackageGroupStatus  `json:"notLike,omitempty"`
}

type PackageGroupSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

// Package Price
type PackagePrice struct {
	// The package id of the price
	PackageID string `json:"packageId"`
	// The pricing type of the package price
	PricingType PricingType `json:"pricingType"`
}

// Package price change
type PackagePriceChange struct {
	// The value after the change
	After *Price `json:"after"`
	// The value before the change
	Before *Price `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Package Pricing Input
type PackagePricingInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The minimum spend configuration per each billing period
	MinimumSpend []*MinimumSpendInput `json:"minimumSpend,omitempty"`
	// The overage billing period of the package pricing
	OverageBillingPeriod *OverageBillingPeriod `json:"overageBillingPeriod,omitempty"`
	// The list of overage pricing models of the package pricing
	OveragePricingModels []*OveragePricingModelCreateInput `json:"overagePricingModels,omitempty"`
	// The package id of the price
	PackageID string `json:"packageId"`
	// The pricing model of the package pricing
	PricingModel *PricingModelCreateInput `json:"pricingModel,omitempty"`
	// The list of pricing models of the package pricing
	PricingModels []*PricingModelCreateInput `json:"pricingModels,omitempty"`
	// The pricing type of the package pricing
	PricingType PricingType `json:"pricingType"`
}

type PackagePricingTypeNotSetError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

// Package Publish Input
type PackagePublishInput struct {
	// Unique identifier for the entity
	ID string `json:"id"`
	// The migration type of the package
	MigrationType PublishMigrationType `json:"migrationType"`
}

// Package Published
type PackagePublished struct {
	// The unique identifier for the account
	AccountID string `json:"accountId"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The migration type of the package
	MigrationType PublishMigrationType `json:"migrationType"`
	// The ref id of the package
	PackageRefID string `json:"packageRefId"`
	// The type of the package
	PackageType string `json:"packageType"`
	// The version number of the package
	PackageVersion int64 `json:"packageVersion"`
}

type PackageStatusFilterComparison struct {
	Eq       *PackageStatus  `json:"eq,omitempty"`
	Gt       *PackageStatus  `json:"gt,omitempty"`
	Gte      *PackageStatus  `json:"gte,omitempty"`
	ILike    *PackageStatus  `json:"iLike,omitempty"`
	In       []PackageStatus `json:"in,omitempty"`
	Is       *bool           `json:"is,omitempty"`
	IsNot    *bool           `json:"isNot,omitempty"`
	Like     *PackageStatus  `json:"like,omitempty"`
	Lt       *PackageStatus  `json:"lt,omitempty"`
	Lte      *PackageStatus  `json:"lte,omitempty"`
	Neq      *PackageStatus  `json:"neq,omitempty"`
	NotILike *PackageStatus  `json:"notILike,omitempty"`
	NotIn    []PackageStatus `json:"notIn,omitempty"`
	NotLike  *PackageStatus  `json:"notLike,omitempty"`
}

type PageInfo struct {
	// The cursor of the last returned record.
	EndCursor *string `json:"endCursor"`
	// true if paging forward and there are more records.
	HasNextPage *bool `json:"hasNextPage"`
	// true if paging backwards and there are more records.
	HasPreviousPage *bool `json:"hasPreviousPage"`
	// The cursor of the first returned record.
	StartCursor *string `json:"startCursor"`
}

type PaymentCollectionFilterComparison struct {
	Eq       *PaymentCollection  `json:"eq,omitempty"`
	Gt       *PaymentCollection  `json:"gt,omitempty"`
	Gte      *PaymentCollection  `json:"gte,omitempty"`
	ILike    *PaymentCollection  `json:"iLike,omitempty"`
	In       []PaymentCollection `json:"in,omitempty"`
	Is       *bool               `json:"is,omitempty"`
	IsNot    *bool               `json:"isNot,omitempty"`
	Like     *PaymentCollection  `json:"like,omitempty"`
	Lt       *PaymentCollection  `json:"lt,omitempty"`
	Lte      *PaymentCollection  `json:"lte,omitempty"`
	Neq      *PaymentCollection  `json:"neq,omitempty"`
	NotILike *PaymentCollection  `json:"notILike,omitempty"`
	NotIn    []PaymentCollection `json:"notIn,omitempty"`
	NotLike  *PaymentCollection  `json:"notLike,omitempty"`
}

// DTO for the paywall
type Paywall struct {
	// List of active subscriptions for the customer
	ActiveSubscriptions []*CustomerSubscription `json:"activeSubscriptions"`
	// Paywall configuration
	Configuration *PaywallConfiguration `json:"configuration"`
	// The currency used in the paywall, e.g. USD
	Currency PaywallCurrency `json:"currency"`
	// The customer for whom the paywall is being fetched
	Customer *Customer `json:"customer"`
	// Calculated price points for the paywall
	PaywallCalculatedPricePoints []*PaywallPricePoint `json:"paywallCalculatedPricePoints"`
	// List of plans available in the paywall
	Plans []*Plan `json:"plans"`
	// The resource for which the paywall is being fetched
	Resource *CustomerResource `json:"resource"`
}

// DTO for an addon
type PaywallAddon struct {
	// Additional metadata for the addon, e.g. features or tags
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// List of addons this addon is dependant on
	Dependencies []*PaywallAddon `json:"dependencies"`
	// The description of the addon
	Description *string `json:"description"`
	// The display name of the addon
	DisplayName string `json:"displayName"`
	// List of entitlements for the addon
	Entitlements []*Entitlement `json:"entitlements"`
	// List of hidden widgets of the package
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	// The maximum quantity of this addon that can be added to a subscription
	MaxQuantity *float64 `json:"maxQuantity"`
	// List of prices for the addon
	Prices []*PaywallPrice `json:"prices"`
	// The pricing type of the addon, e.g. "recurring" or "one-time"
	PricingType *PricingType `json:"pricingType"`
	// The unique reference ID of the addon
	RefID string `json:"refId"`
}

// DTO for a base plan
type PaywallBasePlan struct {
	// The display name of the base plan
	DisplayName string `json:"displayName"`
	// The unique reference ID of the base plan
	RefID string `json:"refId"`
}

// Color palette for customizing the paywall.
type PaywallColorsPalette struct {
	// Background color for the paywall area.
	BackgroundColor *string `json:"backgroundColor"`
	// Color used for UI dividers or borders.
	BorderColor *string `json:"borderColor"`
	// Background color for highlighting the customers current plan.
	CurrentPlanBackground *string `json:"currentPlanBackground"`
	// Primary highlight color used across the paywall.
	Primary *string `json:"primary"`
	// Default text color within the paywall.
	TextColor *string `json:"textColor"`
}

// Input for customizing paywall-specific color elements.
type PaywallColorsPaletteInput struct {
	// Background color of the widget.
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// Color applied to widget borders or separators.
	BorderColor *string `json:"borderColor,omitempty"`
	// Background color for the customer’s current plan section in the paywall.
	CurrentPlanBackground *string `json:"currentPlanBackground,omitempty"`
	// Primary accent color used throughout the widget.
	Primary *string `json:"primary,omitempty"`
	// Default color used for text content.
	TextColor *string `json:"textColor,omitempty"`
}

// Styling and layout configuration for the paywall widget.
type PaywallConfiguration struct {
	// Custom CSS styles to override default paywall appearance.
	CustomCSS *string `json:"customCss"`
	// Layout parameters for displaying plans in the paywall.
	Layout *PaywallLayoutConfiguration `json:"layout"`
	// Color settings applied to the paywall UI.
	Palette *PaywallColorsPalette `json:"palette"`
	// Typography settings for the paywall interface.
	Typography *TypographyConfiguration `json:"typography"`
}

// Input for updating the paywall configuration.
type PaywallConfigurationInput struct {
	// Custom CSS overrides for additional visual customization.
	CustomCSS *string `json:"customCss,omitempty"`
	// Layout settings for plan display in the paywall.
	Layout *PaywallLayoutConfigurationInput `json:"layout,omitempty"`
	// Color palette settings for the paywall UI.
	Palette *PaywallColorsPaletteInput `json:"palette,omitempty"`
	// Typography configuration used in the paywall widget.
	Typography *TypographyConfigurationInput `json:"typography,omitempty"`
}

// DTO for a currency
type PaywallCurrency struct {
	// The currency code, e.g. USD
	Code Currency `json:"code"`
	// The currency symbol, e.g. $
	Symbol string `json:"symbol"`
}

// Layout configuration for arranging plans in the paywall UI.
type PaywallLayoutConfiguration struct {
	// Horizontal alignment of the plan cards, such as left, center, right.
	Alignment *Alignment `json:"alignment"`
	// Outer spacing around each plan card.
	PlanMargin *float64 `json:"planMargin"`
	// Inner spacing inside each plan card.
	PlanPadding *float64 `json:"planPadding"`
	// Width setting for each individual plan card.
	PlanWidth *float64 `json:"planWidth"`
}

// Input for controlling the layout of pricing plans in the paywall.
type PaywallLayoutConfigurationInput struct {
	// Horizontal alignment of pricing plans, such as left, center, or right.
	Alignment *Alignment `json:"alignment,omitempty"`
	// Outer spacing around each plan.
	PlanMargin *float64 `json:"planMargin,omitempty"`
	// Inner spacing inside each plan card.
	PlanPadding *float64 `json:"planPadding,omitempty"`
	// Width of each plan card displayed in the paywall.
	PlanWidth *float64 `json:"planWidth,omitempty"`
}

// DTO for a plan
type PaywallPlan struct {
	// Additional metadata for the plan, e.g. features or tags
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// The base plan for the plan, if applicable
	BasePlan *PaywallBasePlan `json:"basePlan"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// List of compatible addons for the plan
	CompatibleAddons []*PaywallAddon `json:"compatibleAddons"`
	// Plan's compatible package groups
	CompatiblePackageGroups []*PaywallPlanCompatiblePackageGroup `json:"compatiblePackageGroups"`
	// Default trial configuration for the plan
	DefaultTrialConfig *DefaultTrialConfig `json:"defaultTrialConfig"`
	// The description of the plan
	Description *string `json:"description"`
	// The display name of the plan
	DisplayName string `json:"displayName"`
	// List of entitlements for the plan
	Entitlements []*Entitlement `json:"entitlements"`
	// List of inherited entitlements for the plan
	InheritedEntitlements []*Entitlement `json:"inheritedEntitlements"`
	// Minimum spend configuration
	MinimumSpend []*MinimumSpend `json:"minimumSpend"`
	// List of prices for the plan
	Prices []*PaywallPrice `json:"prices"`
	// The pricing type of the plan, e.g. "recurring" or "one-time"
	PricingType *PricingType `json:"pricingType"`
	// The product to which the plan belongs
	Product PaywallProduct `json:"product"`
	// The unique reference ID of the plan
	RefID string `json:"refId"`
}

// DTO for a plan compatible package group
type PaywallPlanCompatiblePackageGroup struct {
	// Included addons in the package group
	Addons []*PaywallAddon `json:"addons"`
	// The description of the package group
	Description *string `json:"description"`
	// The display name of the package group
	DisplayName string `json:"displayName"`
	// Plan compatible package group options
	Options PaywallPlanCompatiblePackageGroupOptions `json:"options"`
	// The id of the package group
	PackageGroupID string `json:"packageGroupId"`
}

// Plan compatible package group options
type PaywallPlanCompatiblePackageGroupOptions struct {
	// Number of free items from package group
	FreeItems *float64 `json:"freeItems"`
	// Number of required items from packageGroup
	MinItems *float64 `json:"minItems"`
}

// DTO for a price
type PaywallPrice struct {
	// The country code for billing, e.g. "US"
	BillingCountryCode *string `json:"billingCountryCode"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The billing model for the price, e.g. "recurring" or "one-time"
	BillingModel BillingModel `json:"billingModel"`
	// The billing period for the price, e.g. "monthly" or "yearly"
	BillingPeriod BillingPeriod `json:"billingPeriod"`
	// The number of units per block. Defaults to 1 unit
	BlockSize *float64 `json:"blockSize"`
	// The feature associated with this price, if applicable
	Feature *EntitlementFeature `json:"feature"`
	// The ID of the feature associated with this price, if applicable
	FeatureID *string `json:"featureId"`
	// The maximum unit quantity for this price, if applicable
	MaxUnitQuantity *float64 `json:"maxUnitQuantity"`
	// The minimum unit quantity for this price, if applicable
	MinUnitQuantity *float64 `json:"minUnitQuantity"`
	// The price amount in the smallest currency unit (e.g. cents)
	Price *Money `json:"price"`
	// List of tiers for the price, if applicable
	Tiers []*PriceTier `json:"tiers"`
	// The tiers mode for the price, e.g. "graduated" or "volume"
	TiersMode *TiersMode `json:"tiersMode"`
}

// DTO for a price point
type PaywallPricePoint struct {
	// Indicates if additional charges may apply for this price point
	AdditionalChargesMayApply *bool `json:"additionalChargesMayApply"`
	// The amount for the price point, in the smallest currency unit (e.g. cents)
	Amount float64 `json:"amount"`
	// The country code for billing, e.g. "US"
	BillingCountryCode *string `json:"billingCountryCode"`
	// The billing period for the price point, e.g. "monthly" or "yearly"
	BillingPeriod BillingPeriod `json:"billingPeriod"`
	// The currency of the price point, e.g. "USD"
	Currency Currency `json:"currency"`
	// The feature associated with this price point, if applicable
	Feature *Feature `json:"feature"`
	// The ID of the plan this price point belongs to
	PlanID string `json:"planId"`
}

// DTO for a product
type PaywallProduct struct {
	// Additional metadata for the product, e.g. features or tags
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// The description of the product
	Description *string `json:"description"`
	// The display name of the product
	DisplayName *string `json:"displayName"`
	RefID       string  `json:"refId"`
}

// Plan Data Transfer Object
type Plan struct {
	// The additional meta data of the package
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// The AWS Marketplace plan dimension, if applicable
	AwsMarketplacePlanDimension *string `json:"awsMarketplacePlanDimension"`
	BasePlan                    *Plan   `json:"basePlan"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The billing link url of the package
	BillingLinkURL   *string  `json:"billingLinkUrl"`
	CompatibleAddons []*Addon `json:"compatibleAddons"`
	// List of compatible package groups for the plan
	CompatiblePackageGroups []*PlanCompatiblePackageGroups `json:"compatiblePackageGroups"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Default trial configuration for the plan
	DefaultTrialConfig *DefaultTrialConfig `json:"defaultTrialConfig"`
	// The description of the package
	Description *string `json:"description"`
	// The display name of the package
	DisplayName string `json:"displayName"`
	// Detailed information about the plan draft
	DraftDetails *PackageDraftDetails `json:"draftDetails"`
	// Summary of the plan draft
	DraftSummary *PackageDraftSummary `json:"draftSummary"`
	// List of entitlements for the plan
	Entitlements []*PackageEntitlement `json:"entitlements"`
	Environment  Environment           `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// List of hidden widgets of the package
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// List of inherited entitlements for the plan
	InheritedEntitlements []*PackageEntitlement `json:"inheritedEntitlements"`
	// Indicates if the package is the latest version
	IsLatest *bool `json:"isLatest"`
	// Indicates if the plan is a parent plan
	IsParent bool `json:"isParent"`
	// Minimum spend configuration
	MinimumSpend []*MinimumSpend `json:"minimumSpend"`
	// The overage billing period of the package
	OverageBillingPeriod *OverageBillingPeriod `json:"overageBillingPeriod"`
	// List of overage prices of the package
	OveragePrices []*Price `json:"overagePrices"`
	// List of prices for the plan
	Prices []*Price `json:"prices"`
	// The pricing type of the package
	PricingType *PricingType `json:"pricingType"`
	Product     Product      `json:"product"`
	// The product id of the package
	ProductID *string `json:"productId"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// The status of the package
	Status PackageStatus `json:"status"`
	// Sync states of the plan with external systems
	SyncStates []*SyncState `json:"syncStates"`
	// The type of the package
	Type string `json:"type"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The version number of the package
	VersionNumber int64 `json:"versionNumber"`
}

type PlanAggregateGroupBy struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	IsLatest      *bool          `json:"isLatest"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanAvgAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

type PlanChangeAddon struct {
	AddonRefID string  `json:"addonRefId"`
	Quantity   float64 `json:"quantity"`
}

type PlanChangeVariables struct {
	Addons           []*PlanChangeAddon              `json:"addons"`
	BillableFeatures []*BillableFeature              `json:"billableFeatures"`
	BillingPeriod    *BillingPeriod                  `json:"billingPeriod"`
	ChangeType       PlanChangeType                  `json:"changeType"`
	PlanRefID        string                          `json:"planRefId"`
	PriceOverrides   []*PriceOverrideChangeVariables `json:"priceOverrides"`
}

func (PlanChangeVariables) IsScheduleVariables() {}

// Package group changed
type PlanCompatibleAddonChange struct {
	// The value after the change
	After *Addon `json:"after"`
	// The value before the change
	Before *Addon `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Package group change
type PlanCompatiblePackageGroupChange struct {
	// The value after the change
	After *PackageGroup `json:"after"`
	// The value before the change
	Before *PackageGroup `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

// Plan compatible package group options
type PlanCompatiblePackageGroupOptions struct {
	// Number of free items from package group
	FreeItems *float64 `json:"freeItems"`
	// Number of required items from package group
	MinItems *float64 `json:"minItems"`
}

// Plan compatible package group
type PlanCompatiblePackageGroups struct {
	// Included addons in the package group
	Addons []*Addon `json:"addons"`
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// The description of the package group
	Description *string `json:"description"`
	// The display name of the package group
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Indicates if this is the latest version of the package group
	IsLatest bool `json:"isLatest"`
	// Plan compatible package group options
	Options PlanCompatiblePackageGroupOptions `json:"options"`
	// The id of the package group
	PackageGroupID string  `json:"packageGroupId"`
	Product        Product `json:"product"`
	// The id of the related product
	ProductID *string `json:"productId"`
	// The status of the package group (draft, published, archived)
	Status PackageGroupStatus `json:"status"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
	// The version number of the package group
	VersionNumber int64 `json:"versionNumber"`
}

type PlanConnection struct {
	// Array of edges.
	Edges []*PlanEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PlanCountAggregate struct {
	BillingID     *int64 `json:"billingId"`
	CreatedAt     *int64 `json:"createdAt"`
	Description   *int64 `json:"description"`
	DisplayName   *int64 `json:"displayName"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	IsLatest      *int64 `json:"isLatest"`
	PricingType   *int64 `json:"pricingType"`
	ProductID     *int64 `json:"productId"`
	RefID         *int64 `json:"refId"`
	Status        *int64 `json:"status"`
	UpdatedAt     *int64 `json:"updatedAt"`
	VersionNumber *int64 `json:"versionNumber"`
}

// Input for creating a plan
type PlanCreateInput struct {
	// The additional meta data of the package
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The AWS marketplace plan dimension of the package
	AwsMarketplacePlanDimension *string `json:"awsMarketplacePlanDimension,omitempty"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId,omitempty"`
	// The description of the package
	Description *string `json:"description,omitempty"`
	// The display name of the package
	DisplayName string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// List of hidden widgets of the package
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets,omitempty"`
	// The ID of the parent plan, if applicable
	ParentPlanID *string `json:"parentPlanId,omitempty"`
	// The pricing type of the package
	PricingType *PricingType `json:"pricingType,omitempty"`
	// The product id of the package
	ProductID string `json:"productId"`
	// The unique identifier for the entity
	RefID *string `json:"refId,omitempty"`
	// The status of the package
	Status *PackageStatus `json:"status,omitempty"`
}

type PlanEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Plan
	Node Plan `json:"node"`
}

type PlanFilter struct {
	And              []*PlanFilter                  `json:"and,omitempty"`
	BillingID        *StringFieldComparison         `json:"billingId,omitempty"`
	CompatibleAddons *PlanFilterAddonFilter         `json:"compatibleAddons,omitempty"`
	CreatedAt        *DateFieldComparison           `json:"createdAt,omitempty"`
	Description      *StringFieldComparison         `json:"description,omitempty"`
	DisplayName      *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID    *UUIDFilterComparison          `json:"environmentId,omitempty"`
	ID               *UUIDFilterComparison          `json:"id,omitempty"`
	IsLatest         *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or               []*PlanFilter                  `json:"or,omitempty"`
	PricingType      *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	Product          *PlanFilterProductFilter       `json:"product,omitempty"`
	ProductID        *StringFieldComparison         `json:"productId,omitempty"`
	RefID            *StringFieldComparison         `json:"refId,omitempty"`
	Status           *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt        *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber    *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PlanFilterAddonFilter struct {
	And           []*PlanFilterAddonFilter       `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison          `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison          `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*PlanFilterAddonFilter       `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PlanFilterProductFilter struct {
	And                       []*PlanFilterProductFilter `json:"and,omitempty"`
	AwsMarketplaceProductCode *StringFieldComparison     `json:"awsMarketplaceProductCode,omitempty"`
	AwsMarketplaceProductID   *StringFieldComparison     `json:"awsMarketplaceProductId,omitempty"`
	CreatedAt                 *DateFieldComparison       `json:"createdAt,omitempty"`
	Description               *StringFieldComparison     `json:"description,omitempty"`
	DisplayName               *StringFieldComparison     `json:"displayName,omitempty"`
	EnvironmentID             *UUIDFilterComparison      `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison      `json:"id,omitempty"`
	IsDefaultProduct          *BooleanFieldComparison    `json:"isDefaultProduct,omitempty"`
	MultipleSubscriptions     *BooleanFieldComparison    `json:"multipleSubscriptions,omitempty"`
	Or                        []*PlanFilterProductFilter `json:"or,omitempty"`
	RefID                     *StringFieldComparison     `json:"refId,omitempty"`
	UpdatedAt                 *DateFieldComparison       `json:"updatedAt,omitempty"`
}

type PlanMaxAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanMinAggregate struct {
	BillingID     *string        `json:"billingId"`
	CreatedAt     *string        `json:"createdAt"`
	Description   *string        `json:"description"`
	DisplayName   *string        `json:"displayName"`
	EnvironmentID *string        `json:"environmentId"`
	ID            *string        `json:"id"`
	PricingType   *PricingType   `json:"pricingType"`
	ProductID     *string        `json:"productId"`
	RefID         *string        `json:"refId"`
	Status        *PackageStatus `json:"status"`
	UpdatedAt     *string        `json:"updatedAt"`
	VersionNumber *int64         `json:"versionNumber"`
}

type PlanNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type PlanPriceOverrideChangeVariables struct {
	FeatureID *string `json:"featureId"`
	PlanRefID string  `json:"planRefId"`
}

func (PlanPriceOverrideChangeVariables) IsScheduleVariables() {}

type PlanSort struct {
	Direction SortDirection  `json:"direction"`
	Field     PlanSortFields `json:"field"`
	Nulls     *SortNulls     `json:"nulls,omitempty"`
}

type PlanSumAggregate struct {
	VersionNumber *float64 `json:"versionNumber"`
}

// Input for updating a plan
type PlanUpdateInput struct {
	// Additional metadata for the plan, e.g. features or tags
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId,omitempty"`
	// Default trial configuration for the plan
	DefaultTrialConfig *DefaultTrialConfigInputDto `json:"defaultTrialConfig,omitempty"`
	// The description of the plan
	Description *string `json:"description,omitempty"`
	// The display name of the plan
	DisplayName *string `json:"displayName,omitempty"`
	// Indicates if the plan should be hidden from widgets
	HiddenFromWidgets []WidgetType `json:"hiddenFromWidgets,omitempty"`
	// The ID of the plan to update
	ID string `json:"id"`
	// The minimum spend configuration per each billing period
	MinimumSpend []*MinimumSpendInput `json:"minimumSpend,omitempty"`
	// The ID of the parent plan, if applicable
	ParentPlanID *string `json:"parentPlanId,omitempty"`
	// The status of the plan, e.g. "active" or "archived"
	Status *PackageStatus `json:"status,omitempty"`
}

// Input for preparing a payment method form
type PreparePaymentMethodFormInput struct {
	// Customer slug
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The billing integration to use for this payment method
	IntegrationID *string `json:"integrationId,omitempty"`
}

// Response for preparing a payment method form
type PreparedPaymentMethodForm struct {
	// The integration id of the payment method
	IntegrationID string `json:"integrationId"`
	// The payment method form details
	PaymentMethodForm PaymentMethodForm `json:"paymentMethodForm"`
	// The integration type to attach the payment method to
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

// Input to preview the next invoice for a subscription
type PreviewNextInvoiceInput struct {
	// The environment id of the subscription to preview
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The subscription id to preview
	SubscriptionID string `json:"subscriptionId"`
}

type PreviewSubscriptionInput struct {
	Addons []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon      *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	BillableFeatures   []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingCountryCode *string                  `json:"billingCountryCode,omitempty"`
	BillingInformation *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod      *BillingPeriod           `json:"billingPeriod,omitempty"`
	CustomerID         string                   `json:"customerId"`
	EnvironmentID      *string                  `json:"environmentId,omitempty"`
	// The customer that will pay for the subscription
	PayingCustomerID *string           `json:"payingCustomerId,omitempty"`
	PlanID           string            `json:"planId"`
	PromotionCode    *string           `json:"promotionCode,omitempty"`
	ResourceID       *string           `json:"resourceId,omitempty"`
	ScheduleStrategy *ScheduleStrategy `json:"scheduleStrategy,omitempty"`
	StartDate        *string           `json:"startDate,omitempty"`
	// trial configuration to override the default values from plan if exists
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

// Price
type Price struct {
	// The billing cadence of the price
	BillingCadence BillingCadence `json:"billingCadence"`
	// The billing country code of the price
	BillingCountryCode *string `json:"billingCountryCode"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The billing model of the price
	BillingModel BillingModel `json:"billingModel"`
	// The billing period of the price
	BillingPeriod BillingPeriod `json:"billingPeriod"`
	// The number of units per block
	BlockSize *float64 `json:"blockSize"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The CRM id of the price
	CrmID *string `json:"crmId"`
	// The CRM link url of the price
	CrmLinkURL *string `json:"crmLinkUrl"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// Get the feature of the price
	Feature *Feature `json:"feature"`
	// The feature id of the price
	FeatureID *string `json:"featureId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Indication whether the subscription price is an override price
	IsOverridePrice bool `json:"isOverridePrice"`
	// The maximum unit quantity of the price
	MaxUnitQuantity *float64 `json:"maxUnitQuantity"`
	// The minimum unit quantity of the price
	MinUnitQuantity *float64   `json:"minUnitQuantity"`
	Package         PackageDto `json:"package"`
	// The package id of the price
	PackageID *string `json:"packageId"`
	// The price amount of the price
	Price *Money `json:"price"`
	// The reset period of the price
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// The reset period configuration of the price
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	// List of tiers of the price
	Tiers []*PriceTier `json:"tiers"`
	// The tiers mode of the price
	TiersMode *TiersMode `json:"tiersMode"`
	// Indicates if the price is used in subscriptions
	UsedInSubscriptions *bool `json:"usedInSubscriptions"`
}

type PriceAggregateGroupBy struct {
	BillingCadence *BillingCadence `json:"billingCadence"`
	BillingID      *string         `json:"billingId"`
	BillingModel   *BillingModel   `json:"billingModel"`
	BillingPeriod  *BillingPeriod  `json:"billingPeriod"`
	CreatedAt      *string         `json:"createdAt"`
	ID             *string         `json:"id"`
	TiersMode      *TiersMode      `json:"tiersMode"`
}

type PriceCountAggregate struct {
	BillingCadence *int64 `json:"billingCadence"`
	BillingID      *int64 `json:"billingId"`
	BillingModel   *int64 `json:"billingModel"`
	BillingPeriod  *int64 `json:"billingPeriod"`
	CreatedAt      *int64 `json:"createdAt"`
	ID             *int64 `json:"id"`
	TiersMode      *int64 `json:"tiersMode"`
}

type PriceDeleteResponse struct {
	// The billing cadence of the price
	BillingCadence *BillingCadence `json:"billingCadence"`
	// The billing country code of the price
	BillingCountryCode *string `json:"billingCountryCode"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId"`
	// The billing model of the price
	BillingModel *BillingModel `json:"billingModel"`
	// The billing period of the price
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
	// The number of units per block
	BlockSize *float64 `json:"blockSize"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The CRM id of the price
	CrmID *string `json:"crmId"`
	// The CRM link url of the price
	CrmLinkURL *string `json:"crmLinkUrl"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// The feature of the price
	Feature *Feature `json:"feature"`
	// The feature id of the price
	FeatureID *string `json:"featureId"`
	// Unique identifier for the entity
	ID *string `json:"id"`
	// The maximum unit quantity of the price
	MaxUnitQuantity *float64 `json:"maxUnitQuantity"`
	// The minimum unit quantity of the price
	MinUnitQuantity *float64 `json:"minUnitQuantity"`
	// The package id of the price
	PackageID *string `json:"packageId"`
	// The price amount of the price
	Price *Money `json:"price"`
	// The reset period of the price
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// The reset period configuration of the price
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	// List of tiers of the price
	Tiers []*PriceTier `json:"tiers"`
	// The tiers mode of the price
	TiersMode *TiersMode `json:"tiersMode"`
	// Indicates if the price is used in subscriptions
	UsedInSubscriptions *bool `json:"usedInSubscriptions"`
}

type PriceEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Price
	Node Price `json:"node"`
}

// Entitlement that is granted as part of a price component.
type PriceEntitlement struct {
	// Detailed description of the entitlement associated with the pricing component.
	Description *string `json:"description"`
	// The feature this entitlement corresponds to.
	Feature Feature `json:"feature"`
	// The internal ID of the feature linked to this entitlement.
	FeatureID string `json:"featureId"`
	// Indicates whether the usage limit is soft — usage can exceed the limit, but will be tracked.
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Indicates whether this entitlement grants unlimited usage with no enforced cap.
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage"`
	// The package that this entitlement is associated with.
	Package PackageDto `json:"package"`
	// The internal ID of the package or plan that granted this entitlement.
	PackageID string `json:"packageId"`
	// The interval at which usage resets automatically, such as monthly or yearly.
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// Detailed configuration object specifying the usage reset schedule.
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The maximum allowed usage for this entitlement before restrictions apply.
	UsageLimit *float64 `json:"usageLimit"`
}

type PriceFilter struct {
	And            []*PriceFilter                  `json:"and,omitempty"`
	BillingCadence *BillingCadenceFilterComparison `json:"billingCadence,omitempty"`
	BillingID      *StringFieldComparison          `json:"billingId,omitempty"`
	BillingModel   *BillingModelFilterComparison   `json:"billingModel,omitempty"`
	BillingPeriod  *BillingPeriodFilterComparison  `json:"billingPeriod,omitempty"`
	CreatedAt      *DateFieldComparison            `json:"createdAt,omitempty"`
	ID             *UUIDFilterComparison           `json:"id,omitempty"`
	Or             []*PriceFilter                  `json:"or,omitempty"`
	Package        *PriceFilterPackageDTOFilter    `json:"package,omitempty"`
	TiersMode      *TiersModeFilterComparison      `json:"tiersMode,omitempty"`
}

type PriceFilterPackageDTOFilter struct {
	And           []*PriceFilterPackageDTOFilter `json:"and,omitempty"`
	BillingID     *StringFieldComparison         `json:"billingId,omitempty"`
	CreatedAt     *DateFieldComparison           `json:"createdAt,omitempty"`
	Description   *StringFieldComparison         `json:"description,omitempty"`
	DisplayName   *StringFieldComparison         `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison          `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison          `json:"id,omitempty"`
	IsLatest      *BooleanFieldComparison        `json:"isLatest,omitempty"`
	Or            []*PriceFilterPackageDTOFilter `json:"or,omitempty"`
	PricingType   *PricingTypeFilterComparison   `json:"pricingType,omitempty"`
	ProductID     *StringFieldComparison         `json:"productId,omitempty"`
	RefID         *StringFieldComparison         `json:"refId,omitempty"`
	Status        *PackageStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison           `json:"updatedAt,omitempty"`
	VersionNumber *IntFieldComparison            `json:"versionNumber,omitempty"`
}

type PriceMaxAggregate struct {
	BillingCadence *BillingCadence `json:"billingCadence"`
	BillingID      *string         `json:"billingId"`
	BillingModel   *BillingModel   `json:"billingModel"`
	BillingPeriod  *BillingPeriod  `json:"billingPeriod"`
	CreatedAt      *string         `json:"createdAt"`
	ID             *string         `json:"id"`
	TiersMode      *TiersMode      `json:"tiersMode"`
}

type PriceMinAggregate struct {
	BillingCadence *BillingCadence `json:"billingCadence"`
	BillingID      *string         `json:"billingId"`
	BillingModel   *BillingModel   `json:"billingModel"`
	BillingPeriod  *BillingPeriod  `json:"billingPeriod"`
	CreatedAt      *string         `json:"createdAt"`
	ID             *string         `json:"id"`
	TiersMode      *TiersMode      `json:"tiersMode"`
}

type PriceNotFoundError struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PriceOverrideChangeVariables struct {
	AddonRefID *string `json:"addonRefId"`
	FeatureID  *string `json:"featureId"`
	PlanRefID  *string `json:"planRefId"`
}

type PriceOverrideInput struct {
	// The corresponding addon id of the price
	AddonID *string `json:"addonId,omitempty"`
	// Whether the price is a base charge
	BaseCharge *bool `json:"baseCharge,omitempty"`
	// The number of units per block. Defaults to 1 unit
	BlockSize *float64 `json:"blockSize,omitempty"`
	// The corresponding feature id of the price
	FeatureID *string `json:"featureId,omitempty"`
	// The price of the price period
	Price *MoneyInputDto `json:"price,omitempty"`
	// List of tiers of the price period
	Tiers []*PriceTierInput `json:"tiers,omitempty"`
}

// Price Period Input
type PricePeriodInput struct {
	// The billing country code of the price
	BillingCountryCode *string `json:"billingCountryCode,omitempty"`
	// The billing period of the price
	BillingPeriod BillingPeriod `json:"billingPeriod"`
	// The number of units per block. Defaults to 1 unit
	BlockSize *float64 `json:"blockSize,omitempty"`
	// The price of the price period
	Price *MoneyInputDto `json:"price,omitempty"`
	// List of tiers of the price period
	Tiers []*PriceTierInput `json:"tiers,omitempty"`
}

type PriceSort struct {
	Direction SortDirection   `json:"direction"`
	Field     PriceSortFields `json:"field"`
	Nulls     *SortNulls      `json:"nulls,omitempty"`
}

// Price Tier
type PriceTier struct {
	// The flat fee price of the price tier
	FlatPrice *Money `json:"flatPrice"`
	// The unit price of the price tier
	UnitPrice *Money `json:"unitPrice"`
	// The up to quantity of the price tier
	UpTo *float64 `json:"upTo"`
}

// Price Tier Input
type PriceTierInput struct {
	// The flat fee price of the price tier
	FlatPrice *MoneyInputDto `json:"flatPrice,omitempty"`
	// The unit price of the price tier
	UnitPrice *MoneyInputDto `json:"unitPrice,omitempty"`
	// The up to quantity of the price tier
	UpTo *float64 `json:"upTo,omitempty"`
}

// Pricing Model Create Input
type PricingModelCreateInput struct {
	// The billing cadence of the base pricing model
	BillingCadence *BillingCadence `json:"billingCadence,omitempty"`
	// The billing model of the base pricing model
	BillingModel BillingModel `json:"billingModel"`
	// The feature id of the base pricing model
	FeatureID *string `json:"featureId,omitempty"`
	// The maximum unit quantity of the pricing model
	MaxUnitQuantity *float64 `json:"maxUnitQuantity,omitempty"`
	// The minimum unit quantity of the pricing model
	MinUnitQuantity *float64 `json:"minUnitQuantity,omitempty"`
	// The monthly reset period configuration of the pricing model
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The price periods of the base pricing model
	PricePeriods []*PricePeriodInput `json:"pricePeriods"`
	// The reset period of the pricing model
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The tiers mode of the pricing model
	TiersMode *TiersMode `json:"tiersMode,omitempty"`
	// The weekly reset period configuration of the pricing model
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the pricing model
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

// Pricing type change
type PricingTypeChange struct {
	// The value after the change
	After *PricingType `json:"after"`
	// The value before the change
	Before *PricingType `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

type PricingTypeFilterComparison struct {
	Eq       *PricingType  `json:"eq,omitempty"`
	Gt       *PricingType  `json:"gt,omitempty"`
	Gte      *PricingType  `json:"gte,omitempty"`
	ILike    *PricingType  `json:"iLike,omitempty"`
	In       []PricingType `json:"in,omitempty"`
	Is       *bool         `json:"is,omitempty"`
	IsNot    *bool         `json:"isNot,omitempty"`
	Like     *PricingType  `json:"like,omitempty"`
	Lt       *PricingType  `json:"lt,omitempty"`
	Lte      *PricingType  `json:"lte,omitempty"`
	Neq      *PricingType  `json:"neq,omitempty"`
	NotILike *PricingType  `json:"notILike,omitempty"`
	NotIn    []PricingType `json:"notIn,omitempty"`
	NotLike  *PricingType  `json:"notLike,omitempty"`
}

// Product object
type Product struct {
	// Additional metadata for the product
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// Addons associated with the product
	Addons []*Addon `json:"addons"`
	// Method to get the auto cancellation rules for the product
	AutoCancellationRules []*AutoCancellationRule `json:"autoCancellationRules"`
	// AWS Marketplace product code
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	// AWS Marketplace product ID
	AwsMarketplaceProductID *string `json:"awsMarketplaceProductId"`
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// Description of the product
	Description *string `json:"description"`
	// Display name of the product
	DisplayName   *string      `json:"displayName"`
	DowngradePlan *Plan        `json:"downgradePlan"`
	Environment   *Environment `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Whether the product has subscriptions
	HasSubscriptions bool `json:"hasSubscriptions"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Indicates if this is the default product for the account
	IsDefaultProduct bool `json:"isDefaultProduct"`
	// Indicates if multiple subscriptions to this product are allowed
	MultipleSubscriptions bool `json:"multipleSubscriptions"`
	// Plans associated with the product
	Plans []*Plan `json:"plans"`
	// Settings for the product
	ProductSettings ProductSettings `json:"productSettings"`
	// The unique identifier for the entity
	RefID                 string `json:"refId"`
	SubscriptionStartPlan *Plan  `json:"subscriptionStartPlan"`
	// Method to get the rule for resetting usage cutoff on subscription update
	SubscriptionUpdateUsageResetCutoffRule SubscriptionUpdateUsageResetCutoffRule `json:"subscriptionUpdateUsageResetCutoffRule"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
}

type ProductAggregateGroupBy struct {
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string `json:"awsMarketplaceProductId"`
	CreatedAt                 *string `json:"createdAt"`
	Description               *string `json:"description"`
	DisplayName               *string `json:"displayName"`
	EnvironmentID             *string `json:"environmentId"`
	ID                        *string `json:"id"`
	IsDefaultProduct          *bool   `json:"isDefaultProduct"`
	MultipleSubscriptions     *bool   `json:"multipleSubscriptions"`
	RefID                     *string `json:"refId"`
	UpdatedAt                 *string `json:"updatedAt"`
}

// DTO representing a product catalog dump
type ProductCatalogDump struct {
	// The complete product catalog configuration dump
	Dump map[string]interface{} `json:"dump"`
}

type ProductConnection struct {
	// Array of edges.
	Edges []*ProductEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type ProductCountAggregate struct {
	AwsMarketplaceProductCode *int64 `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *int64 `json:"awsMarketplaceProductId"`
	CreatedAt                 *int64 `json:"createdAt"`
	Description               *int64 `json:"description"`
	DisplayName               *int64 `json:"displayName"`
	EnvironmentID             *int64 `json:"environmentId"`
	ID                        *int64 `json:"id"`
	IsDefaultProduct          *int64 `json:"isDefaultProduct"`
	MultipleSubscriptions     *int64 `json:"multipleSubscriptions"`
	RefID                     *int64 `json:"refId"`
	UpdatedAt                 *int64 `json:"updatedAt"`
}

// Input for creating a product
type ProductCreateInput struct {
	// Additional metadata for the product
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// Description of the product
	Description *string `json:"description,omitempty"`
	// Display name of the product
	DisplayName *string `json:"displayName,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Indicates if multiple subscriptions to this product are allowed
	MultipleSubscriptions *bool `json:"multipleSubscriptions,omitempty"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
}

// Product deletion response
type ProductDeleteResponse struct {
	// Additional metadata for the deleted product
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	// Addons associated with the deleted product
	Addons []*Addon `json:"addons"`
	// AWS Marketplace product code of the deleted product
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	// AWS Marketplace product ID of the deleted product
	AwsMarketplaceProductID *string `json:"awsMarketplaceProductId"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Description of the deleted product
	Description *string `json:"description"`
	// Display name of the deleted product
	DisplayName *string `json:"displayName"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// Unique identifier for the entity
	ID *string `json:"id"`
	// Indicates if the deleted product was the default product
	IsDefaultProduct *bool `json:"isDefaultProduct"`
	// Indicates if multiple subscriptions to the deleted product were allowed
	MultipleSubscriptions *bool `json:"multipleSubscriptions"`
	// Plans associated with the deleted product
	Plans []*Plan `json:"plans"`
	// Settings for the deleted product
	ProductSettings *ProductSettings `json:"productSettings"`
	// The unique identifier for the entity
	RefID *string `json:"refId"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
}

type ProductEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the Product
	Node Product `json:"node"`
}

type ProductFilter struct {
	And                       []*ProductFilter        `json:"and,omitempty"`
	AwsMarketplaceProductCode *StringFieldComparison  `json:"awsMarketplaceProductCode,omitempty"`
	AwsMarketplaceProductID   *StringFieldComparison  `json:"awsMarketplaceProductId,omitempty"`
	CreatedAt                 *DateFieldComparison    `json:"createdAt,omitempty"`
	Description               *StringFieldComparison  `json:"description,omitempty"`
	DisplayName               *StringFieldComparison  `json:"displayName,omitempty"`
	EnvironmentID             *UUIDFilterComparison   `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison   `json:"id,omitempty"`
	IsDefaultProduct          *BooleanFieldComparison `json:"isDefaultProduct,omitempty"`
	MultipleSubscriptions     *BooleanFieldComparison `json:"multipleSubscriptions,omitempty"`
	Or                        []*ProductFilter        `json:"or,omitempty"`
	RefID                     *StringFieldComparison  `json:"refId,omitempty"`
	UpdatedAt                 *DateFieldComparison    `json:"updatedAt,omitempty"`
}

type ProductMaxAggregate struct {
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string `json:"awsMarketplaceProductId"`
	CreatedAt                 *string `json:"createdAt"`
	Description               *string `json:"description"`
	DisplayName               *string `json:"displayName"`
	EnvironmentID             *string `json:"environmentId"`
	ID                        *string `json:"id"`
	RefID                     *string `json:"refId"`
	UpdatedAt                 *string `json:"updatedAt"`
}

type ProductMinAggregate struct {
	AwsMarketplaceProductCode *string `json:"awsMarketplaceProductCode"`
	AwsMarketplaceProductID   *string `json:"awsMarketplaceProductId"`
	CreatedAt                 *string `json:"createdAt"`
	Description               *string `json:"description"`
	DisplayName               *string `json:"displayName"`
	EnvironmentID             *string `json:"environmentId"`
	ID                        *string `json:"id"`
	RefID                     *string `json:"refId"`
	UpdatedAt                 *string `json:"updatedAt"`
}

// Product settings object
type ProductSettings struct {
	// Plan to downgrade to at the end of the billing period
	DowngradePlan *Plan `json:"downgradePlan"`
	// ID of the plan to downgrade to at the end of the billing period
	DowngradePlanID *string `json:"downgradePlanId"`
	// Indicates if the subscription should be prorated at the end of the billing period
	ProrateAtEndOfBillingPeriod *bool `json:"prorateAtEndOfBillingPeriod"`
	// Time when the subscription will be cancelled
	SubscriptionCancellationTime SubscriptionCancellationTime `json:"subscriptionCancellationTime"`
	// Setup for the end of the subscription
	SubscriptionEndSetup SubscriptionEndSetup `json:"subscriptionEndSetup"`
	// Plan to start the subscription with
	SubscriptionStartPlan *Plan `json:"subscriptionStartPlan"`
	// ID of the plan to start the subscription with
	SubscriptionStartPlanID *string `json:"subscriptionStartPlanId"`
	// Setup for the start of the subscription
	SubscriptionStartSetup SubscriptionStartSetup `json:"subscriptionStartSetup"`
}

// Input for product settings
type ProductSettingsInput struct {
	// Indicates if the subscription should be downgraded at the end of the billing period
	DowngradeAtEndOfBillingPeriod *string `json:"downgradeAtEndOfBillingPeriod,omitempty"`
	// ID of the plan to downgrade to at the end of the billing period
	DowngradePlanID *string `json:"downgradePlanId,omitempty"`
	// Indicates if the subscription should be prorated at the end of the billing period
	ProrateAtEndOfBillingPeriod *bool `json:"prorateAtEndOfBillingPeriod,omitempty"`
	// Time when the subscription will be cancelled
	SubscriptionCancellationTime SubscriptionCancellationTime `json:"subscriptionCancellationTime"`
	// Setup for the end of the subscription
	SubscriptionEndSetup SubscriptionEndSetup `json:"subscriptionEndSetup"`
	// ID of the plan to start the subscription with
	SubscriptionStartPlanID *string `json:"subscriptionStartPlanId,omitempty"`
	// Setup for the start of the subscription
	SubscriptionStartSetup SubscriptionStartSetup `json:"subscriptionStartSetup"`
}

type ProductSort struct {
	Direction SortDirection     `json:"direction"`
	Field     ProductSortFields `json:"field"`
	Nulls     *SortNulls        `json:"nulls,omitempty"`
}

// Input for updating a product
type ProductUpdateInput struct {
	// Additional metadata for the product
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// Auto cancellation rules
	AutoCancellationRules []*AutoCancellationRuleInput `json:"autoCancellationRules,omitempty"`
	// Description of the product
	Description *string `json:"description,omitempty"`
	// Display name of the product
	DisplayName *string `json:"displayName,omitempty"`
	// Indicates if multiple subscriptions to this product are allowed
	MultipleSubscriptions *bool `json:"multipleSubscriptions,omitempty"`
	// Settings for the product
	ProductSettings *ProductSettingsInput `json:"productSettings,omitempty"`
	// Usage reset cutoff rule
	UsageResetCutoffRule *SubscriptionUpdateUsageResetCutoffRuleInput `json:"usageResetCutoffRule,omitempty"`
}

type PromotionCodeCustomerNotFirstPurchase struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeMaxRedemptionsReached struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeMinimumAmountNotReached struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeNotActive struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeNotForCustomer struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

type PromotionCodeNotFound struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

// Promotional entitlement
type PromotionalEntitlement struct {
	// Timestamp of when the record was created
	CreatedAt *string  `json:"createdAt"`
	Customer  Customer `json:"customer"`
	// The description of the entitlement
	Description *string `json:"description"`
	// The end date of the promotional entitlement
	EndDate *string `json:"endDate"`
	// The unique identifier for the environment
	EnvironmentID string  `json:"environmentId"`
	Feature       Feature `json:"feature"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool  `json:"hasUnlimitedUsage"`
	ID                string `json:"id"`
	// Whether the entitlement is visible
	IsVisible bool   `json:"isVisible"`
	Meter     *Meter `json:"meter"`
	// The grant period of the promotional entitlement
	Period PromotionalEntitlementPeriod `json:"period"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// The reset period configuration of the entitlement
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	// The start date of the entitlement
	StartDate string `json:"startDate"`
	// The status of the entitlement
	Status PromotionalEntitlementStatus `json:"status"`
	// Whether the entitlement has an unlimited usage
	Unlimited *bool `json:"unlimited"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit"`
}

type PromotionalEntitlementAggregateGroupBy struct {
	CreatedAt     *string                       `json:"createdAt"`
	EnvironmentID *string                       `json:"environmentId"`
	ID            *string                       `json:"id"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	UpdatedAt     *string                       `json:"updatedAt"`
}

type PromotionalEntitlementConnection struct {
	// Array of edges.
	Edges []*PromotionalEntitlementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type PromotionalEntitlementCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
	UpdatedAt     *int64 `json:"updatedAt"`
}

type PromotionalEntitlementDeleteResponse struct {
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The description of the entitlement
	Description *string `json:"description"`
	// The end date of the promotional entitlement
	EndDate *string `json:"endDate"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// The unique identifier of the entitlement feature
	FeatureID *string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool   `json:"hasUnlimitedUsage"`
	ID                *string `json:"id"`
	// Whether the entitlement is visible
	IsVisible *bool `json:"isVisible"`
	// The grant period of the promotional entitlement
	Period *PromotionalEntitlementPeriod `json:"period"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// The reset period configuration of the entitlement
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	// The start date of the entitlement
	StartDate *string `json:"startDate"`
	// The status of the entitlement
	Status *PromotionalEntitlementStatus `json:"status"`
	// Whether the entitlement has an unlimited usage
	Unlimited *bool `json:"unlimited"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit"`
}

type PromotionalEntitlementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the PromotionalEntitlement
	Node PromotionalEntitlement `json:"node"`
}

type PromotionalEntitlementFilter struct {
	And           []*PromotionalEntitlementFilter               `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	EnvironmentID *UUIDFilterComparison                         `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison                         `json:"id,omitempty"`
	Or            []*PromotionalEntitlementFilter               `json:"or,omitempty"`
	Status        *PromotionalEntitlementStatusFilterComparison `json:"status,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
}

// Promotional entitlement input
type PromotionalEntitlementInput struct {
	// The unique identifier of the entitlement customer
	CustomerID string `json:"customerId"`
	// The description of the entitlement
	Description *string `json:"description,omitempty"`
	// The end date of the promotional entitlement
	EndDate *string `json:"endDate,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Whether the entitlement is visible
	IsVisible bool `json:"isVisible"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The grant period of the promotional entitlement
	Period PromotionalEntitlementPeriod `json:"period"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the entitlement, defined when reset period is yearly
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type PromotionalEntitlementMaxAggregate struct {
	CreatedAt     *string                       `json:"createdAt"`
	EnvironmentID *string                       `json:"environmentId"`
	ID            *string                       `json:"id"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	UpdatedAt     *string                       `json:"updatedAt"`
}

type PromotionalEntitlementMinAggregate struct {
	CreatedAt     *string                       `json:"createdAt"`
	EnvironmentID *string                       `json:"environmentId"`
	ID            *string                       `json:"id"`
	Status        *PromotionalEntitlementStatus `json:"status"`
	UpdatedAt     *string                       `json:"updatedAt"`
}

type PromotionalEntitlementSort struct {
	Direction SortDirection                    `json:"direction"`
	Field     PromotionalEntitlementSortFields `json:"field"`
	Nulls     *SortNulls                       `json:"nulls,omitempty"`
}

type PromotionalEntitlementStatusFilterComparison struct {
	Eq       *PromotionalEntitlementStatus  `json:"eq,omitempty"`
	Gt       *PromotionalEntitlementStatus  `json:"gt,omitempty"`
	Gte      *PromotionalEntitlementStatus  `json:"gte,omitempty"`
	ILike    *PromotionalEntitlementStatus  `json:"iLike,omitempty"`
	In       []PromotionalEntitlementStatus `json:"in,omitempty"`
	Is       *bool                          `json:"is,omitempty"`
	IsNot    *bool                          `json:"isNot,omitempty"`
	Like     *PromotionalEntitlementStatus  `json:"like,omitempty"`
	Lt       *PromotionalEntitlementStatus  `json:"lt,omitempty"`
	Lte      *PromotionalEntitlementStatus  `json:"lte,omitempty"`
	Neq      *PromotionalEntitlementStatus  `json:"neq,omitempty"`
	NotILike *PromotionalEntitlementStatus  `json:"notILike,omitempty"`
	NotIn    []PromotionalEntitlementStatus `json:"notIn,omitempty"`
	NotLike  *PromotionalEntitlementStatus  `json:"notLike,omitempty"`
}

// Promotional entitlement update input
type PromotionalEntitlementUpdateInput struct {
	// The description of the entitlement
	Description *string `json:"description,omitempty"`
	// The end date of the promotional entitlement
	EndDate *string `json:"endDate,omitempty"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Whether the entitlement is visible
	IsVisible bool `json:"isVisible"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The grant period of the promotional entitlement
	Period PromotionalEntitlementPeriod `json:"period"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
}

// Input to provision a customer and subscription
type ProvisionCustomerInput struct {
	// Additional metadata
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The AWS Marketplace integration id
	AwsMarketplaceCustomerID *string `json:"awsMarketplaceCustomerId,omitempty"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId,omitempty"`
	// Customer billing information
	BillingInformation *CustomerBillingInfo `json:"billingInformation,omitempty"`
	// Customer level coupon
	CouponRefID *string `json:"couponRefId,omitempty"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// The unique identifier for the customer in Hubspot integration
	CrmID *string `json:"crmId,omitempty"`
	// Customer slug
	CustomerID *string `json:"customerId,omitempty"`
	// The email of the customer
	Email *string `json:"email,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Wether the customer should be excluded from the experiment
	ExcludeFromExperiment *bool `json:"excludeFromExperiment,omitempty"`
	// The name of the customer
	Name *string `json:"name,omitempty"`
	// Customer slug
	RefID *string `json:"refId,omitempty"`
	// The unique identifier for the customer in Salesforce integration
	SalesforceID *string `json:"salesforceId,omitempty"`
	// Wether or not to sync free subscriptions to the billing provider
	ShouldSyncFree *bool `json:"shouldSyncFree,omitempty"`
	// Subscription parameters
	SubscriptionParams *ProvisionCustomerSubscriptionInput `json:"subscriptionParams,omitempty"`
}

// Provision a new subscription for a customer
type ProvisionCustomerSubscriptionInput struct {
	AdditionalMetaData map[string]interface{}    `json:"additionalMetaData,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon            *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	AwaitPaymentConfirmation *bool                    `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures         []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingCountryCode       *string                  `json:"billingCountryCode,omitempty"`
	BillingID                *string                  `json:"billingId,omitempty"`
	BillingInformation       *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod            *BillingPeriod           `json:"billingPeriod,omitempty"`
	// Budget configuration
	Budget *BudgetConfigurationInput `json:"budget,omitempty"`
	// The minimum spend configuration
	MinimumSpend *SubscriptionMinimumSpendValueInput `json:"minimumSpend,omitempty"`
	// Subscription payment collection method
	PaymentCollectionMethod *PaymentCollectionMethod `json:"paymentCollectionMethod,omitempty"`
	PlanID                  string                   `json:"planId"`
	// Override the price of the subscription
	PriceOverrides             []*PriceOverrideInput            `json:"priceOverrides,omitempty"`
	PriceUnitAmount            *float64                         `json:"priceUnitAmount,omitempty"`
	PromotionCode              *string                          `json:"promotionCode,omitempty"`
	RefID                      *string                          `json:"refId,omitempty"`
	ResourceID                 *string                          `json:"resourceId,omitempty"`
	SalesforceID               *string                          `json:"salesforceId,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID             *string                          `json:"subscriptionId,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

// Input for provisioning a sandbox environment
type ProvisionSandboxInput struct {
	// The billing model to use for the sandbox environment
	BillingModel BillingModel `json:"billingModel"`
	// The name of the sandbox environment
	DisplayName string `json:"displayName"`
}

type ProvisionSubscription struct {
	AdditionalMetaData map[string]interface{}    `json:"additionalMetaData,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon            *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	AwaitPaymentConfirmation *bool                    `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures         []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingCountryCode       *string                  `json:"billingCountryCode,omitempty"`
	BillingID                *string                  `json:"billingId,omitempty"`
	BillingInformation       *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod            *BillingPeriod           `json:"billingPeriod,omitempty"`
	// Budget configuration
	Budget          *BudgetConfigurationInput `json:"budget,omitempty"`
	CheckoutOptions *CheckoutOptions          `json:"checkoutOptions,omitempty"`
	CustomerID      string                    `json:"customerId"`
	// The minimum spend configuration
	MinimumSpend     *SubscriptionMinimumSpendValueInput `json:"minimumSpend,omitempty"`
	PayingCustomerID *string                             `json:"payingCustomerId,omitempty"`
	// Subscription payment collection method
	PaymentCollectionMethod *PaymentCollectionMethod `json:"paymentCollectionMethod,omitempty"`
	PlanID                  string                   `json:"planId"`
	// Override the price of the subscription
	PriceOverrides             []*PriceOverrideInput            `json:"priceOverrides,omitempty"`
	PriceUnitAmount            *float64                         `json:"priceUnitAmount,omitempty"`
	PromotionCode              *string                          `json:"promotionCode,omitempty"`
	RefID                      *string                          `json:"refId,omitempty"`
	ResourceID                 *string                          `json:"resourceId,omitempty"`
	SalesforceID               *string                          `json:"salesforceId,omitempty"`
	ScheduleStrategy           *ScheduleStrategy                `json:"scheduleStrategy,omitempty"`
	SkipTrial                  *bool                            `json:"skipTrial,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID             *string                          `json:"subscriptionId,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

type ProvisionSubscriptionInput struct {
	AdditionalMetaData map[string]interface{}    `json:"additionalMetaData,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon            *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	AwaitPaymentConfirmation *bool                    `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures         []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingCountryCode       *string                  `json:"billingCountryCode,omitempty"`
	BillingID                *string                  `json:"billingId,omitempty"`
	BillingInformation       *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod            *BillingPeriod           `json:"billingPeriod,omitempty"`
	// Budget configuration
	Budget          *BudgetConfigurationInput `json:"budget,omitempty"`
	CheckoutOptions *CheckoutOptions          `json:"checkoutOptions,omitempty"`
	CustomerID      string                    `json:"customerId"`
	// The minimum spend configuration
	MinimumSpend     *SubscriptionMinimumSpendValueInput `json:"minimumSpend,omitempty"`
	PayingCustomerID *string                             `json:"payingCustomerId,omitempty"`
	// Subscription payment collection method
	PaymentCollectionMethod *PaymentCollectionMethod `json:"paymentCollectionMethod,omitempty"`
	PlanID                  string                   `json:"planId"`
	// Override the price of the subscription
	PriceOverrides             []*PriceOverrideInput            `json:"priceOverrides,omitempty"`
	PriceUnitAmount            *float64                         `json:"priceUnitAmount,omitempty"`
	PromotionCode              *string                          `json:"promotionCode,omitempty"`
	RefID                      *string                          `json:"refId,omitempty"`
	ResourceID                 *string                          `json:"resourceId,omitempty"`
	SalesforceID               *string                          `json:"salesforceId,omitempty"`
	ScheduleStrategy           *ScheduleStrategy                `json:"scheduleStrategy,omitempty"`
	SkipTrial                  *bool                            `json:"skipTrial,omitempty"`
	StartDate                  *string                          `json:"startDate,omitempty"`
	SubscriptionEntitlements   []*SubscriptionEntitlementInput  `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID             *string                          `json:"subscriptionId,omitempty"`
	TrialOverrideConfiguration *TrialOverrideConfigurationInput `json:"trialOverrideConfiguration,omitempty"`
	UnitQuantity               *float64                         `json:"unitQuantity,omitempty"`
}

type ProvisionSubscriptionResult struct {
	CheckoutBillingID *string                     `json:"checkoutBillingId"`
	CheckoutURL       *string                     `json:"checkoutUrl"`
	Entitlements      []*Entitlement              `json:"entitlements"`
	ID                string                      `json:"id"`
	IsScheduled       *bool                       `json:"isScheduled"`
	Status            ProvisionSubscriptionStatus `json:"status"`
	Subscription      *CustomerSubscription       `json:"subscription"`
}

// Response for provisioning a customer and subscription
type ProvisionedCustomer struct {
	// Customer slg
	Customer Customer `json:"customer"`
	// Entitlements
	Entitlements []*Entitlement `json:"entitlements"`
	// Provisioned subscription
	Subscription *CustomerSubscription `json:"subscription"`
	// Wether the subscription should be provision based on customer journey or input
	SubscriptionDecisionStrategy SubscriptionDecisionStrategy `json:"subscriptionDecisionStrategy"`
	// Wether the subscription should be provision based on customer journey or input
	SubscriptionStrategyDecision SubscriptionDecisionStrategy `json:"subscriptionStrategyDecision"`
}

// Publish Package Result
type PublishPackageResult struct {
	// The task id for the publish package operation
	TaskID *string `json:"taskId"`
}

// Input object for triggering entitlement recalculation for one or more customers.
type RecalculateEntitlementsInput struct {
	// List of customer IDs for which to recalculate entitlements.
	CustomerIds []string `json:"customerIds,omitempty"`
	// Identifier of the environment where recalculation should occur.
	EnvironmentID string `json:"environmentId"`
	// If true, recalculates entitlements for all customers in the environment.
	ForAllCustomers *bool `json:"forAllCustomers,omitempty"`
	// Optional flags to control recalculation side effects.
	SideEffectsOptions *RecalculateEntitlementsSideEffectsOptionsInput `json:"sideEffectsOptions,omitempty"`
}

// Output of the entitlement recalculation operation.
type RecalculateEntitlementsResult struct {
	// Identifier for the background task handling the recalculation.
	TaskID string `json:"taskId"`
}

// Flags to control side effects triggered during entitlement recalculation.
type RecalculateEntitlementsSideEffectsOptionsInput struct {
	// Prevents publishing entitlement updates to subscribers.
	SkipPublishToSubscribers *bool `json:"skipPublishToSubscribers,omitempty"`
	// Skips cache updates for recalculated entitlements.
	SkipWriteToCache *bool `json:"skipWriteToCache,omitempty"`
	// Skips updating the data catalog during recalculation.
	SkipWriteToDataCatalog *bool `json:"skipWriteToDataCatalog,omitempty"`
	// Skips writing entitlement recalculation events to the event log.
	SkipWriteToEventLog *bool `json:"skipWriteToEventLog,omitempty"`
}

type RemoveBasePlanFromPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveCompatibleAddonsFromPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type RemoveCouponFromCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveExperimentFromCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type RemoveExperimentFromCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

// Input for removing a feature group and his related entitlements (if there are no other groups they are a part of) from a package
type RemoveFeatureGroupFromPackageInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The group id to remove
	FeatureGroupID string `json:"featureGroupId"`
	// The unique identifier of the entitlement package
	PackageID string `json:"packageId"`
}

// Report usage base input
type ReportUsageBaseInput struct {
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// Customer id
	CustomerID string `json:"customerId"`
	// Additional dimensions for the usage report
	Dimensions map[string]interface{} `json:"dimensions,omitempty"`
	// Feature id
	FeatureID string `json:"featureId"`
	// Resource id
	ResourceID *string `json:"resourceId,omitempty"`
	// The method by which the usage value should be updated
	UpdateBehavior *UsageUpdateBehavior `json:"updateBehavior,omitempty"`
	// The value to report for usage
	Value float64 `json:"value"`
}

// Input for reporting usage in bulk
type ReportUsageBulkInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// A list of usage reports to be submitted in bulk
	Usages []*ReportUsageBaseInput `json:"usages"`
}

// Input parameters for reporting usage
type ReportUsageInput struct {
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// Customer id
	CustomerID string `json:"customerId"`
	// Additional dimensions for the usage report
	Dimensions map[string]interface{} `json:"dimensions,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Feature id
	FeatureID string `json:"featureId"`
	// Resource id
	ResourceID *string `json:"resourceId,omitempty"`
	// The method by which the usage value should be updated
	UpdateBehavior *UsageUpdateBehavior `json:"updateBehavior,omitempty"`
	// The value to report for usage
	Value float64 `json:"value"`
}

// Input for re-syncing an integration
type ResyncIntegrationInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Internal ID of the integration to re-sync
	IntegrationID string `json:"integrationId"`
	// Allow skipping entitlement recalculation
	RecalculateEntitlements *bool `json:"recalculateEntitlements,omitempty"`
	// The vendor identifier of integration
	VendorIdentifier *VendorIdentifier `json:"vendorIdentifier,omitempty"`
}

// Result of the re-sync operation
type ResyncIntegrationResult struct {
	// ID of the integration that was re-synced
	IntegrationID string `json:"integrationId"`
	// ID of the task associated with the re-sync operation
	TaskID *string `json:"taskId"`
}

// Revoke promotional entitlement input
type RevokePromotionalEntitlementInput struct {
	// The unique identifier of the entitlement customer
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
}

// Salesforce integration configuration object
type SalesforceCredentials struct {
	// Domain of the Salesforce account
	Domain *string `json:"domain"`
}

func (SalesforceCredentials) IsCredentials() {}

// Input configuration for Salesforce Integration
type SalesforceCredentialsInput struct {
	// Domain of the Salesforce account
	Domain *string `json:"domain,omitempty"`
}

// Overall SDK configuration for the current environment.
type SdkConfiguration struct {
	// Flag to determine whether the Stigg watermark should be displayed in widgets.
	IsWidgetWatermarkEnabled *bool `json:"isWidgetWatermarkEnabled"`
	// Sentry DSN (Data Source Name) used for error logging and monitoring.
	SentryDsn *string `json:"sentryDsn"`
}

// Input for setting access roles for a user
type SetAccessRolesInput struct {
	// Account level access of the user
	AccountRole AccountAccessRole `json:"accountRole"`
	// Environment level access of the user
	NonProductionRole EnvironmentAccessRole `json:"nonProductionRole"`
	// Environment level access of the user
	ProductionRole EnvironmentAccessRole `json:"productionRole"`
	// The id of the user associated with this member
	UserID string `json:"userId"`
}

type SetBasePlanOnPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetCompatibleAddonsOnPlanInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The ids of the relations.
	RelationIds []string `json:"relationIds"`
}

type SetCouponOnCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetExperimentOnCustomerInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

type SetExperimentOnCustomerSubscriptionInput struct {
	// The id of the record.
	ID string `json:"id"`
	// The id of relation.
	RelationID string `json:"relationId"`
}

// The input type for setting the addons of an package group
type SetPackageGroupAddons struct {
	// The addons to set on the package group
	Addons []string `json:"addons"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The id of the package group
	PackageGroupID string `json:"packageGroupId"`
}

// Set plan compatible package groups input
type SetPlanCompatiblePackageGroup struct {
	// The options for the package group
	Options *SetPlanCompatiblePackageGroupOptions `json:"options,omitempty"`
	// The package group id
	PackageGroupID string `json:"packageGroupId"`
}

// Set plan compatible package groups input
type SetPlanCompatiblePackageGroupOptions struct {
	// Number of free items from packageGroup
	FreeItems *float64 `json:"freeItems,omitempty"`
	// Number of required items from packageGroup
	MinItems *float64 `json:"minItems,omitempty"`
}

// Set plan compatible package groups input
type SetPlanCompatiblePackageGroups struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The id of the plan
	ID string `json:"id"`
	// The package groups with optional options
	PackageGroups []*SetPlanCompatiblePackageGroup `json:"packageGroups"`
}

// Snowflake integration configuration object
type SnowflakeCredentials struct {
	// Airbyte connection ID for Snowflake
	AirbyteConnectionID *string `json:"airbyteConnectionId"`
	// Airbyte destination ID for Snowflake
	AirbyteDestinationID *string `json:"airbyteDestinationId"`
	// The database you specified when creating the Stigg entities in Snowflake, for example: STIGG_DATABASE
	Database string `json:"database"`
	// The Snowflake account URL, for example: https://ab12345.us-east-2.aws.snowflakecomputing.com
	Host string `json:"host"`
	// The role you specified when creating the Stigg entities in Snowflake, for example: STIGG_ROLE
	Role string `json:"role"`
	// The schema you specified when creating the Stigg entities in Snowflake, for example: STIGG_SCHEMA
	SchemaName string `json:"schemaName"`
	// The username you specified when creating the Stigg entities in Snowflake, for example: STIGG_USER
	Username string `json:"username"`
	// The warehouse you specified when creating the Stigg entities in Snowflake, for example: STIGG_WAREHOUSE
	Warehouse string `json:"warehouse"`
}

func (SnowflakeCredentials) IsCredentials() {}

// Input configuration for Snowflake integration
type SnowflakeCredentialsInput struct {
	// The database you specified when creating the Stigg entities in Snowflake, for example: STIGG_DATABASE
	Database string `json:"database"`
	// The Snowflake account URL, for example: https://ab12345.us-east-2.aws.snowflakecomputing.com
	Host string `json:"host"`
	// The password you specified when creating the Stigg entities in Snowflake
	Password string `json:"password"`
	// The role you specified when creating the Stigg entities in Snowflake, for example: STIGG_ROLE
	Role string `json:"role"`
	// The schema you specified when creating the Stigg entities in Snowflake, for example: STIGG_SCHEMA
	SchemaName string `json:"schemaName"`
	// The username you specified when creating the Stigg entities in Snowflake, for example: STIGG_USER
	Username string `json:"username"`
	// The warehouse you specified when creating the Stigg entities in Snowflake, for example: STIGG_WAREHOUSE
	Warehouse string `json:"warehouse"`
}

// Input parameters for starting an experiment
type StartExperimentInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The unique identifier for the experiment
	RefID string `json:"refId"`
}

// Input parameters for stopping an experiment
type StopExperimentInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The unique identifier for the experiment
	RefID string `json:"refId"`
}

// String change
type StringChangeDto struct {
	// The value after the change
	After *string `json:"after"`
	// The value before the change
	Before *string `json:"before"`
	// The change type
	ChangeType *ChangeType `json:"changeType"`
}

type StringFieldComparison struct {
	Eq       *string  `json:"eq,omitempty"`
	Gt       *string  `json:"gt,omitempty"`
	Gte      *string  `json:"gte,omitempty"`
	ILike    *string  `json:"iLike,omitempty"`
	In       []string `json:"in,omitempty"`
	Is       *bool    `json:"is,omitempty"`
	IsNot    *bool    `json:"isNot,omitempty"`
	Like     *string  `json:"like,omitempty"`
	Lt       *string  `json:"lt,omitempty"`
	Lte      *string  `json:"lte,omitempty"`
	Neq      *string  `json:"neq,omitempty"`
	NotILike *string  `json:"notILike,omitempty"`
	NotIn    []string `json:"notIn,omitempty"`
	NotLike  *string  `json:"notLike,omitempty"`
}

// Stripe integration configuration object
type StripeCredentials struct {
	// Display name of the Stripe account
	AccountDisplayName string `json:"accountDisplayName"`
	// ID of the Stripe account
	AccountID string `json:"accountId"`
	// Whether tax is enabled for the Stripe account
	IsTaxEnabled bool `json:"isTaxEnabled"`
	// Whether the Stripe account is in test mode
	IsTestMode bool `json:"isTestMode"`
}

func (StripeCredentials) IsCredentials() {}

// Input configuration for Stripe integration
type StripeCredentialsInput struct {
	// ID of the Stripe account
	AccountID *string `json:"accountId,omitempty"`
	// Authorization code for Stripe
	AuthorizationCode string `json:"authorizationCode"`
	// Whether tax is enabled for the Stripe account
	IsTaxEnabled *bool `json:"isTaxEnabled,omitempty"`
	// Whether the Stripe account is in test mode
	IsTestMode bool `json:"isTestMode"`
}

// Stripe customer information
type StripeCustomer struct {
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// Customer email address
	Email string `json:"email"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Indicates if the customer is synced with Stigg
	IsSynced bool `json:"isSynced"`
	// Customer name
	Name string `json:"name"`
	// Name of the subscription plan
	SubscriptionPlanName *string `json:"subscriptionPlanName"`
	// Number of active subscriptions
	SubscriptionsCount float64 `json:"subscriptionsCount"`
}

type StripeCustomerIsDeleted struct {
	BillingID         string `json:"billingId"`
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
}

// Input parameters for searching Stripe customers
type StripeCustomerSearchInput struct {
	// Name of the customer to search for
	CustomerName *string `json:"customerName,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Token for retrieving the next page of results
	NextPage *string `json:"nextPage,omitempty"`
}

// Results from searching Stripe customers
type StripeCustomerSearchResult struct {
	// List of found Stripe customers
	Customers []*StripeCustomer `json:"customers"`
	// Token for the next page of results
	NextPage *string `json:"nextPage"`
	// Total number of customers found
	TotalCount int64 `json:"totalCount"`
}

// Response for preparing a Stripe payment method form
type StripePaymentMethodForm struct {
	// The client secret for the payment method form
	ClientSecret string `json:"clientSecret"`
	// The Stripe publishable key
	StripePublishableKey *string `json:"stripePublishableKey"`
}

func (StripePaymentMethodForm) IsPaymentMethodForm() {}

// Stripe product information
type StripeProduct struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Indicates if the product is synced with Stigg
	IsSynced bool `json:"isSynced"`
	// Product name
	Name string `json:"name"`
	// Indicates if the product cannot be imported
	NotSupportedForImport bool `json:"notSupportedForImport"`
	// List of prices associated with the product
	Prices []*StripeProductPrice `json:"prices"`
	// Timestamp of when the record was last updated
	UpdatedAt string `json:"updatedAt"`
}

// Price information for a Stripe product
type StripeProductPrice struct {
	// Price amount
	Amount float64 `json:"amount"`
	// Billing period for the price
	BillingPeriod *BillingPeriod `json:"billingPeriod"`
}

// Input parameters for searching Stripe products
type StripeProductSearchInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Token for retrieving the next page of results
	NextPage *string `json:"nextPage,omitempty"`
	// Name of the product to search for
	ProductName *string `json:"productName,omitempty"`
}

// Results from searching Stripe products
type StripeProductSearchResult struct {
	// Token for the next page of results
	NextPage *string `json:"nextPage"`
	// List of found Stripe products
	Products []*StripeProduct `json:"products"`
	// Total number of products found
	TotalCount int64 `json:"totalCount"`
	// Indicates if any usage-based products were found
	UsageBasedProductPresent *bool `json:"usageBasedProductPresent"`
}

// Stripe subscription information
type StripeSubscription struct {
	// Unique identifier for the entity
	ID string `json:"id"`
}

// Input parameters for searching Stripe subscriptions
type StripeSubscriptionSearchInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Token for retrieving the next page of results
	NextPage *string `json:"nextPage,omitempty"`
}

// Results from searching Stripe subscriptions
type StripeSubscriptionSearchResult struct {
	// Token for the next page of results
	NextPage *string `json:"nextPage"`
	// List of found Stripe subscriptions
	Subscriptions []*StripeSubscription `json:"subscriptions"`
	// Total number of subscriptions found
	TotalCount int64 `json:"totalCount"`
}

type SubscriptionAddon struct {
	// Addon object
	Addon Addon `json:"addon"`
	// The id of the addon
	AddonID      string               `json:"addonId"`
	CreatedAt    *string              `json:"createdAt"`
	ID           string               `json:"id"`
	Price        *Price               `json:"price"`
	Quantity     float64              `json:"quantity"`
	Subscription CustomerSubscription `json:"subscription"`
	UpdatedAt    string               `json:"updatedAt"`
}

type SubscriptionAddonAggregateGroupBy struct {
	CreatedAt *string  `json:"createdAt"`
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
}

type SubscriptionAddonAvgAggregate struct {
	Quantity *float64 `json:"quantity"`
}

type SubscriptionAddonCountAggregate struct {
	CreatedAt *int64 `json:"createdAt"`
	ID        *int64 `json:"id"`
	Quantity  *int64 `json:"quantity"`
	UpdatedAt *int64 `json:"updatedAt"`
}

type SubscriptionAddonEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionAddon
	Node SubscriptionAddon `json:"node"`
}

type SubscriptionAddonFilter struct {
	And          []*SubscriptionAddonFilter                         `json:"and,omitempty"`
	CreatedAt    *DateFieldComparison                               `json:"createdAt,omitempty"`
	ID           *UUIDFilterComparison                              `json:"id,omitempty"`
	Or           []*SubscriptionAddonFilter                         `json:"or,omitempty"`
	Price        *SubscriptionAddonFilterPriceFilter                `json:"price,omitempty"`
	Quantity     *NumberFieldComparison                             `json:"quantity,omitempty"`
	Subscription *SubscriptionAddonFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
	UpdatedAt    *DateFieldComparison                               `json:"updatedAt,omitempty"`
}

type SubscriptionAddonFilterCustomerSubscriptionFilter struct {
	And                       []*SubscriptionAddonFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingCycleAnchor        *DateFieldComparison                                 `json:"billingCycleAnchor,omitempty"`
	BillingID                 *StringFieldComparison                               `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison            `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                 `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                 `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                               `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                               `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                 `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                 `json:"currentBillingPeriodStart,omitempty"`
	CustomerID                *UUIDFilterComparison                                `json:"customerId,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                 `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                 `json:"endDate,omitempty"`
	EnvironmentID             *UUIDFilterComparison                                `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison                                `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                               `json:"oldBillingId,omitempty"`
	Or                        []*SubscriptionAddonFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PayingCustomerID          *UUIDFilterComparison                                `json:"payingCustomerId,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                   `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                         `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                               `json:"refId,omitempty"`
	ResourceID                *UUIDFilterComparison                                `json:"resourceId,omitempty"`
	SalesforceID              *StringFieldComparison                               `json:"salesforceId,omitempty"`
	StartDate                 *DateFieldComparison                                 `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                  `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                               `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                 `json:"trialEndDate,omitempty"`
}

type SubscriptionAddonFilterPriceFilter struct {
	And            []*SubscriptionAddonFilterPriceFilter `json:"and,omitempty"`
	BillingCadence *BillingCadenceFilterComparison       `json:"billingCadence,omitempty"`
	BillingID      *StringFieldComparison                `json:"billingId,omitempty"`
	BillingModel   *BillingModelFilterComparison         `json:"billingModel,omitempty"`
	BillingPeriod  *BillingPeriodFilterComparison        `json:"billingPeriod,omitempty"`
	CreatedAt      *DateFieldComparison                  `json:"createdAt,omitempty"`
	ID             *UUIDFilterComparison                 `json:"id,omitempty"`
	Or             []*SubscriptionAddonFilterPriceFilter `json:"or,omitempty"`
	TiersMode      *TiersModeFilterComparison            `json:"tiersMode,omitempty"`
}

type SubscriptionAddonInput struct {
	AddonID  string `json:"addonId"`
	Quantity *int64 `json:"quantity,omitempty"`
}

type SubscriptionAddonMaxAggregate struct {
	CreatedAt *string  `json:"createdAt"`
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
}

type SubscriptionAddonMinAggregate struct {
	CreatedAt *string  `json:"createdAt"`
	ID        *string  `json:"id"`
	Quantity  *float64 `json:"quantity"`
	UpdatedAt *string  `json:"updatedAt"`
}

type SubscriptionAddonSort struct {
	Direction SortDirection               `json:"direction"`
	Field     SubscriptionAddonSortFields `json:"field"`
	Nulls     *SortNulls                  `json:"nulls,omitempty"`
}

type SubscriptionAddonSumAggregate struct {
	Quantity *float64 `json:"quantity"`
}

type SubscriptionAlreadyCanceledOrExpired struct {
	Code              string             `json:"code"`
	IsValidationError bool               `json:"isValidationError"`
	RefID             string             `json:"refId"`
	Status            SubscriptionStatus `json:"status"`
}

type SubscriptionBillingInfo struct {
	BillingAddress          *BillingAddress `json:"billingAddress,omitempty"`
	ChargeOnBehalfOfAccount *string         `json:"chargeOnBehalfOfAccount,omitempty"`
	CouponID                *string         `json:"couponId,omitempty"`
	// The billing integration to use for this subscription
	IntegrationID       *string                `json:"integrationId,omitempty"`
	InvoiceDaysUntilDue *float64               `json:"invoiceDaysUntilDue,omitempty"`
	IsBackdated         *bool                  `json:"isBackdated,omitempty"`
	IsInvoicePaid       *bool                  `json:"isInvoicePaid,omitempty"`
	Metadata            map[string]interface{} `json:"metadata,omitempty"`
	TaxPercentage       *float64               `json:"taxPercentage,omitempty"`
	TaxRateIds          []string               `json:"taxRateIds,omitempty"`
}

type SubscriptionCancelReasonFilterComparison struct {
	Eq       *SubscriptionCancelReason  `json:"eq,omitempty"`
	Gt       *SubscriptionCancelReason  `json:"gt,omitempty"`
	Gte      *SubscriptionCancelReason  `json:"gte,omitempty"`
	ILike    *SubscriptionCancelReason  `json:"iLike,omitempty"`
	In       []SubscriptionCancelReason `json:"in,omitempty"`
	Is       *bool                      `json:"is,omitempty"`
	IsNot    *bool                      `json:"isNot,omitempty"`
	Like     *SubscriptionCancelReason  `json:"like,omitempty"`
	Lt       *SubscriptionCancelReason  `json:"lt,omitempty"`
	Lte      *SubscriptionCancelReason  `json:"lte,omitempty"`
	Neq      *SubscriptionCancelReason  `json:"neq,omitempty"`
	NotILike *SubscriptionCancelReason  `json:"notILike,omitempty"`
	NotIn    []SubscriptionCancelReason `json:"notIn,omitempty"`
	NotLike  *SubscriptionCancelReason  `json:"notLike,omitempty"`
}

type SubscriptionCancellationInput struct {
	EndDate       *string `json:"endDate,omitempty"`
	EnvironmentID *string `json:"environmentId,omitempty"`
	// If set, enables or disables prorating of credits on subscription cancellation.
	Prorate                        *bool                           `json:"prorate,omitempty"`
	SubscriptionCancellationAction *SubscriptionCancellationAction `json:"subscriptionCancellationAction,omitempty"`
	SubscriptionCancellationTime   *SubscriptionCancellationTime   `json:"subscriptionCancellationTime,omitempty"`
	SubscriptionRefID              string                          `json:"subscriptionRefId"`
}

// Subscription coupons
type SubscriptionCoupon struct {
	// Fixed amount discounts in different currencies
	AmountsOff []*Money `json:"amountsOff"`
	// Discount value of the coupon (deprecated)
	DiscountValue float64 `json:"discountValue"`
	// Duration of the coupon validity in months
	DurationInMonths *float64 `json:"durationInMonths"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The expiration date of this coupon
	ExpirationDate *string `json:"expirationDate"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Name of the coupon
	Name string `json:"name"`
	// Percentage discount off the original price
	PercentOff *float64 `json:"percentOff"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// The start date of this coupon
	StartDate *string `json:"startDate"`
	// Current status of the coupon
	Status SubscriptionCouponStatus `json:"status"`
	// Type of the coupon (percentage or fixed amount)
	Type CouponType `json:"type"`
}

// Subscription coupon configuration input
type SubscriptionCouponConfigurationInput struct {
	// The date to start the coupon from
	StartDate *string `json:"startDate,omitempty"`
}

// Inline subscription coupon input
type SubscriptionCouponDiscountInput struct {
	// Discount flat fee amounts off
	AmountsOff []*MoneyInputDto `json:"amountsOff,omitempty"`
	// Description of the coupon that will be created
	Description *string `json:"description,omitempty"`
	// The duration in months for which the coupon remains active.
	DurationInMonths *float64 `json:"durationInMonths,omitempty"`
	// Name of the coupon that will be created
	Name *string `json:"name,omitempty"`
	// Discount percent off
	PercentOff *float64 `json:"percentOff,omitempty"`
}

// Subscription coupon input
type SubscriptionCouponInput struct {
	// Billing integration coupon id
	BillingCouponID *string `json:"billingCouponId,omitempty"`
	// Coupon configuration input
	Configuration *SubscriptionCouponConfigurationInput `json:"configuration,omitempty"`
	// Stigg coupon id
	CouponID *string `json:"couponId,omitempty"`
	// An inline discount
	Discount *SubscriptionCouponDiscountInput `json:"discount,omitempty"`
	// Promotion code
	PromotionCode *string `json:"promotionCode,omitempty"`
}

// Subscription entitlement
type SubscriptionEntitlement struct {
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// Subscription entitlement
	Description *string `json:"description"`
	// The unique identifier for the environment
	EnvironmentID string  `json:"environmentId"`
	Feature       Feature `json:"feature"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool  `json:"hasUnlimitedUsage"`
	ID                string `json:"id"`
	Meter             *Meter `json:"meter"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod"`
	// The reset period configuration of the entitlement
	ResetPeriodConfiguration ResetPeriodConfiguration `json:"resetPeriodConfiguration"`
	Subscription             CustomerSubscription     `json:"subscription"`
	// The unique identifier of the entitlement subscription
	SubscriptionID string `json:"subscriptionId"`
	// Timestamp of when the record was last updated
	UpdatedAt *string `json:"updatedAt"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionEntitlementAggregateGroupBy struct {
	CreatedAt      *string `json:"createdAt"`
	EnvironmentID  *string `json:"environmentId"`
	ID             *string `json:"id"`
	SubscriptionID *string `json:"subscriptionId"`
	UpdatedAt      *string `json:"updatedAt"`
}

type SubscriptionEntitlementConnection struct {
	// Array of edges.
	Edges []*SubscriptionEntitlementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type SubscriptionEntitlementCountAggregate struct {
	CreatedAt      *int64 `json:"createdAt"`
	EnvironmentID  *int64 `json:"environmentId"`
	ID             *int64 `json:"id"`
	SubscriptionID *int64 `json:"subscriptionId"`
	UpdatedAt      *int64 `json:"updatedAt"`
}

type SubscriptionEntitlementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionEntitlement
	Node SubscriptionEntitlement `json:"node"`
}

type SubscriptionEntitlementFilter struct {
	And            []*SubscriptionEntitlementFilter                         `json:"and,omitempty"`
	CreatedAt      *DateFieldComparison                                     `json:"createdAt,omitempty"`
	EnvironmentID  *UUIDFilterComparison                                    `json:"environmentId,omitempty"`
	Feature        *SubscriptionEntitlementFilterFeatureFilter              `json:"feature,omitempty"`
	ID             *UUIDFilterComparison                                    `json:"id,omitempty"`
	Or             []*SubscriptionEntitlementFilter                         `json:"or,omitempty"`
	Subscription   *SubscriptionEntitlementFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
	SubscriptionID *StringFieldComparison                                   `json:"subscriptionId,omitempty"`
	UpdatedAt      *DateFieldComparison                                     `json:"updatedAt,omitempty"`
}

type SubscriptionEntitlementFilterCustomerSubscriptionFilter struct {
	And                       []*SubscriptionEntitlementFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingCycleAnchor        *DateFieldComparison                                       `json:"billingCycleAnchor,omitempty"`
	BillingID                 *StringFieldComparison                                     `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison                  `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                       `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                       `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                                     `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                                     `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                       `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                       `json:"currentBillingPeriodStart,omitempty"`
	CustomerID                *UUIDFilterComparison                                      `json:"customerId,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                       `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                       `json:"endDate,omitempty"`
	EnvironmentID             *UUIDFilterComparison                                      `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison                                      `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                                     `json:"oldBillingId,omitempty"`
	Or                        []*SubscriptionEntitlementFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PayingCustomerID          *UUIDFilterComparison                                      `json:"payingCustomerId,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                         `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                               `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                                     `json:"refId,omitempty"`
	ResourceID                *UUIDFilterComparison                                      `json:"resourceId,omitempty"`
	SalesforceID              *StringFieldComparison                                     `json:"salesforceId,omitempty"`
	StartDate                 *DateFieldComparison                                       `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                        `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                                     `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                       `json:"trialEndDate,omitempty"`
}

type SubscriptionEntitlementFilterFeatureFilter struct {
	And           []*SubscriptionEntitlementFilterFeatureFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                          `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                        `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                        `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison                         `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison                `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison                  `json:"featureType,omitempty"`
	ID            *UUIDFilterComparison                         `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison                    `json:"meterType,omitempty"`
	Or            []*SubscriptionEntitlementFilterFeatureFilter `json:"or,omitempty"`
	RefID         *StringFieldComparison                        `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison                          `json:"updatedAt,omitempty"`
}

// Subscription entitlement input
type SubscriptionEntitlementInput struct {
	// The description of the entitlement
	Description *string `json:"description,omitempty"`
	// The unique identifier of the entitlement feature
	FeatureID string `json:"featureId"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the entitlement, defined when reset period is yearly
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type SubscriptionEntitlementMaxAggregate struct {
	CreatedAt      *string `json:"createdAt"`
	EnvironmentID  *string `json:"environmentId"`
	ID             *string `json:"id"`
	SubscriptionID *string `json:"subscriptionId"`
	UpdatedAt      *string `json:"updatedAt"`
}

type SubscriptionEntitlementMinAggregate struct {
	CreatedAt      *string `json:"createdAt"`
	EnvironmentID  *string `json:"environmentId"`
	ID             *string `json:"id"`
	SubscriptionID *string `json:"subscriptionId"`
	UpdatedAt      *string `json:"updatedAt"`
}

type SubscriptionEntitlementSort struct {
	Direction SortDirection                     `json:"direction"`
	Field     SubscriptionEntitlementSortFields `json:"field"`
	Nulls     *SortNulls                        `json:"nulls,omitempty"`
}

type SubscriptionFutureUpdate struct {
	BillingID      *string                    `json:"billingId"`
	CreatedAt      *string                    `json:"createdAt"`
	ScheduleStatus SubscriptionScheduleStatus `json:"scheduleStatus"`
	// The schedule variables by the type of the schedule
	ScheduleVariables        ScheduleVariables        `json:"scheduleVariables"`
	ScheduledExecutionTime   string                   `json:"scheduledExecutionTime"`
	SubscriptionScheduleType SubscriptionScheduleType `json:"subscriptionScheduleType"`
	TargetPackage            *PackageDto              `json:"targetPackage"`
}

type SubscriptionInput struct {
	AdditionalMetaData map[string]interface{}    `json:"additionalMetaData,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon            *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	AwaitPaymentConfirmation *bool                    `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures         []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingCountryCode       *string                  `json:"billingCountryCode,omitempty"`
	BillingID                *string                  `json:"billingId,omitempty"`
	BillingInformation       *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod            *BillingPeriod           `json:"billingPeriod,omitempty"`
	// Budget configuration
	Budget                    *BudgetConfigurationInput `json:"budget,omitempty"`
	CrmID                     *string                   `json:"crmId,omitempty"`
	CustomerID                string                    `json:"customerId"`
	EndDate                   *string                   `json:"endDate,omitempty"`
	EnvironmentID             *string                   `json:"environmentId,omitempty"`
	IsCustomPriceSubscription *bool                     `json:"isCustomPriceSubscription,omitempty"`
	IsOverridingTrialConfig   *bool                     `json:"isOverridingTrialConfig,omitempty"`
	IsTrial                   *bool                     `json:"isTrial,omitempty"`
	// The minimum spend configuration
	MinimumSpend     *SubscriptionMinimumSpendValueInput `json:"minimumSpend,omitempty"`
	PayingCustomerID *string                             `json:"payingCustomerId,omitempty"`
	// Subscription payment collection method
	PaymentCollectionMethod *PaymentCollectionMethod `json:"paymentCollectionMethod,omitempty"`
	PlanID                  string                   `json:"planId"`
	// Override the price of the subscription
	PriceOverrides           []*PriceOverrideInput           `json:"priceOverrides,omitempty"`
	PriceUnitAmount          *float64                        `json:"priceUnitAmount,omitempty"`
	PromotionCode            *string                         `json:"promotionCode,omitempty"`
	RefID                    *string                         `json:"refId,omitempty"`
	ResourceID               *string                         `json:"resourceId,omitempty"`
	SalesforceID             *string                         `json:"salesforceId,omitempty"`
	ScheduleStrategy         *ScheduleStrategy               `json:"scheduleStrategy,omitempty"`
	StartDate                *string                         `json:"startDate,omitempty"`
	SubscriptionEntitlements []*SubscriptionEntitlementInput `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID           *string                         `json:"subscriptionId,omitempty"`
	// Indicates the behavior of the subscription when the trial is expired.
	TrialEndBehavior *TrialEndBehavior `json:"trialEndBehavior,omitempty"`
	UnitQuantity     *float64          `json:"unitQuantity,omitempty"`
}

type SubscriptionInvoice struct {
	AmountDue      *float64 `json:"amountDue"`
	AppliedBalance *float64 `json:"appliedBalance"`
	// Number of payment attempts made for this invoice, from the perspective of the payment retry schedule.
	AttemptCount         *float64                          `json:"attemptCount"`
	BillingID            string                            `json:"billingId"`
	BillingReason        *SubscriptionInvoiceBillingReason `json:"billingReason"`
	CreatedAt            string                            `json:"createdAt"`
	Currency             *string                           `json:"currency"`
	EndingBalance        *float64                          `json:"endingBalance"`
	ErrorMessage         *string                           `json:"errorMessage"`
	Lines                []*InvoiceLine                    `json:"lines"`
	PaymentSecret        *string                           `json:"paymentSecret"`
	PaymentURL           *string                           `json:"paymentUrl"`
	PDFURL               *string                           `json:"pdfUrl"`
	RequiresAction       bool                              `json:"requiresAction"`
	StartingBalance      *float64                          `json:"startingBalance"`
	Status               SubscriptionInvoiceStatus         `json:"status"`
	SubTotal             *float64                          `json:"subTotal"`
	SubTotalExcludingTax *float64                          `json:"subTotalExcludingTax"`
	Tax                  *float64                          `json:"tax"`
	Total                *float64                          `json:"total"`
	TotalExcludingTax    *float64                          `json:"totalExcludingTax"`
	UpdatedAt            string                            `json:"updatedAt"`
}

// The preview of the next upcoming invoice for the given subscription
type SubscriptionInvoicePreview struct {
	// The amount due for the invoice after taxes, discounts and credits
	AmountDue Money `json:"amountDue"`
	// Credits information (initial, used, remaining)
	Credits *SubscriptionPreviewCredits `json:"credits"`
	// The total discount amount of the invoice
	Discount *Money `json:"discount"`
	// The applied discount details
	DiscountDetails *SubscriptionPreviewDiscount `json:"discountDetails"`
	// The date when the invoice was last updated
	LastUpdatedAt string `json:"lastUpdatedAt"`
	// The line items of the invoice
	Lines []*SubscriptionInvoicePreviewLineItem `json:"lines"`
	// The minimum spend adjustment applied to the invoice
	MinimumSpendAdjustment Money `json:"minimumSpendAdjustment"`
	// The sub total amount of the invoice excluding  discounts
	SubTotal Money `json:"subTotal"`
	// The sub total amount of the invoice excluding taxes and discounts
	SubTotalExcludingTax Money `json:"subTotalExcludingTax"`
	// The total tax amount of the invoice
	Tax *Money `json:"tax"`
	// The applied tax details
	TaxDetails *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	// The total amount of the invoice including taxes and discounts
	Total Money `json:"total"`
	// The total amount of the invoice excluding taxes
	TotalExcludingTax Money `json:"totalExcludingTax"`
}

// The invoice line item
type SubscriptionInvoicePreviewLineItem struct {
	// The total amount of the invoice line item
	Amount Money `json:"amount"`
	// The cost description of the invoice line item
	CostDescription string `json:"costDescription"`
	// The description of the invoice line item
	Description string `json:"description"`
	// Whether the price connected to the invoice line item has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit"`
	// The nested line items of the invoice line item
	Lines  []*SubscriptionInvoicePreviewLineItemData `json:"lines"`
	Period SubscriptionInvoicePreviewLineItemPeriod  `json:"period"`
	// The price connected to the invoice line item
	Price *Price `json:"price"`
	// Whether the line item is prorated
	Proration bool `json:"proration"`
	// The quantity of the invoice line item
	Quantity *int64 `json:"quantity"`
	// The charge type of the invoice line item
	Type InvoiceLineItemType `json:"type"`
	// The unit price of the invoice line item
	UnitPrice *Money `json:"unitPrice"`
	// The usage limit of the invoice line item
	UsageLimit *float64 `json:"usageLimit"`
}

// The invoice line item
type SubscriptionInvoicePreviewLineItemData struct {
	// The total amount of the invoice line item
	Amount Money `json:"amount"`
	// The cost description of the invoice line item
	CostDescription string `json:"costDescription"`
	// The description of the invoice line item
	Description string `json:"description"`
	// Whether the price connected to the invoice line item has a soft limit
	HasSoftLimit *bool                                    `json:"hasSoftLimit"`
	Period       SubscriptionInvoicePreviewLineItemPeriod `json:"period"`
	// The price connected to the invoice line item
	Price *Price `json:"price"`
	// Whether the line item is prorated
	Proration bool `json:"proration"`
	// The quantity of the invoice line item
	Quantity *int64 `json:"quantity"`
	// The charge type of the invoice line item
	Type InvoiceLineItemType `json:"type"`
	// The unit price of the invoice line item
	UnitPrice *Money `json:"unitPrice"`
	// The usage limit of the invoice line item
	UsageLimit *float64 `json:"usageLimit"`
}

// The invoice line item period
type SubscriptionInvoicePreviewLineItemPeriod struct {
	End   string `json:"end"`
	Start string `json:"start"`
}

type SubscriptionMaximumSpend struct {
	Discount        *Money                                `json:"discount"`
	DiscountDetails *SubscriptionMaximumSpendDiscount     `json:"discountDetails"`
	LastUpdatedAt   string                                `json:"lastUpdatedAt"`
	Lines           []*SubscriptionInvoicePreviewLineItem `json:"lines"`
	// The maximum spending limit set
	MaximumSpend Money `json:"maximumSpend"`
	SubTotal     Money `json:"subTotal"`
	Total        Money `json:"total"`
}

type SubscriptionMaximumSpendDiscount struct {
	// Coupon duration in month
	DurationInMonths *float64 `json:"durationInMonths"`
	// Coupon duration type
	DurationType *DiscountDurationType `json:"durationType"`
	// Coupon name
	Name *string `json:"name"`
	// Coupon start date
	Start *string `json:"start"`
	// Discount type
	Type *DiscountType `json:"type"`
	// Coupon value
	Value *float64 `json:"value"`
}

type SubscriptionMigrationInput struct {
	EnvironmentID             *string                    `json:"environmentId,omitempty"`
	SubscriptionID            string                     `json:"subscriptionId"`
	SubscriptionMigrationTime *SubscriptionMigrationTime `json:"subscriptionMigrationTime,omitempty"`
}

// Subscription migration task
type SubscriptionMigrationTask struct {
	// The number of customers that are affected by the subscription migration task
	AffectedCustomersCount *int64 `json:"affectedCustomersCount"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt"`
	// The end date of the task
	EndDate *string `json:"endDate"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The id of the package that was initiated
	InitiatedPackageID *string `json:"initiatedPackageId"`
	// The number of customers that have been migrated
	MigratedCustomersCount *int64        `json:"migratedCustomersCount"`
	Packages               []*PackageDto `json:"packages"`
	// The progress of the task as a percentage, a number between 0 and 100
	Progress int64 `json:"progress"`
	// The start date of the task
	StartDate *string `json:"startDate"`
	// The status of the task
	Status TaskStatus `json:"status"`
	// The type of the task
	TaskType TaskType `json:"taskType"`
}

type SubscriptionMigrationTaskAggregateGroupBy struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type SubscriptionMigrationTaskConnection struct {
	// Array of edges.
	Edges []*SubscriptionMigrationTaskEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
}

type SubscriptionMigrationTaskCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
	Status        *int64 `json:"status"`
	TaskType      *int64 `json:"taskType"`
}

type SubscriptionMigrationTaskEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionMigrationTask
	Node SubscriptionMigrationTask `json:"node"`
}

type SubscriptionMigrationTaskFilter struct {
	And           []*SubscriptionMigrationTaskFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison               `json:"createdAt,omitempty"`
	EnvironmentID *StringFieldComparison             `json:"environmentId,omitempty"`
	ID            *UUIDFilterComparison              `json:"id,omitempty"`
	Or            []*SubscriptionMigrationTaskFilter `json:"or,omitempty"`
	Status        *TaskStatusFilterComparison        `json:"status,omitempty"`
	TaskType      *TaskTypeFilterComparison          `json:"taskType,omitempty"`
}

type SubscriptionMigrationTaskMaxAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type SubscriptionMigrationTaskMinAggregate struct {
	CreatedAt     *string     `json:"createdAt"`
	EnvironmentID *string     `json:"environmentId"`
	ID            *string     `json:"id"`
	Status        *TaskStatus `json:"status"`
	TaskType      *TaskType   `json:"taskType"`
}

type SubscriptionMigrationTaskSort struct {
	Direction SortDirection                       `json:"direction"`
	Field     SubscriptionMigrationTaskSortFields `json:"field"`
	Nulls     *SortNulls                          `json:"nulls,omitempty"`
}

// Subscription minimum spend
type SubscriptionMinimumSpend struct {
	// Is the minimum spend an override on the subscription level
	IsOverride *bool `json:"isOverride"`
	// The minimum spend limit
	Minimum *Money `json:"minimum"`
}

// Subscription minimum spend input
type SubscriptionMinimumSpendValueInput struct {
	// The subscription minimum spend
	Minimum *MoneyInputDto `json:"minimum,omitempty"`
}

type SubscriptionMustHaveSinglePlanError struct {
	Code              string   `json:"code"`
	IsValidationError bool     `json:"isValidationError"`
	RefIds            []string `json:"refIds"`
}

type SubscriptionNoBillingID struct {
	Code              string `json:"code"`
	IsValidationError bool   `json:"isValidationError"`
	RefID             string `json:"refId"`
}

type SubscriptionPreview struct {
	BillingPeriodRange  DateRange                    `json:"billingPeriodRange"`
	Credits             *SubscriptionPreviewCredits  `json:"credits"`
	Discount            *SubscriptionPreviewDiscount `json:"discount"`
	DiscountAmount      *Money                       `json:"discountAmount"`
	HasScheduledUpdates *bool                        `json:"hasScheduledUpdates"`
	IsPlanDowngrade     *bool                        `json:"isPlanDowngrade"`
	// The minimum spend adjustment applied to the invoice
	MinimumSpendAdjustment Money                          `json:"minimumSpendAdjustment"`
	Proration              *SubscriptionPreviewProrations `json:"proration"`
	SubTotal               Money                          `json:"subTotal"`
	Subscription           *SubscriptionPricePreviewDto   `json:"subscription"`
	Tax                    *Money                         `json:"tax"`
	TaxDetails             *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total                  Money                          `json:"total"`
	TotalExcludingTax      Money                          `json:"totalExcludingTax"`
}

type SubscriptionPreviewCredits struct {
	Initial   Money `json:"initial"`
	Remaining Money `json:"remaining"`
	Used      Money `json:"used"`
}

type SubscriptionPreviewDiscount struct {
	// Coupon duration in month
	DurationInMonths *float64 `json:"durationInMonths"`
	// Coupon duration type
	DurationType DiscountDurationType `json:"durationType"`
	// Coupon end date
	End *string `json:"end"`
	// Coupon name
	Name *string `json:"name"`
	// Coupon start date
	Start string `json:"start"`
	// Discount type
	Type DiscountType `json:"type"`
	// Coupon value
	Value float64 `json:"value"`
}

type SubscriptionPreviewInvoice struct {
	Discount        *Money                       `json:"discount"`
	DiscountDetails *SubscriptionPreviewDiscount `json:"discountDetails"`
	// The minimum spend adjustment applied to the invoice
	MinimumSpendAdjustment Money                          `json:"minimumSpendAdjustment"`
	SubTotal               Money                          `json:"subTotal"`
	Tax                    *Money                         `json:"tax"`
	TaxDetails             *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total                  Money                          `json:"total"`
	TotalExcludingTax      Money                          `json:"totalExcludingTax"`
}

type SubscriptionPreviewProrations struct {
	Credit        Money  `json:"credit"`
	Debit         Money  `json:"debit"`
	HasProrations *bool  `json:"hasProrations"`
	NetAmount     Money  `json:"netAmount"`
	ProrationDate string `json:"prorationDate"`
}

type SubscriptionPreviewTaxDetails struct {
	DisplayName string  `json:"displayName"`
	Inclusive   bool    `json:"inclusive"`
	Percentage  float64 `json:"percentage"`
}

type SubscriptionPreviewV2 struct {
	BillingPeriodRange DateRange `json:"billingPeriodRange"`
	// Free items of the subscription
	FreeItems           []*FreeSubscriptionItem             `json:"freeItems"`
	HasScheduledUpdates *bool                               `json:"hasScheduledUpdates"`
	ImmediateInvoice    ImmediateSubscriptionPreviewInvoice `json:"immediateInvoice"`
	IsPlanDowngrade     *bool                               `json:"isPlanDowngrade"`
	RecurringInvoice    *SubscriptionPreviewInvoice         `json:"recurringInvoice"`
}

type SubscriptionPrice struct {
	BillingModel *BillingModel        `json:"billingModel"`
	CreatedAt    *string              `json:"createdAt"`
	FeatureID    *string              `json:"featureId"`
	HasSoftLimit *bool                `json:"hasSoftLimit"`
	ID           string               `json:"id"`
	Price        *Price               `json:"price"`
	Subscription CustomerSubscription `json:"subscription"`
	UpdatedAt    string               `json:"updatedAt"`
	UsageLimit   *float64             `json:"usageLimit"`
}

type SubscriptionPriceAggregateGroupBy struct {
	BillingModel *BillingModel `json:"billingModel"`
	CreatedAt    *string       `json:"createdAt"`
	FeatureID    *string       `json:"featureId"`
	HasSoftLimit *bool         `json:"hasSoftLimit"`
	ID           *string       `json:"id"`
	UpdatedAt    *string       `json:"updatedAt"`
	UsageLimit   *float64      `json:"usageLimit"`
}

type SubscriptionPriceAvgAggregate struct {
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPriceCountAggregate struct {
	BillingModel *int64 `json:"billingModel"`
	CreatedAt    *int64 `json:"createdAt"`
	FeatureID    *int64 `json:"featureId"`
	HasSoftLimit *int64 `json:"hasSoftLimit"`
	ID           *int64 `json:"id"`
	UpdatedAt    *int64 `json:"updatedAt"`
	UsageLimit   *int64 `json:"usageLimit"`
}

type SubscriptionPriceEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionPrice
	Node SubscriptionPrice `json:"node"`
}

type SubscriptionPriceFilter struct {
	And          []*SubscriptionPriceFilter                         `json:"and,omitempty"`
	BillingModel *BillingModelFilterComparison                      `json:"billingModel,omitempty"`
	CreatedAt    *DateFieldComparison                               `json:"createdAt,omitempty"`
	FeatureID    *StringFieldComparison                             `json:"featureId,omitempty"`
	HasSoftLimit *BooleanFieldComparison                            `json:"hasSoftLimit,omitempty"`
	ID           *UUIDFilterComparison                              `json:"id,omitempty"`
	Or           []*SubscriptionPriceFilter                         `json:"or,omitempty"`
	Price        *SubscriptionPriceFilterPriceFilter                `json:"price,omitempty"`
	Subscription *SubscriptionPriceFilterCustomerSubscriptionFilter `json:"subscription,omitempty"`
	UpdatedAt    *DateFieldComparison                               `json:"updatedAt,omitempty"`
	UsageLimit   *NumberFieldComparison                             `json:"usageLimit,omitempty"`
}

type SubscriptionPriceFilterCustomerSubscriptionFilter struct {
	And                       []*SubscriptionPriceFilterCustomerSubscriptionFilter `json:"and,omitempty"`
	BillingCycleAnchor        *DateFieldComparison                                 `json:"billingCycleAnchor,omitempty"`
	BillingID                 *StringFieldComparison                               `json:"billingId,omitempty"`
	CancelReason              *SubscriptionCancelReasonFilterComparison            `json:"cancelReason,omitempty"`
	CancellationDate          *DateFieldComparison                                 `json:"cancellationDate,omitempty"`
	CreatedAt                 *DateFieldComparison                                 `json:"createdAt,omitempty"`
	CrmID                     *StringFieldComparison                               `json:"crmId,omitempty"`
	CrmLinkURL                *StringFieldComparison                               `json:"crmLinkUrl,omitempty"`
	CurrentBillingPeriodEnd   *DateFieldComparison                                 `json:"currentBillingPeriodEnd,omitempty"`
	CurrentBillingPeriodStart *DateFieldComparison                                 `json:"currentBillingPeriodStart,omitempty"`
	CustomerID                *UUIDFilterComparison                                `json:"customerId,omitempty"`
	EffectiveEndDate          *DateFieldComparison                                 `json:"effectiveEndDate,omitempty"`
	EndDate                   *DateFieldComparison                                 `json:"endDate,omitempty"`
	EnvironmentID             *UUIDFilterComparison                                `json:"environmentId,omitempty"`
	ID                        *UUIDFilterComparison                                `json:"id,omitempty"`
	OldBillingID              *StringFieldComparison                               `json:"oldBillingId,omitempty"`
	Or                        []*SubscriptionPriceFilterCustomerSubscriptionFilter `json:"or,omitempty"`
	PayingCustomerID          *UUIDFilterComparison                                `json:"payingCustomerId,omitempty"`
	PaymentCollection         *PaymentCollectionFilterComparison                   `json:"paymentCollection,omitempty"`
	PricingType               *PricingTypeFilterComparison                         `json:"pricingType,omitempty"`
	RefID                     *StringFieldComparison                               `json:"refId,omitempty"`
	ResourceID                *UUIDFilterComparison                                `json:"resourceId,omitempty"`
	SalesforceID              *StringFieldComparison                               `json:"salesforceId,omitempty"`
	StartDate                 *DateFieldComparison                                 `json:"startDate,omitempty"`
	Status                    *SubscriptionStatusFilterComparison                  `json:"status,omitempty"`
	SubscriptionID            *StringFieldComparison                               `json:"subscriptionId,omitempty"`
	TrialEndDate              *DateFieldComparison                                 `json:"trialEndDate,omitempty"`
}

type SubscriptionPriceFilterPriceFilter struct {
	And            []*SubscriptionPriceFilterPriceFilter `json:"and,omitempty"`
	BillingCadence *BillingCadenceFilterComparison       `json:"billingCadence,omitempty"`
	BillingID      *StringFieldComparison                `json:"billingId,omitempty"`
	BillingModel   *BillingModelFilterComparison         `json:"billingModel,omitempty"`
	BillingPeriod  *BillingPeriodFilterComparison        `json:"billingPeriod,omitempty"`
	CreatedAt      *DateFieldComparison                  `json:"createdAt,omitempty"`
	ID             *UUIDFilterComparison                 `json:"id,omitempty"`
	Or             []*SubscriptionPriceFilterPriceFilter `json:"or,omitempty"`
	TiersMode      *TiersModeFilterComparison            `json:"tiersMode,omitempty"`
}

type SubscriptionPriceMaxAggregate struct {
	BillingModel *BillingModel `json:"billingModel"`
	CreatedAt    *string       `json:"createdAt"`
	FeatureID    *string       `json:"featureId"`
	ID           *string       `json:"id"`
	UpdatedAt    *string       `json:"updatedAt"`
	UsageLimit   *float64      `json:"usageLimit"`
}

type SubscriptionPriceMinAggregate struct {
	BillingModel *BillingModel `json:"billingModel"`
	CreatedAt    *string       `json:"createdAt"`
	FeatureID    *string       `json:"featureId"`
	ID           *string       `json:"id"`
	UpdatedAt    *string       `json:"updatedAt"`
	UsageLimit   *float64      `json:"usageLimit"`
}

type SubscriptionPricePreviewDto struct {
	Discount          *SubscriptionPreviewDiscount   `json:"discount"`
	DiscountAmount    *Money                         `json:"discountAmount"`
	SubTotal          Money                          `json:"subTotal"`
	Tax               Money                          `json:"tax"`
	TaxDetails        *SubscriptionPreviewTaxDetails `json:"taxDetails"`
	Total             Money                          `json:"total"`
	TotalExcludingTax Money                          `json:"totalExcludingTax"`
}

type SubscriptionPriceSort struct {
	Direction SortDirection               `json:"direction"`
	Field     SubscriptionPriceSortFields `json:"field"`
	Nulls     *SortNulls                  `json:"nulls,omitempty"`
}

type SubscriptionPriceSumAggregate struct {
	UsageLimit *float64 `json:"usageLimit"`
}

type SubscriptionPricingTypeStatistics struct {
	PricingType PricingType `json:"pricingType"`
	TotalCount  float64     `json:"totalCount"`
}

// Query for subscriptions
type SubscriptionQuery struct {
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData"`
	Addons             []*SubscriptionAddon   `json:"addons"`
	// Billing cycle anchor date
	BillingCycleAnchor *string `json:"billingCycleAnchor"`
	BillingID          *string `json:"billingId"`
	BillingLinkURL     *string `json:"billingLinkUrl"`
	BillingSyncError   *string `json:"billingSyncError"`
	// Budget configuration
	Budget *BudgetConfiguration `json:"budget"`
	// Indicates if the budget has been exceeded
	BudgetExceeded   *bool                     `json:"budgetExceeded"`
	CancelReason     *SubscriptionCancelReason `json:"cancelReason"`
	CancellationDate *string                   `json:"cancellationDate"`
	Coupon           *SubscriptionCoupon       `json:"coupon"`
	Coupons          []*SubscriptionCoupon     `json:"coupons"`
	// Created at
	CreatedAt                 *string  `json:"createdAt"`
	CrmID                     *string  `json:"crmId"`
	CrmLinkURL                *string  `json:"crmLinkUrl"`
	CurrentBillingPeriodEnd   *string  `json:"currentBillingPeriodEnd"`
	CurrentBillingPeriodStart *string  `json:"currentBillingPeriodStart"`
	Customer                  Customer `json:"customer"`
	// Customer ID
	CustomerID       *string     `json:"customerId"`
	EffectiveEndDate *string     `json:"effectiveEndDate"`
	EndDate          *string     `json:"endDate"`
	Environment      Environment `json:"environment"`
	// Environment ID
	EnvironmentID  string          `json:"environmentId"`
	Experiment     *Experiment     `json:"experiment"`
	ExperimentInfo *ExperimentInfo `json:"experimentInfo"`
	// Free items included in the subscription
	FreeItems        []*FreeSubscriptionItem `json:"freeItems"`
	ID               string                  `json:"id"`
	LastUsageInvoice *SubscriptionInvoice    `json:"lastUsageInvoice"`
	LatestInvoice    *SubscriptionInvoice    `json:"latestInvoice"`
	// Minimum spend configuration
	MinimumSpend      *SubscriptionMinimumSpend `json:"minimumSpend"`
	OldBillingID      *string                   `json:"oldBillingId"`
	PayingCustomer    *Customer                 `json:"payingCustomer"`
	PayingCustomerID  *string                   `json:"payingCustomerId"`
	PaymentCollection PaymentCollection         `json:"paymentCollection"`
	// Payment collection method of the subscription
	PaymentCollectionMethod *PaymentCollectionMethod `json:"paymentCollectionMethod"`
	Plan                    Plan                     `json:"plan"`
	Prices                  []*SubscriptionPrice     `json:"prices"`
	PricingType             PricingType              `json:"pricingType"`
	RefID                   string                   `json:"refId"`
	Resource                *CustomerResource        `json:"resource"`
	// Resource ID
	ResourceID       *string                        `json:"resourceId"`
	SalesforceID     *string                        `json:"salesforceId"`
	ScheduledUpdates []*SubscriptionScheduledUpdate `json:"scheduledUpdates"`
	StartDate        string                         `json:"startDate"`
	// Subscription status
	Status                   SubscriptionStatus              `json:"status"`
	SubscriptionEntitlements []*SubscriptionEntitlement      `json:"subscriptionEntitlements"`
	SubscriptionID           string                          `json:"subscriptionId"`
	SyncStates               []*SyncState                    `json:"syncStates"`
	TotalPrice               *CustomerSubscriptionTotalPrice `json:"totalPrice"`
	// Trial configuration
	TrialConfiguration *TrialConfiguration `json:"trialConfiguration"`
	TrialEndDate       *string             `json:"trialEndDate"`
	WasInTrial         *bool               `json:"wasInTrial"`
}

type SubscriptionQueryAggregateGroupBy struct {
	CreatedAt     *string             `json:"createdAt"`
	CustomerID    *string             `json:"customerId"`
	EnvironmentID *string             `json:"environmentId"`
	ProductID     *string             `json:"productId"`
	ResourceID    *string             `json:"resourceId"`
	Status        *SubscriptionStatus `json:"status"`
}

type SubscriptionQueryConnection struct {
	// Array of edges.
	Edges []*SubscriptionQueryEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type SubscriptionQueryCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	CustomerID    *int64 `json:"customerId"`
	EnvironmentID *int64 `json:"environmentId"`
	ProductID     *int64 `json:"productId"`
	ResourceID    *int64 `json:"resourceId"`
	Status        *int64 `json:"status"`
}

type SubscriptionQueryEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the SubscriptionQuery
	Node SubscriptionQuery `json:"node"`
}

type SubscriptionQueryFilter struct {
	And           []*SubscriptionQueryFilter          `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                `json:"createdAt,omitempty"`
	CustomerID    *StringFieldComparison              `json:"customerId,omitempty"`
	EnvironmentID *UUIDFilterComparison               `json:"environmentId,omitempty"`
	Or            []*SubscriptionQueryFilter          `json:"or,omitempty"`
	ProductID     *StringFieldComparison              `json:"productId,omitempty"`
	ResourceID    *StringFieldComparison              `json:"resourceId,omitempty"`
	Status        *SubscriptionStatusFilterComparison `json:"status,omitempty"`
}

type SubscriptionQueryMaxAggregate struct {
	CreatedAt     *string             `json:"createdAt"`
	CustomerID    *string             `json:"customerId"`
	EnvironmentID *string             `json:"environmentId"`
	ProductID     *string             `json:"productId"`
	ResourceID    *string             `json:"resourceId"`
	Status        *SubscriptionStatus `json:"status"`
}

type SubscriptionQueryMinAggregate struct {
	CreatedAt     *string             `json:"createdAt"`
	CustomerID    *string             `json:"customerId"`
	EnvironmentID *string             `json:"environmentId"`
	ProductID     *string             `json:"productId"`
	ResourceID    *string             `json:"resourceId"`
	Status        *SubscriptionStatus `json:"status"`
}

type SubscriptionQuerySort struct {
	Direction SortDirection               `json:"direction"`
	Field     SubscriptionQuerySortFields `json:"field"`
	Nulls     *SortNulls                  `json:"nulls,omitempty"`
}

type SubscriptionScheduledUpdate struct {
	BillingID      *string                    `json:"billingId"`
	CreatedAt      *string                    `json:"createdAt"`
	ScheduleStatus SubscriptionScheduleStatus `json:"scheduleStatus"`
	// The schedule variables by the type of the schedule
	ScheduleVariables        ScheduleVariables        `json:"scheduleVariables"`
	ScheduledExecutionTime   string                   `json:"scheduledExecutionTime"`
	SubscriptionScheduleType SubscriptionScheduleType `json:"subscriptionScheduleType"`
	TargetPackage            *PackageDto              `json:"targetPackage"`
}

type SubscriptionStatusFilterComparison struct {
	Eq       *SubscriptionStatus  `json:"eq,omitempty"`
	Gt       *SubscriptionStatus  `json:"gt,omitempty"`
	Gte      *SubscriptionStatus  `json:"gte,omitempty"`
	ILike    *SubscriptionStatus  `json:"iLike,omitempty"`
	In       []SubscriptionStatus `json:"in,omitempty"`
	Is       *bool                `json:"is,omitempty"`
	IsNot    *bool                `json:"isNot,omitempty"`
	Like     *SubscriptionStatus  `json:"like,omitempty"`
	Lt       *SubscriptionStatus  `json:"lt,omitempty"`
	Lte      *SubscriptionStatus  `json:"lte,omitempty"`
	Neq      *SubscriptionStatus  `json:"neq,omitempty"`
	NotILike *SubscriptionStatus  `json:"notILike,omitempty"`
	NotIn    []SubscriptionStatus `json:"notIn,omitempty"`
	NotLike  *SubscriptionStatus  `json:"notLike,omitempty"`
}

type SubscriptionUpdateScheduleCancellationInput struct {
	EnvironmentID  *string                     `json:"environmentId,omitempty"`
	Status         *SubscriptionScheduleStatus `json:"status,omitempty"`
	SubscriptionID string                      `json:"subscriptionId"`
}

// Usage reset cutoff rule - when does the usage for a feature should be reset
type SubscriptionUpdateUsageResetCutoffRule struct {
	// Behavior to reset according to
	Behavior SubscriptionUpdateUsageCutoffBehavior `json:"behavior"`
}

// Input for usage reset cutoff rule
type SubscriptionUpdateUsageResetCutoffRuleInput struct {
	// Behavior of the usage reset cutoff rule
	Behavior SubscriptionUpdateUsageCutoffBehavior `json:"behavior"`
}

// Data of billing sync revision
type SyncRevisionBillingData struct {
	// Billing integration id
	BillingID string `json:"billingId"`
	// Billing integration url
	BillingLinkURL string `json:"billingLinkUrl"`
}

func (SyncRevisionBillingData) IsSyncRevisionData() {}

// Data of marketplace sync revision
type SyncRevisionMarketplaceData struct {
	// Dimensions of the marketplace sync revision
	Dimensions string `json:"dimensions"`
}

func (SyncRevisionMarketplaceData) IsSyncRevisionData() {}

// Data of price billing sync revision
type SyncRevisionPriceBillingData struct {
	// Billing integration id
	BillingID string `json:"billingId"`
	// Billing integration url
	BillingLinkURL string `json:"billingLinkUrl"`
	// Price group package billing id
	PriceGroupPackageBillingID string `json:"priceGroupPackageBillingId"`
}

func (SyncRevisionPriceBillingData) IsSyncRevisionData() {}

// State of the integration sync
type SyncState struct {
	// Sync revision data
	Data SyncRevisionData `json:"data"`
	// Error message
	Error *string `json:"error"`
	// Integration details
	Integration Integration `json:"integration"`
	// Status of the integration sync
	Status SyncStatus `json:"status"`
	// Synced entity id
	SyncedEntityID *string `json:"syncedEntityId"`
	// The vendor identifier of integration
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
}

// Input for triggering a sync of tax rates from the billing provider.
type SyncTaxRatesInput struct {
	// The ID of the environment for which tax rates should be synced.
	EnvironmentID *string `json:"environmentId,omitempty"`
}

type TaskStatusFilterComparison struct {
	Eq       *TaskStatus  `json:"eq,omitempty"`
	Gt       *TaskStatus  `json:"gt,omitempty"`
	Gte      *TaskStatus  `json:"gte,omitempty"`
	ILike    *TaskStatus  `json:"iLike,omitempty"`
	In       []TaskStatus `json:"in,omitempty"`
	Is       *bool        `json:"is,omitempty"`
	IsNot    *bool        `json:"isNot,omitempty"`
	Like     *TaskStatus  `json:"like,omitempty"`
	Lt       *TaskStatus  `json:"lt,omitempty"`
	Lte      *TaskStatus  `json:"lte,omitempty"`
	Neq      *TaskStatus  `json:"neq,omitempty"`
	NotILike *TaskStatus  `json:"notILike,omitempty"`
	NotIn    []TaskStatus `json:"notIn,omitempty"`
	NotLike  *TaskStatus  `json:"notLike,omitempty"`
}

type TaskTypeFilterComparison struct {
	Eq       *TaskType  `json:"eq,omitempty"`
	Gt       *TaskType  `json:"gt,omitempty"`
	Gte      *TaskType  `json:"gte,omitempty"`
	ILike    *TaskType  `json:"iLike,omitempty"`
	In       []TaskType `json:"in,omitempty"`
	Is       *bool      `json:"is,omitempty"`
	IsNot    *bool      `json:"isNot,omitempty"`
	Like     *TaskType  `json:"like,omitempty"`
	Lt       *TaskType  `json:"lt,omitempty"`
	Lte      *TaskType  `json:"lte,omitempty"`
	Neq      *TaskType  `json:"neq,omitempty"`
	NotILike *TaskType  `json:"notILike,omitempty"`
	NotIn    []TaskType `json:"notIn,omitempty"`
	NotLike  *TaskType  `json:"notLike,omitempty"`
}

// Information on the tax exemption.
type TaxExempt struct {
	// The type of tax exemption identifier, such as VAT.
	Type string `json:"type"`
	// The actual tax identifier value
	Value string `json:"value"`
}

// TestHook object
type TestHook struct {
	// The event log type to test
	TestHookEventType string `json:"testHookEventType"`
	// The payload for the event log type
	TestHookPayload string `json:"testHookPayload"`
}

// TestHookInput object
type TestHookInput struct {
	// The endpoint URL for the webhook
	EndpointURL string `json:"endpointUrl"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The event log type to test
	HookEventType EventLogType `json:"hookEventType"`
}

// TestHookResult object
type TestHookResult struct {
	// The status code of the response
	ResponseStatusCode *float64 `json:"responseStatusCode"`
	// The status text of the response
	ResponseStatusText *string `json:"responseStatusText"`
	// Whether the response was successful
	ResponseSuccess bool `json:"responseSuccess"`
}

// Trigger workflow with test event input
type TestWorkflowInput struct {
	// Workflow trigger endpoint
	EndpointURL string `json:"endpointUrl"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The event type to trigger the workflow on
	HookEventType EventLogType `json:"hookEventType"`
}

type TiersModeFilterComparison struct {
	Eq       *TiersMode  `json:"eq,omitempty"`
	Gt       *TiersMode  `json:"gt,omitempty"`
	Gte      *TiersMode  `json:"gte,omitempty"`
	ILike    *TiersMode  `json:"iLike,omitempty"`
	In       []TiersMode `json:"in,omitempty"`
	Is       *bool       `json:"is,omitempty"`
	IsNot    *bool       `json:"isNot,omitempty"`
	Like     *TiersMode  `json:"like,omitempty"`
	Lt       *TiersMode  `json:"lt,omitempty"`
	Lte      *TiersMode  `json:"lte,omitempty"`
	Neq      *TiersMode  `json:"neq,omitempty"`
	NotILike *TiersMode  `json:"notILike,omitempty"`
	NotIn    []TiersMode `json:"notIn,omitempty"`
	NotLike  *TiersMode  `json:"notLike,omitempty"`
}

type TransferSubscriptionInput struct {
	CustomerID            string `json:"customerId"`
	DestinationResourceID string `json:"destinationResourceId"`
	SourceResourceID      string `json:"sourceResourceId"`
}

// The input for transferring a subscription to a resource
type TransferSubscriptionToResourceInput struct {
	// The resource ID to transfer the subscription to
	DestinationResourceID *string `json:"destinationResourceId,omitempty"`
	// The environment ID of the subscription to transfer
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The ID of the subscription to transfer
	SubscriptionID string `json:"subscriptionId"`
}

// Trial configuration
type TrialConfiguration struct {
	// Indicates the behavior of the subscription when the trial is expired.
	TrialEndBehavior TrialEndBehavior `json:"trialEndBehavior"`
}

type TrialOverrideConfigurationInput struct {
	IsTrial bool `json:"isTrial"`
	// Indicates the behavior of the subscription when the trial is expired.
	TrialEndBehavior *TrialEndBehavior `json:"trialEndBehavior,omitempty"`
	TrialEndDate     *string           `json:"trialEndDate,omitempty"`
}

// Information on a plan this customer already trialed
type TrialedPlan struct {
	// Internal plan id
	PlanID *string `json:"planId"`
	// Plan slug, as defined by the user
	PlanRefID *string `json:"planRefId"`
	// Internal product id
	ProductID *string `json:"productId"`
	// Product slug, as defined by the user
	ProductRefID *string `json:"productRefId"`
}

// Input for triggering the subscription billing month ends soon webhook
type TriggerSubscriptionBillingMonthEndsSoonWebhookInput struct {
	// The subscription reference id to trigger the webhook for
	SubscriptionID string `json:"subscriptionId"`
}

// Trigger a subscription migration
type TriggerSubscriptionMigrationInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
	// The version number of the plan to migrate
	VersionNumber float64 `json:"versionNumber"`
}

// The result of triggering a subscription migration
type TriggerSubscriptionMigrationResult struct {
	// The id of the task that was created
	TaskID *string `json:"taskId"`
}

// Input for triggering usage sync
type TriggerSubscriptionUsageSyncInput struct {
	// The customer id to trigger usage sync for
	CustomerID string `json:"customerId"`
	// The environment id to trigger usage sync for
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The resource id to trigger usage sync for
	ResourceID *string `json:"resourceId,omitempty"`
}

// Trigger workflow
type TriggerWorkflowDto struct {
	// Workflow payload
	Response map[string]interface{} `json:"response"`
	// Trigger workflow success
	Success bool `json:"success"`
}

// Trigger workflow input
type TriggerWorkflowInput struct {
	// If set to true, trigger the test workflow, otherwise trigger live workflow
	IsTest *bool `json:"isTest,omitempty"`
	// Workflow payload
	Payload map[string]interface{} `json:"payload,omitempty"`
	// Trigger id
	TriggerID string `json:"triggerId"`
}

// Typography settings for various text elements.
type TypographyConfiguration struct {
	// Font styling for body text.
	Body *FontVariant `json:"body"`
	// Primary font family used across the widget.
	FontFamily *string `json:"fontFamily"`
	// Font styling for level-1 headings.
	H1 *FontVariant `json:"h1"`
	// Font styling for level-2 headings.
	H2 *FontVariant `json:"h2"`
	// Font styling for level-3 headings.
	H3 *FontVariant `json:"h3"`
}

// Input for setting typography styles for widgets.
type TypographyConfigurationInput struct {
	// Style applied to general text content.
	Body *FontVariantInput `json:"body,omitempty"`
	// Font family to be used throughout the widget.
	FontFamily *string `json:"fontFamily,omitempty"`
	// Style applied to top-level headings.
	H1 *FontVariantInput `json:"h1,omitempty"`
	// Style applied to second-level headings.
	H2 *FontVariantInput `json:"h2,omitempty"`
	// Style applied to third-level headings.
	H3 *FontVariantInput `json:"h3,omitempty"`
}

type UUIDFilterComparison struct {
	Eq       *string  `json:"eq,omitempty"`
	Gt       *string  `json:"gt,omitempty"`
	Gte      *string  `json:"gte,omitempty"`
	ILike    *string  `json:"iLike,omitempty"`
	In       []string `json:"in,omitempty"`
	Is       *bool    `json:"is,omitempty"`
	IsNot    *bool    `json:"isNot,omitempty"`
	Like     *string  `json:"like,omitempty"`
	Lt       *string  `json:"lt,omitempty"`
	Lte      *string  `json:"lte,omitempty"`
	Neq      *string  `json:"neq,omitempty"`
	NotILike *string  `json:"notILike,omitempty"`
	NotIn    []string `json:"notIn,omitempty"`
	NotLike  *string  `json:"notLike,omitempty"`
}

// Input for unarchiving a feature group
type UnArchiveFeatureGroupInput struct {
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The feature group id
	FeatureGroupID string `json:"featureGroupId"`
}

// Input for un-archiving a feature
type UnArchiveFeatureInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Unique identifier for the entity
	ID string `json:"id"`
}

// Input for un-archiving a plan
type UnArchivePlanInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Plan ID to unarchive
	ID string `json:"id"`
}

type UnPublishedPackageError struct {
	Code                   string   `json:"code"`
	IsValidationError      bool     `json:"isValidationError"`
	NonPublishedPackageIds []string `json:"nonPublishedPackageIds"`
	PackageType            string   `json:"packageType"`
}

// Unarchive a customer
type UnarchiveCustomerInput struct {
	// Customer slug
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Input for unarchiving an environment
type UnarchiveEnvironmentInput struct {
	// Unique identifier for the entity
	ID *string `json:"id,omitempty"`
	// A unique identifier for the environment
	Slug *string `json:"slug,omitempty"`
}

type UnitAmountChangeVariables struct {
	FeatureID     *string  `json:"featureId"`
	NewUnitAmount *float64 `json:"newUnitAmount"`
}

func (UnitAmountChangeVariables) IsScheduleVariables() {}

// Transformation to the reported usage
type UnitTransformation struct {
	// Divide usage by this number
	Divide float64 `json:"divide"`
	// Singular feature units after the transformation
	FeatureUnits *string `json:"featureUnits"`
	// Plural feature units after the transformation
	FeatureUnitsPlural *string `json:"featureUnitsPlural"`
	// After division, either round the result up or down
	Round UnitTransformationRound `json:"round"`
}

// Input for unit transformation to be applied to the reported usage
type UnitTransformationInput struct {
	// Divide usage by this number
	Divide int64 `json:"divide"`
	// Singular feature units after the transformation
	FeatureUnits *string `json:"featureUnits,omitempty"`
	// Plural feature units after the transformation
	FeatureUnitsPlural *string `json:"featureUnitsPlural,omitempty"`
	// After division, either round the result up or down
	Round *UnitTransformationRound `json:"round,omitempty"`
}

// Unlink feature group from package entitlements input
type UnlinkFeatureGroupInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The group id to unlink
	FeatureGroupID string `json:"featureGroupId"`
	// The unique identifier of the entitlement package
	PackageID string `json:"packageId"`
}

type UnsupportedFeatureTypeError struct {
	Code        string `json:"code"`
	FeatureType string `json:"featureType"`
}

type UnsupportedVendorIdentifierError struct {
	Code             string `json:"code"`
	VendorIdentifier string `json:"vendorIdentifier"`
}

// Input type for updating an account
type UpdateAccountInput struct {
	// The method of adding new members to this account
	AccessMethod *AccountAccessMethod `json:"accessMethod,omitempty"`
	// Email domain to be used for sso and authorized domain configuration
	AccountEmailDomain *string `json:"accountEmailDomain,omitempty"`
	// Default SSO roles for the account
	DefaultSSORoles *DefaultSSORolesInput `json:"defaultSSORoles,omitempty"`
	// The display name of the account
	DisplayName string `json:"displayName"`
	// The billing anchor for the subscription, e.g. "START_OF_THE_MONTH"
	SubscriptionBillingAnchor *BillingAnchor `json:"subscriptionBillingAnchor,omitempty"`
	// The proration behavior for the subscription, e.g. "CREATE_PRORATIONS"
	SubscriptionProrationBehavior *ProrationBehavior `json:"subscriptionProrationBehavior,omitempty"`
	// The timezone of the account, e.g. "America/New_York"
	Timezone *string `json:"timezone,omitempty"`
}

// Update a coupon input
type UpdateCouponInput struct {
	// Metadata associated with the entity
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// Description of the coupon
	Description *string `json:"description,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Name of the coupon
	Name *string `json:"name,omitempty"`
	// The unique identifier for the entity
	RefID string `json:"refId"`
}

// Update customer information
type UpdateCustomerInput struct {
	// Additional metadata update
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The AWS Marketplace integration id
	AwsMarketplaceCustomerID *string `json:"awsMarketplaceCustomerId,omitempty"`
	// The unique identifier for the entity in the billing provider
	BillingID *string `json:"billingId,omitempty"`
	// Billing information update
	BillingInformation *CustomerBillingInfo `json:"billingInformation,omitempty"`
	// Update a customer level coupon
	CouponRefID *string `json:"couponRefId,omitempty"`
	// The unique identifier for the customer in Hubspot integration
	CrmID *string `json:"crmId,omitempty"`
	// Customer slug
	CustomerID *string `json:"customerId,omitempty"`
	// The email of the customer
	Email *string `json:"email,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The name of the customer
	Name *string `json:"name,omitempty"`
	// Customer slug
	RefID *string `json:"refId,omitempty"`
	// The unique identifier for the customer in Salesforce integration
	SalesforceID *string `json:"salesforceId,omitempty"`
	// Should wait for sync to complete before returning a response
	ShouldWaitSync *bool `json:"shouldWaitSync,omitempty"`
}

// Update entitlements order
type UpdateEntitlementsOrderDto struct {
	ID string `json:"id"`
	// The order of the entitlement in the entitlement list
	Order *float64 `json:"order"`
}

// Input parameters for updating an existing experiment
type UpdateExperimentInput struct {
	// Name for the control group
	ControlGroupName *string `json:"controlGroupName,omitempty"`
	// Description of the experiements
	Description *string `json:"description,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Name of the experiment
	Name *string `json:"name,omitempty"`
	// Internal identifier for the product experiment is associated with
	ProductID *string `json:"productId,omitempty"`
	// Product settings for the variant group
	ProductSettings *ProductSettingsInput `json:"productSettings,omitempty"`
	// The unique identifier for the experiment
	RefID string `json:"refId"`
	// Name for the variant group
	VariantGroupName *string `json:"variantGroupName,omitempty"`
	// Percentage of users in the variant group
	VariantPercentage *float64 `json:"variantPercentage,omitempty"`
}

// Input for updating a feature
type UpdateFeatureInput struct {
	// The additional metadata for the feature
	AdditionalMetaData map[string]interface{} `json:"additionalMetaData,omitempty"`
	// The description for the feature
	Description *string `json:"description,omitempty"`
	// The display name for the feature
	DisplayName *string `json:"displayName,omitempty"`
	// The configuration data for the feature
	EnumConfiguration []*EnumConfigurationEntityInput `json:"enumConfiguration,omitempty"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// The units for the feature
	FeatureUnits *string `json:"featureUnits,omitempty"`
	// The plural units for the feature
	FeatureUnitsPlural *string `json:"featureUnitsPlural,omitempty"`
	// Input for creating a meter
	Meter *CreateMeter `json:"meter,omitempty"`
	// The unique identifier for the feature
	RefID string `json:"refId"`
	// Unit transformation to be applied to the reported usage
	UnitTransformation *UnitTransformationInput `json:"unitTransformation,omitempty"`
}

type UpdateHook struct {
	// A JSON containing the configuration for each event log type
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// Webhook description
	Description *string `json:"description,omitempty"`
	// The Webhook endpoint URL
	Endpoint *string `json:"endpoint,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The event types that the webhook will be triggered on
	EventLogTypes []EventLogType `json:"eventLogTypes,omitempty"`
	// Unique identifier for the entity
	ID *string `json:"id,omitempty"`
	// Secret key for the webhook
	SecretKey *string `json:"secretKey,omitempty"`
	// The status of the webhook
	Status *HookStatus `json:"status,omitempty"`
}

// Update integration input
type UpdateIntegrationInput struct {
	// Auth0 integration configuration
	Auth0Credentials *Auth0CredentialsInput `json:"auth0Credentials,omitempty"`
	// The reference ID for the integration
	IntegrationID *string `json:"integrationId,omitempty"`
	// Whether the integration is the default integration
	IsDefault *bool `json:"isDefault,omitempty"`
	// OpenFGA integration configuration
	OpenFGACredentials *OpenFGACredentialsInput `json:"openFGACredentials,omitempty"`
	// Salesforce integration configuration
	SalesforceCredentials *SalesforceCredentialsInput `json:"salesforceCredentials,omitempty"`
	// Stripe integration configuration
	StripeCredentials *UpdateStripeCredentialsInput `json:"stripeCredentials,omitempty"`
	// The vendor identifier of integration
	VendorIdentifier VendorIdentifier `json:"vendorIdentifier"`
	// Zuora integration configuration
	ZuoraCredentials *ZuoraCredentialsInput `json:"zuoraCredentials,omitempty"`
}

type UpdateOneEnvironmentInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update EnvironmentInput `json:"update"`
}

type UpdateOneHookInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateHook `json:"update"`
}

type UpdateOneIntegrationInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update UpdateIntegrationInput `json:"update"`
}

type UpdateOnePackageEntitlementInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update PackageEntitlementUpdateInput `json:"update"`
}

type UpdateOneProductInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update ProductUpdateInput `json:"update"`
}

type UpdateOnePromotionalEntitlementInput struct {
	// The id of the record to update
	ID string `json:"id"`
	// The update to apply.
	Update PromotionalEntitlementUpdateInput `json:"update"`
}

// Update package entitlement order input
type UpdatePackageEntitlementOrderInput struct {
	// Entitlements to update
	Entitlements []*UpdatePackageEntitlementOrderItemInput `json:"entitlements"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// The unique identifier of the entitlement package
	PackageID string `json:"packageId"`
}

// Update package entitlement order item input
type UpdatePackageEntitlementOrderItemInput struct {
	// Unique identifier for the entity
	ID string `json:"id"`
	// The order of the entitlement in the entitlement list
	Order *float64 `json:"order,omitempty"`
}

// Input configuration for updating Stripe integration
type UpdateStripeCredentialsInput struct {
	// Whether tax is enabled for the Stripe account
	IsTaxEnabled *bool `json:"isTaxEnabled,omitempty"`
}

// Update subscription entitlement input
type UpdateSubscriptionEntitlementInput struct {
	// The unique identifier of the entitlement feature
	FeatureID *string `json:"featureId,omitempty"`
	// Whether the entitlement has a soft limit
	HasSoftLimit *bool `json:"hasSoftLimit,omitempty"`
	// Whether the entitlement has an unlimited usage
	HasUnlimitedUsage *bool `json:"hasUnlimitedUsage,omitempty"`
	// Unique identifier for the entity
	ID *string `json:"id,omitempty"`
	// The monthly reset period configuration of the entitlement, defined when reset period is monthly
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// The reset period of the entitlement
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// The usage limit of the entitlement
	UsageLimit *float64 `json:"usageLimit,omitempty"`
	// The weekly reset period configuration of the entitlement, defined when reset period is weekly
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// The yearly reset period configuration of the entitlement, defined when reset period is yearly
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

type UpdateSubscriptionInput struct {
	AdditionalMetaData map[string]interface{}    `json:"additionalMetaData,omitempty"`
	Addons             []*SubscriptionAddonInput `json:"addons,omitempty"`
	// Coupon input
	AppliedCoupon            *SubscriptionCouponInput `json:"appliedCoupon,omitempty"`
	AwaitPaymentConfirmation *bool                    `json:"awaitPaymentConfirmation,omitempty"`
	BillableFeatures         []*BillableFeatureInput  `json:"billableFeatures,omitempty"`
	BillingInformation       *SubscriptionBillingInfo `json:"billingInformation,omitempty"`
	BillingPeriod            *BillingPeriod           `json:"billingPeriod,omitempty"`
	// Budget configuration
	Budget        *BudgetConfigurationInput `json:"budget,omitempty"`
	EnvironmentID *string                   `json:"environmentId,omitempty"`
	// The minimum spend configuration
	MinimumSpend *SubscriptionMinimumSpendValueInput `json:"minimumSpend,omitempty"`
	// Override the price of the subscription
	PriceOverrides           []*PriceOverrideInput                 `json:"priceOverrides,omitempty"`
	PromotionCode            *string                               `json:"promotionCode,omitempty"`
	RefID                    *string                               `json:"refId,omitempty"`
	ScheduleStrategy         *ScheduleStrategy                     `json:"scheduleStrategy,omitempty"`
	SubscriptionEntitlements []*UpdateSubscriptionEntitlementInput `json:"subscriptionEntitlements,omitempty"`
	SubscriptionID           *string                               `json:"subscriptionId,omitempty"`
	TrialEndDate             *string                               `json:"trialEndDate,omitempty"`
	UnitQuantity             *float64                              `json:"unitQuantity,omitempty"`
}

// Update the users information
type UpdateUserInput struct {
	// User selected department
	Department *Department `json:"department,omitempty"`
	// User first and last name
	Name string `json:"name"`
}

// An object representing the usage charged
type UsageCharged struct {
	// The id of the feature
	FeatureID *string `json:"featureId"`
	// The amount of units charged for usage usage
	UsageAmount float64 `json:"usageAmount"`
}

// A usage event record
type UsageEvent struct {
	// Customer
	Customer *Customer `json:"customer"`
	// Customer id
	CustomerID string `json:"customerId"`
	// Dimensions associated with the usage event
	Dimensions map[string]interface{} `json:"dimensions"`
	// The name of the usage event
	EventName string `json:"eventName"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Idempotency key
	IdempotencyKey string `json:"idempotencyKey"`
	// Resource id
	ResourceID *string `json:"resourceId"`
	// Timestamp
	Timestamp string `json:"timestamp"`
}

// Input parameters for reporting usage events
type UsageEventReportInput struct {
	// Customer id
	CustomerID string `json:"customerId"`
	// Dimensions to include in the events fields
	Dimensions map[string]interface{} `json:"dimensions,omitempty"`
	// Name of the event
	EventName string `json:"eventName"`
	// Idempotency key
	IdempotencyKey string `json:"idempotencyKey"`
	// Resource id
	ResourceID *string `json:"resourceId,omitempty"`
	// Timestamp
	Timestamp *string `json:"timestamp,omitempty"`
}

// Input for usage events
type UsageEventsInput struct {
	// Customer id filter
	CustomerID *string `json:"customerId,omitempty"`
	// Environment id filter
	EnvironmentID string `json:"environmentId"`
	// List of event filters
	Filters []*MeterFilterDefinitionInput `json:"filters,omitempty"`
}

// Usage events preview
type UsageEventsPreview struct {
	// A usage event record
	Events []*UsageEvent `json:"events"`
}

// Input parameters for reporting usage events
type UsageEventsReportInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// A list of usage events to report
	UsageEvents []*UsageEventReportInput `json:"usageEvents"`
}

// Usage history
type UsageHistory struct {
	// The end date of the usage history period
	EndDate *string `json:"endDate"`
	// Groups included in the usage history
	Groups []*GroupUsageHistory `json:"groups"`
	// Markers indicating events that affect feature usage
	Markers []*UsageMarker `json:"markers"`
	// The start date of the usage history period
	StartDate string `json:"startDate"`
	// List of usage measurements within the period
	UsageMeasurements []*UsageMeasurementPoint `json:"usageMeasurements"`
}

// Input parameters for retrieving usage history
type UsageHistoryInput struct {
	// Reference identifier for the customer
	CustomerRefID string `json:"customerRefId"`
	// The end date of the range
	EndDate *string `json:"endDate,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Reference identifier for the feature
	FeatureRefID string `json:"featureRefId"`
	// Criteria by which to group the usage history
	GroupBy []string `json:"groupBy,omitempty"`
	// Monthly reset period configuration
	MonthlyResetPeriodConfiguration *MonthlyResetPeriodConfigInput `json:"monthlyResetPeriodConfiguration,omitempty"`
	// Reset period
	ResetPeriod *EntitlementResetPeriod `json:"resetPeriod,omitempty"`
	// Reference identifier for the resource
	ResourceRefID *string `json:"resourceRefId,omitempty"`
	// The start date of the range
	StartDate string `json:"startDate"`
	// Weekly reset period configuration
	WeeklyResetPeriodConfiguration *WeeklyResetPeriodConfigInput `json:"weeklyResetPeriodConfiguration,omitempty"`
	// Yearly reset period configuration
	YearlyResetPeriodConfiguration *YearlyResetPeriodConfigInput `json:"yearlyResetPeriodConfiguration,omitempty"`
}

// Point in the usage history
type UsageHistoryPoint struct {
	// Indicates whether there was usage reset in this point, see `markers` for details
	IsResetPoint bool `json:"isResetPoint"`
	// Timestamp of the usage history point
	Timestamp string `json:"timestamp"`
	// Value of the usage history point
	Value float64 `json:"value"`
}

// Series of usage history
type UsageHistorySeries struct {
	// Points in the usage history series
	Points []*UsageHistoryPoint `json:"points"`
	// Tags for the usage history series
	Tags []*UsageHistorySeriesTag `json:"tags"`
}

// Tag for the usage history series
type UsageHistorySeriesTag struct {
	// Key of the tag
	Key string `json:"key"`
	// Value of the tag
	Value string `json:"value"`
}

// Usage history
type UsageHistoryV2 struct {
	// Markers for events that affecting feature usage
	Markers []*UsageMarker `json:"markers"`
	// Series of usage history
	Series []*UsageHistorySeries `json:"series"`
}

// Input parameters for retrieving usage history
type UsageHistoryV2Input struct {
	// Customer id
	CustomerID string `json:"customerId"`
	// The end date of the range
	EndDate *string `json:"endDate,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Feature id
	FeatureID string `json:"featureId"`
	// Criteria by which to group the usage history
	GroupBy []string `json:"groupBy,omitempty"`
	// Resource id
	ResourceID *string `json:"resourceId,omitempty"`
	// The start date of the range
	StartDate string `json:"startDate"`
}

// Marker for a event affecting usage
type UsageMarker struct {
	// Timestamp of the marker
	Timestamp string `json:"timestamp"`
	// Type of marker
	Type UsageMarkerType `json:"type"`
}

// Usage measurement
type UsageMeasurement struct {
	// Timestamp of when the record was created
	CreatedAt string   `json:"createdAt"`
	Customer  Customer `json:"customer"`
	// Customer id
	CustomerID  string      `json:"customerId"`
	Environment Environment `json:"environment"`
	// The unique identifier for the environment
	EnvironmentID string  `json:"environmentId"`
	Feature       Feature `json:"feature"`
	// Feature id
	FeatureID string `json:"featureId"`
	// Unique identifier for the usage measurement
	ID string `json:"id"`
	// Measured usage value
	Value float64 `json:"value"`
}

type UsageMeasurementAggregateGroupBy struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type UsageMeasurementConnection struct {
	// Array of edges.
	Edges []*UsageMeasurementEdge `json:"edges"`
	// Paging information
	PageInfo PageInfo `json:"pageInfo"`
	// Fetch total count of records
	TotalCount int64 `json:"totalCount"`
}

type UsageMeasurementCountAggregate struct {
	CreatedAt     *int64 `json:"createdAt"`
	EnvironmentID *int64 `json:"environmentId"`
	ID            *int64 `json:"id"`
}

// Input for creating a usage measurement
type UsageMeasurementCreateInput struct {
	// Timestamp of when the record was created
	CreatedAt *string `json:"createdAt,omitempty"`
	// Customer id
	CustomerID string `json:"customerId"`
	// Additional dimensions for the usage report
	Dimensions map[string]interface{} `json:"dimensions,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Feature id
	FeatureID string `json:"featureId"`
	// Resource id
	ResourceID *string `json:"resourceId,omitempty"`
	// The method by which the usage value should be updated
	UpdateBehavior *UsageUpdateBehavior `json:"updateBehavior,omitempty"`
	// The value to report for usage
	Value float64 `json:"value"`
}

type UsageMeasurementEdge struct {
	// Cursor for this node.
	Cursor string `json:"cursor"`
	// The node containing the UsageMeasurement
	Node UsageMeasurement `json:"node"`
}

type UsageMeasurementFilter struct {
	And           []*UsageMeasurementFilter             `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                  `json:"createdAt,omitempty"`
	Customer      *UsageMeasurementFilterCustomerFilter `json:"customer,omitempty"`
	EnvironmentID *UUIDFilterComparison                 `json:"environmentId,omitempty"`
	Feature       *UsageMeasurementFilterFeatureFilter  `json:"feature,omitempty"`
	ID            *UUIDFilterComparison                 `json:"id,omitempty"`
	Or            []*UsageMeasurementFilter             `json:"or,omitempty"`
}

type UsageMeasurementFilterCustomerFilter struct {
	And                  []*UsageMeasurementFilterCustomerFilter `json:"and,omitempty"`
	BillingID            *StringFieldComparison                  `json:"billingId,omitempty"`
	CreatedAt            *DateFieldComparison                    `json:"createdAt,omitempty"`
	CrmHubspotCompanyID  *StringFieldComparison                  `json:"crmHubspotCompanyId,omitempty"`
	CrmHubspotCompanyURL *StringFieldComparison                  `json:"crmHubspotCompanyUrl,omitempty"`
	CrmID                *StringFieldComparison                  `json:"crmId,omitempty"`
	CustomerID           *StringFieldComparison                  `json:"customerId,omitempty"`
	DeletedAt            *DateFieldComparison                    `json:"deletedAt,omitempty"`
	Email                *StringFieldComparison                  `json:"email,omitempty"`
	EnvironmentID        *UUIDFilterComparison                   `json:"environmentId,omitempty"`
	ID                   *UUIDFilterComparison                   `json:"id,omitempty"`
	Name                 *StringFieldComparison                  `json:"name,omitempty"`
	Or                   []*UsageMeasurementFilterCustomerFilter `json:"or,omitempty"`
	RefID                *StringFieldComparison                  `json:"refId,omitempty"`
	SalesforceID         *StringFieldComparison                  `json:"salesforceId,omitempty"`
	SearchQuery          *CustomerSearchQueryFilterComparison    `json:"searchQuery,omitempty"`
	UpdatedAt            *DateFieldComparison                    `json:"updatedAt,omitempty"`
}

type UsageMeasurementFilterFeatureFilter struct {
	And           []*UsageMeasurementFilterFeatureFilter `json:"and,omitempty"`
	CreatedAt     *DateFieldComparison                   `json:"createdAt,omitempty"`
	Description   *StringFieldComparison                 `json:"description,omitempty"`
	DisplayName   *StringFieldComparison                 `json:"displayName,omitempty"`
	EnvironmentID *UUIDFilterComparison                  `json:"environmentId,omitempty"`
	FeatureStatus *FeatureStatusFilterComparison         `json:"featureStatus,omitempty"`
	FeatureType   *FeatureTypeFilterComparison           `json:"featureType,omitempty"`
	ID            *UUIDFilterComparison                  `json:"id,omitempty"`
	MeterType     *MeterTypeFilterComparison             `json:"meterType,omitempty"`
	Or            []*UsageMeasurementFilterFeatureFilter `json:"or,omitempty"`
	RefID         *StringFieldComparison                 `json:"refId,omitempty"`
	UpdatedAt     *DateFieldComparison                   `json:"updatedAt,omitempty"`
}

type UsageMeasurementMaxAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

type UsageMeasurementMinAggregate struct {
	CreatedAt     *string `json:"createdAt"`
	EnvironmentID *string `json:"environmentId"`
	ID            *string `json:"id"`
}

// Usage measurement point
type UsageMeasurementPoint struct {
	// The date and time of this measurement point
	Date string `json:"date"`
	// Indicates whether usage was reset at this point; see markers for further details
	IsResetPoint bool `json:"isResetPoint"`
	// The recorded value at this measurement point
	Value float64 `json:"value"`
}

type UsageMeasurementSort struct {
	Direction SortDirection              `json:"direction"`
	Field     UsageMeasurementSortFields `json:"field"`
	Nulls     *SortNulls                 `json:"nulls,omitempty"`
}

// Usage measurement updated
type UsageMeasurementUpdated struct {
	// The unique identifier for the account
	AccountID string `json:"accountId"`
	// The current measured usage value
	CurrentUsage float64 `json:"currentUsage"`
	// Customer id
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Feature id
	FeatureID string `json:"featureId"`
	// The date when the next usage reset will occur
	NextResetDate *float64 `json:"nextResetDate"`
	// Resource id
	ResourceID *string `json:"resourceId"`
	// The end date of the usage period in which this measurement resides (for entitlements with a reset period)
	UsagePeriodEnd *float64 `json:"usagePeriodEnd"`
	// The start date of the usage period in which this measurement resides (for entitlements with a reset period)
	UsagePeriodStart *float64 `json:"usagePeriodStart"`
}

// Usage measurement with current usage
type UsageMeasurementWithCurrentUsage struct {
	// Timestamp of when the record was created
	CreatedAt string `json:"createdAt"`
	// The current measured usage value
	CurrentUsage *float64 `json:"currentUsage"`
	// Customer id
	CustomerID string `json:"customerId"`
	// The unique identifier for the environment
	EnvironmentID string `json:"environmentId"`
	// Feature id
	FeatureID string `json:"featureId"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// The date when the next usage reset will occur
	NextResetDate *string `json:"nextResetDate"`
	// Resource id
	ResourceID *string `json:"resourceId"`
	// Timestamp
	Timestamp string `json:"timestamp"`
	// The end date of the usage period in which this measurement resides (for entitlements with a reset period)
	UsagePeriodEnd *string `json:"usagePeriodEnd"`
	// The start date of the usage period in which this measurement resides (for entitlements with a reset period)
	UsagePeriodStart *string `json:"usagePeriodStart"`
	// The usage measurement record
	Value float64 `json:"value"`
}

// Usage updated event
type UsageUpdated struct {
	// Entitlement
	Entitlement Entitlement `json:"entitlement"`
	// Usage
	Usage UsageMeasurementUpdated `json:"usage"`
}

// Stigg user
type User struct {
	// User selected department
	Department *Department `json:"department"`
	// User email
	Email *string `json:"email"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Last time the user logged in
	LastSeenAt *string `json:"lastSeenAt"`
	// Environments this user is a member of
	Memberships []*Member `json:"memberships"`
	// User first and last name
	Name *string `json:"name"`
	// Link to the profile image
	ProfileImageURL *string `json:"profileImageUrl"`
	// support chat user identity token
	SupportChatToken *string `json:"supportChatToken"`
}

// DTO representing the result of an environment merge validation
type ValidateMergeEnvironment struct {
	// List of errors or warnings found during the validation. Empty if isValid is true
	Errors []string `json:"errors"`
	// Boolean indicating whether the merge is valid and can proceed without issues
	IsValid bool `json:"isValid"`
}

// Input type for validateMergeEnvironment query
type ValidateMergeEnvironmentInput struct {
	// Slug of the destination environment
	DestinationEnvironmentSlug string `json:"destinationEnvironmentSlug"`
	// Optional configuration to customize how the validation is performed
	MergeConfiguration *EnvironmentMergeConfigurationInput `json:"mergeConfiguration,omitempty"`
	// Slug of the source environment
	SourceEnvironmentSlug string `json:"sourceEnvironmentSlug"`
}

type VendorIdentifierFilterComparison struct {
	Eq       *VendorIdentifier  `json:"eq,omitempty"`
	Gt       *VendorIdentifier  `json:"gt,omitempty"`
	Gte      *VendorIdentifier  `json:"gte,omitempty"`
	ILike    *VendorIdentifier  `json:"iLike,omitempty"`
	In       []VendorIdentifier `json:"in,omitempty"`
	Is       *bool              `json:"is,omitempty"`
	IsNot    *bool              `json:"isNot,omitempty"`
	Like     *VendorIdentifier  `json:"like,omitempty"`
	Lt       *VendorIdentifier  `json:"lt,omitempty"`
	Lte      *VendorIdentifier  `json:"lte,omitempty"`
	Neq      *VendorIdentifier  `json:"neq,omitempty"`
	NotILike *VendorIdentifier  `json:"notILike,omitempty"`
	NotIn    []VendorIdentifier `json:"notIn,omitempty"`
	NotLike  *VendorIdentifier  `json:"notLike,omitempty"`
}

// Weekly reset period config
type WeeklyResetPeriodConfig struct {
	// Weekly according to configuration
	WeeklyAccordingTo *WeeklyAccordingTo `json:"weeklyAccordingTo"`
}

func (WeeklyResetPeriodConfig) IsResetPeriodConfiguration() {}

// Weekly reset period config input
type WeeklyResetPeriodConfigInput struct {
	// Weekly according to configuration
	AccordingTo WeeklyAccordingTo `json:"accordingTo"`
}

// Configuration settings for all embeddable widgets.
type WidgetConfiguration struct {
	// Custom UI configuration for the checkout widget.
	Checkout *CheckoutConfiguration `json:"checkout"`
	// Custom UI configuration for the customer portal widget.
	CustomerPortal *CustomerPortalConfiguration `json:"customerPortal"`
	// Custom UI configuration for the paywall widget.
	Paywall *PaywallConfiguration `json:"paywall"`
}

// Input for updating configuration settings across all widgets.
type WidgetConfigurationUpdateInput struct {
	// Updated configuration for the checkout widget.
	CheckoutConfiguration *CheckoutConfigurationInput `json:"checkoutConfiguration,omitempty"`
	// Updated configuration for the customer portal widget.
	CustomerPortalConfiguration *CustomerPortalConfigurationInput `json:"customerPortalConfiguration,omitempty"`
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
	// Updated configuration for the paywall widget.
	PaywallConfiguration *PaywallConfigurationInput `json:"paywallConfiguration,omitempty"`
}

// Workflow trigger
type WorkflowTriggerDto struct {
	// Workflow trigger endpoint
	Endpoint string `json:"endpoint"`
	// Event log types
	EventLogTypes []EventLogType `json:"eventLogTypes"`
	// Unique identifier for the entity
	ID string `json:"id"`
	// Trigger id
	TriggerID string `json:"triggerId"`
}

// Workflow login
type WorkflowsLoginDto struct {
	// Current project id
	ProjectID string `json:"projectId"`
	// Workflow token
	Token string `json:"token"`
}

// Workflow login input
type WorkflowsLoginInput struct {
	// The unique identifier for the environment
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// Yearly reset period config
type YearlyResetPeriodConfig struct {
	// Yearly according to configuration
	YearlyAccordingTo *YearlyAccordingTo `json:"yearlyAccordingTo"`
}

func (YearlyResetPeriodConfig) IsResetPeriodConfiguration() {}

// Yearly reset period config input
type YearlyResetPeriodConfigInput struct {
	// Yearly according to configuration
	AccordingTo YearlyAccordingTo `json:"accordingTo"`
}

// Zuora integration configuration object
type ZuoraCredentials struct {
	// REST Base URL of the Zuora account
	BaseURL string `json:"baseUrl"`
	// Client ID for the Zuora account
	ClientID string `json:"clientId"`
	// Client secret for the Zuora account
	ClientSecret string `json:"clientSecret"`
	// The ID of the payment gateway to use
	PaymentGatewayID *string `json:"paymentGatewayId"`
	// The ID of the payment page to use
	PaymentPageID *string `json:"paymentPageId"`
	// Stripe publishable key for the Zuora payment page
	StripePublishableKey *string `json:"stripePublishableKey"`
	// Stripe secret key for the Zuora payment page
	StripeSecretKey *string `json:"stripeSecretKey"`
	// Webhook secret to insert on Zuora callouts
	WebhookSecret *string `json:"webhookSecret"`
}

func (ZuoraCredentials) IsCredentials() {}

// Input configuration for Zuora integration
type ZuoraCredentialsInput struct {
	// REST Base URL of the Zuora account
	BaseURL string `json:"baseUrl"`
	// Client ID for the Zuora account
	ClientID string `json:"clientId"`
	// Client secret for the Zuora account
	ClientSecret string `json:"clientSecret"`
	// The ID of the payment gateway to use
	PaymentGatewayID *string `json:"paymentGatewayId,omitempty"`
	// The ID of the payment page to use
	PaymentPageID *string `json:"paymentPageId,omitempty"`
	// Stripe publishable key for the Zuora payment page
	StripePublishableKey *string `json:"stripePublishableKey,omitempty"`
	// Stripe secret key for the Zuora payment page
	StripeSecretKey *string `json:"stripeSecretKey,omitempty"`
}

// Response for preparing a Zuora payment method form
type ZuoraPaymentMethodForm struct {
	// Form key
	Key string `json:"key"`
	// Form page id
	PageID string `json:"pageId"`
	// Form page url
	PageURL string `json:"pageUrl"`
	// Form signature
	Signature string `json:"signature"`
	// Zuora tenant id
	TenantID string `json:"tenantId"`
	// Form token
	Token string `json:"token"`
}

func (ZuoraPaymentMethodForm) IsPaymentMethodForm() {}

// Detailed information about the experiment
type ExperimentInfo struct {
	// Name of the group in the experiment
	GroupName string `json:"groupName"`
	// Type of group (control or variant)
	GroupType ExperimentGroupType `json:"groupType"`
	// The unique identifier for the experiment
	ID string `json:"id"`
	// Name of the experiment
	Name string `json:"name"`
	// The status of the experiment
	Status ExperimentStatus `json:"status"`
}

// DenyReason of get access policy
type AccessDeniedReason string

const (
	// The customer has exceeded their usage budget for the feature.
	AccessDeniedReasonBudgetExceeded AccessDeniedReason = "BudgetExceeded"
	// The customer is archived and no longer eligible for entitlements.
	AccessDeniedReasonCustomerIsArchived AccessDeniedReason = "CustomerIsArchived"
	// The customer making the request could not be found.
	AccessDeniedReasonCustomerNotFound AccessDeniedReason = "CustomerNotFound"
	// The resource associated with the customer could not be found.
	AccessDeniedReasonCustomerResourceNotFound AccessDeniedReason = "CustomerResourceNotFound"
	// The requested feature does not exist or is not defined in the current environment.
	AccessDeniedReasonFeatureNotFound AccessDeniedReason = "FeatureNotFound"
	// The requested entitlement type does not match the feature type
	AccessDeniedReasonFeatureTypeMismatch AccessDeniedReason = "FeatureTypeMismatch"
	// The customer does not have any active subscription linked to the feature.
	AccessDeniedReasonNoActiveSubscription AccessDeniedReason = "NoActiveSubscription"
	// The current subscription does not include entitlement to the requested feature.
	AccessDeniedReasonNoFeatureEntitlementInSubscription AccessDeniedReason = "NoFeatureEntitlementInSubscription"
	// The customers usage request exceeds their entitled limit.
	AccessDeniedReasonRequestedUsageExceedingLimit AccessDeniedReason = "RequestedUsageExceedingLimit"
	// The requested values do not match the expected values for the feature.
	AccessDeniedReasonRequestedValuesMismatch AccessDeniedReason = "RequestedValuesMismatch"
	// The access denial occurred for an unknown or unexpected reason.
	AccessDeniedReasonUnknown AccessDeniedReason = "Unknown"
)

var AllAccessDeniedReason = []AccessDeniedReason{
	AccessDeniedReasonBudgetExceeded,
	AccessDeniedReasonCustomerIsArchived,
	AccessDeniedReasonCustomerNotFound,
	AccessDeniedReasonCustomerResourceNotFound,
	AccessDeniedReasonFeatureNotFound,
	AccessDeniedReasonFeatureTypeMismatch,
	AccessDeniedReasonNoActiveSubscription,
	AccessDeniedReasonNoFeatureEntitlementInSubscription,
	AccessDeniedReasonRequestedUsageExceedingLimit,
	AccessDeniedReasonRequestedValuesMismatch,
	AccessDeniedReasonUnknown,
}

func (e AccessDeniedReason) IsValid() bool {
	switch e {
	case AccessDeniedReasonBudgetExceeded, AccessDeniedReasonCustomerIsArchived, AccessDeniedReasonCustomerNotFound, AccessDeniedReasonCustomerResourceNotFound, AccessDeniedReasonFeatureNotFound, AccessDeniedReasonFeatureTypeMismatch, AccessDeniedReasonNoActiveSubscription, AccessDeniedReasonNoFeatureEntitlementInSubscription, AccessDeniedReasonRequestedUsageExceedingLimit, AccessDeniedReasonRequestedValuesMismatch, AccessDeniedReasonUnknown:
		return true
	}
	return false
}

func (e AccessDeniedReason) String() string {
	return string(e)
}

func (e *AccessDeniedReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessDeniedReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessDeniedReason", str)
	}
	return nil
}

func (e AccessDeniedReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// different methods to control how new users can join an account
type AccountAccessMethod string

const (
	// when a user with the same email-domain as the account authorized domain is registered, it will be automatically added to this account (an accountEmailDomain need to be configured)
	AccountAccessMethodAuthorizedDomain AccountAccessMethod = "AUTHORIZED_DOMAIN"
	// new users can only be added to the account if they are invited
	AccountAccessMethodInviteOnly AccountAccessMethod = "INVITE_ONLY"
	// an identity provider will be used to provide new users access to this account (an accountEmailDomain need to be configured)
	AccountAccessMethodSso AccountAccessMethod = "SSO"
)

var AllAccountAccessMethod = []AccountAccessMethod{
	AccountAccessMethodAuthorizedDomain,
	AccountAccessMethodInviteOnly,
	AccountAccessMethodSso,
}

func (e AccountAccessMethod) IsValid() bool {
	switch e {
	case AccountAccessMethodAuthorizedDomain, AccountAccessMethodInviteOnly, AccountAccessMethodSso:
		return true
	}
	return false
}

func (e AccountAccessMethod) String() string {
	return string(e)
}

func (e *AccountAccessMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountAccessMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountAccessMethod", str)
	}
	return nil
}

func (e AccountAccessMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Account access role of the user
type AccountAccessRole string

const (
	// User can view and manage environments they have been granted access to
	AccountAccessRoleMember AccountAccessRole = "MEMBER"
	// User has full ownership and control over the account
	AccountAccessRoleOwner AccountAccessRole = "OWNER"
)

var AllAccountAccessRole = []AccountAccessRole{
	AccountAccessRoleMember,
	AccountAccessRoleOwner,
}

func (e AccountAccessRole) IsValid() bool {
	switch e {
	case AccountAccessRoleMember, AccountAccessRoleOwner:
		return true
	}
	return false
}

func (e AccountAccessRole) String() string {
	return string(e)
}

func (e *AccountAccessRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountAccessRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountAccessRole", str)
	}
	return nil
}

func (e AccountAccessRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Account status
type AccountStatus string

const (
	// The account is active and in use
	AccountStatusActive AccountStatus = "ACTIVE"
	// The account is blocked and cannot be used
	AccountStatusBlocked AccountStatus = "BLOCKED"
)

var AllAccountStatus = []AccountStatus{
	AccountStatusActive,
	AccountStatusBlocked,
}

func (e AccountStatus) IsValid() bool {
	switch e {
	case AccountStatusActive, AccountStatusBlocked:
		return true
	}
	return false
}

func (e AccountStatus) String() string {
	return string(e)
}

func (e *AccountStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountStatus", str)
	}
	return nil
}

func (e AccountStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AddonSortFields string

const (
	AddonSortFieldsBillingID     AddonSortFields = "billingId"
	AddonSortFieldsCreatedAt     AddonSortFields = "createdAt"
	AddonSortFieldsDescription   AddonSortFields = "description"
	AddonSortFieldsDisplayName   AddonSortFields = "displayName"
	AddonSortFieldsEnvironmentID AddonSortFields = "environmentId"
	AddonSortFieldsID            AddonSortFields = "id"
	AddonSortFieldsIsLatest      AddonSortFields = "isLatest"
	AddonSortFieldsPricingType   AddonSortFields = "pricingType"
	AddonSortFieldsProductID     AddonSortFields = "productId"
	AddonSortFieldsRefID         AddonSortFields = "refId"
	AddonSortFieldsStatus        AddonSortFields = "status"
	AddonSortFieldsUpdatedAt     AddonSortFields = "updatedAt"
	AddonSortFieldsVersionNumber AddonSortFields = "versionNumber"
)

var AllAddonSortFields = []AddonSortFields{
	AddonSortFieldsBillingID,
	AddonSortFieldsCreatedAt,
	AddonSortFieldsDescription,
	AddonSortFieldsDisplayName,
	AddonSortFieldsEnvironmentID,
	AddonSortFieldsID,
	AddonSortFieldsIsLatest,
	AddonSortFieldsPricingType,
	AddonSortFieldsProductID,
	AddonSortFieldsRefID,
	AddonSortFieldsStatus,
	AddonSortFieldsUpdatedAt,
	AddonSortFieldsVersionNumber,
}

func (e AddonSortFields) IsValid() bool {
	switch e {
	case AddonSortFieldsBillingID, AddonSortFieldsCreatedAt, AddonSortFieldsDescription, AddonSortFieldsDisplayName, AddonSortFieldsEnvironmentID, AddonSortFieldsID, AddonSortFieldsIsLatest, AddonSortFieldsPricingType, AddonSortFieldsProductID, AddonSortFieldsRefID, AddonSortFieldsStatus, AddonSortFieldsUpdatedAt, AddonSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e AddonSortFields) String() string {
	return string(e)
}

func (e *AddonSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddonSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddonSortFields", str)
	}
	return nil
}

func (e AddonSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Aggregation function
type AggregationFunction string

const (
	// Average value
	AggregationFunctionAvg AggregationFunction = "AVG"
	// Count of the values
	AggregationFunctionCount AggregationFunction = "COUNT"
	// Maximum value
	AggregationFunctionMax AggregationFunction = "MAX"
	// Minimum value
	AggregationFunctionMin AggregationFunction = "MIN"
	// Sum of the values
	AggregationFunctionSum AggregationFunction = "SUM"
	// Unique values
	AggregationFunctionUnique AggregationFunction = "UNIQUE"
)

var AllAggregationFunction = []AggregationFunction{
	AggregationFunctionAvg,
	AggregationFunctionCount,
	AggregationFunctionMax,
	AggregationFunctionMin,
	AggregationFunctionSum,
	AggregationFunctionUnique,
}

func (e AggregationFunction) IsValid() bool {
	switch e {
	case AggregationFunctionAvg, AggregationFunctionCount, AggregationFunctionMax, AggregationFunctionMin, AggregationFunctionSum, AggregationFunctionUnique:
		return true
	}
	return false
}

func (e AggregationFunction) String() string {
	return string(e)
}

func (e *AggregationFunction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregationFunction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregationFunction", str)
	}
	return nil
}

func (e AggregationFunction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Alignment
type Alignment string

const (
	// Align content to the horizontal center of the container.
	AlignmentCenter Alignment = "CENTER"
	// Align content to the left edge of the container.
	AlignmentLeft Alignment = "LEFT"
	// Align content to the right edge of the container.
	AlignmentRight Alignment = "RIGHT"
)

var AllAlignment = []Alignment{
	AlignmentCenter,
	AlignmentLeft,
	AlignmentRight,
}

func (e Alignment) IsValid() bool {
	switch e {
	case AlignmentCenter, AlignmentLeft, AlignmentRight:
		return true
	}
	return false
}

func (e Alignment) String() string {
	return string(e)
}

func (e *Alignment) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Alignment(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Alignment", str)
	}
	return nil
}

func (e Alignment) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type APIKeySortFields string

const (
	APIKeySortFieldsID APIKeySortFields = "id"
)

var AllAPIKeySortFields = []APIKeySortFields{
	APIKeySortFieldsID,
}

func (e APIKeySortFields) IsValid() bool {
	switch e {
	case APIKeySortFieldsID:
		return true
	}
	return false
}

func (e APIKeySortFields) String() string {
	return string(e)
}

func (e *APIKeySortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APIKeySortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApiKeySortFields", str)
	}
	return nil
}

func (e APIKeySortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of API key
type APIKeyType string

const (
	// Client-side API key
	APIKeyTypeClient APIKeyType = "CLIENT"
	// Salesforce API key
	APIKeyTypeSalesforce APIKeyType = "SALESFORCE"
	// Server-side API key
	APIKeyTypeServer APIKeyType = "SERVER"
	// Workflow API key
	APIKeyTypeWorkflow APIKeyType = "WORKFLOW"
)

var AllAPIKeyType = []APIKeyType{
	APIKeyTypeClient,
	APIKeyTypeSalesforce,
	APIKeyTypeServer,
	APIKeyTypeWorkflow,
}

func (e APIKeyType) IsValid() bool {
	switch e {
	case APIKeyTypeClient, APIKeyTypeSalesforce, APIKeyTypeServer, APIKeyTypeWorkflow:
		return true
	}
	return false
}

func (e APIKeyType) String() string {
	return string(e)
}

func (e *APIKeyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APIKeyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApiKeyType", str)
	}
	return nil
}

func (e APIKeyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Auth0 application type
type Auth0ApplicationType string

const (
	// Both individual and organization Auth0 application types
	Auth0ApplicationTypeBoth Auth0ApplicationType = "BOTH"
	// Individual Auth0 application type
	Auth0ApplicationTypeIndividual Auth0ApplicationType = "INDIVIDUAL"
	// Organization Auth0 application type
	Auth0ApplicationTypeOrganization Auth0ApplicationType = "ORGANIZATION"
)

var AllAuth0ApplicationType = []Auth0ApplicationType{
	Auth0ApplicationTypeBoth,
	Auth0ApplicationTypeIndividual,
	Auth0ApplicationTypeOrganization,
}

func (e Auth0ApplicationType) IsValid() bool {
	switch e {
	case Auth0ApplicationTypeBoth, Auth0ApplicationTypeIndividual, Auth0ApplicationTypeOrganization:
		return true
	}
	return false
}

func (e Auth0ApplicationType) String() string {
	return string(e)
}

func (e *Auth0ApplicationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Auth0ApplicationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Auth0ApplicationType", str)
	}
	return nil
}

func (e Auth0ApplicationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing anchor for subscription billing
type BillingAnchor string

const (
	// Billing will be anchored to the start of the month
	BillingAnchorStartOfTheMonth BillingAnchor = "START_OF_THE_MONTH"
	// Subscriptions will consolidate billing to the start of the month
	BillingAnchorSubscriptionsConsolidateBilling BillingAnchor = "SUBSCRIPTIONS_CONSOLIDATE_BILLING"
	// Billing will be anchored to the start of the subscription
	BillingAnchorSubscriptionStart BillingAnchor = "SUBSCRIPTION_START"
)

var AllBillingAnchor = []BillingAnchor{
	BillingAnchorStartOfTheMonth,
	BillingAnchorSubscriptionsConsolidateBilling,
	BillingAnchorSubscriptionStart,
}

func (e BillingAnchor) IsValid() bool {
	switch e {
	case BillingAnchorStartOfTheMonth, BillingAnchorSubscriptionsConsolidateBilling, BillingAnchorSubscriptionStart:
		return true
	}
	return false
}

func (e BillingAnchor) String() string {
	return string(e)
}

func (e *BillingAnchor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingAnchor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingAnchor", str)
	}
	return nil
}

func (e BillingAnchor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing Cadence
type BillingCadence string

const (
	// One off
	BillingCadenceOneOff BillingCadence = "ONE_OFF"
	// Recurring
	BillingCadenceRecurring BillingCadence = "RECURRING"
)

var AllBillingCadence = []BillingCadence{
	BillingCadenceOneOff,
	BillingCadenceRecurring,
}

func (e BillingCadence) IsValid() bool {
	switch e {
	case BillingCadenceOneOff, BillingCadenceRecurring:
		return true
	}
	return false
}

func (e BillingCadence) String() string {
	return string(e)
}

func (e *BillingCadence) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingCadence(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingCadence", str)
	}
	return nil
}

func (e BillingCadence) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing model
type BillingModel string

const (
	// Flat fee
	BillingModelFlatFee BillingModel = "FLAT_FEE"
	// Minimum spend
	BillingModelMinimumSpend BillingModel = "MINIMUM_SPEND"
	// Per unit
	BillingModelPerUnit BillingModel = "PER_UNIT"
	// Usage based
	BillingModelUsageBased BillingModel = "USAGE_BASED"
)

var AllBillingModel = []BillingModel{
	BillingModelFlatFee,
	BillingModelMinimumSpend,
	BillingModelPerUnit,
	BillingModelUsageBased,
}

func (e BillingModel) IsValid() bool {
	switch e {
	case BillingModelFlatFee, BillingModelMinimumSpend, BillingModelPerUnit, BillingModelUsageBased:
		return true
	}
	return false
}

func (e BillingModel) String() string {
	return string(e)
}

func (e *BillingModel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingModel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingModel", str)
	}
	return nil
}

func (e BillingModel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing period
type BillingPeriod string

const (
	// Annually
	BillingPeriodAnnually BillingPeriod = "ANNUALLY"
	// Monthly
	BillingPeriodMonthly BillingPeriod = "MONTHLY"
)

var AllBillingPeriod = []BillingPeriod{
	BillingPeriodAnnually,
	BillingPeriodMonthly,
}

func (e BillingPeriod) IsValid() bool {
	switch e {
	case BillingPeriodAnnually, BillingPeriodMonthly:
		return true
	}
	return false
}

func (e BillingPeriod) String() string {
	return string(e)
}

func (e *BillingPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingPeriod", str)
	}
	return nil
}

func (e BillingPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Billing vendor identifiers
type BillingVendorIdentifier string

const (
	// Stripe
	BillingVendorIdentifierStripe BillingVendorIdentifier = "STRIPE"
)

var AllBillingVendorIdentifier = []BillingVendorIdentifier{
	BillingVendorIdentifierStripe,
}

func (e BillingVendorIdentifier) IsValid() bool {
	switch e {
	case BillingVendorIdentifierStripe:
		return true
	}
	return false
}

func (e BillingVendorIdentifier) String() string {
	return string(e)
}

func (e *BillingVendorIdentifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BillingVendorIdentifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BillingVendorIdentifier", str)
	}
	return nil
}

func (e BillingVendorIdentifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Change type enum
type ChangeType string

const (
	// Added
	ChangeTypeAdded ChangeType = "ADDED"
	// Deleted
	ChangeTypeDeleted ChangeType = "DELETED"
	// Modified
	ChangeTypeModified ChangeType = "MODIFIED"
	// Reordered
	ChangeTypeReordered ChangeType = "REORDERED"
)

var AllChangeType = []ChangeType{
	ChangeTypeAdded,
	ChangeTypeDeleted,
	ChangeTypeModified,
	ChangeTypeReordered,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeAdded, ChangeTypeDeleted, ChangeTypeModified, ChangeTypeReordered:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Condition operation
type ConditionOperation string

const (
	// Equals operation
	ConditionOperationEquals ConditionOperation = "EQUALS"
	// Greater than operation
	ConditionOperationGreaterThan ConditionOperation = "GREATER_THAN"
	// Greater than or equal operation
	ConditionOperationGreaterThanOrEqual ConditionOperation = "GREATER_THAN_OR_EQUAL"
	// Is not null operation
	ConditionOperationIsNotNull ConditionOperation = "IS_NOT_NULL"
	// Is null operation
	ConditionOperationIsNull ConditionOperation = "IS_NULL"
	// Less than operation
	ConditionOperationLessThan ConditionOperation = "LESS_THAN"
	// Less than or equal operation
	ConditionOperationLessThanOrEqual ConditionOperation = "LESS_THAN_OR_EQUAL"
	// Not equals operation
	ConditionOperationNotEquals ConditionOperation = "NOT_EQUALS"
)

var AllConditionOperation = []ConditionOperation{
	ConditionOperationEquals,
	ConditionOperationGreaterThan,
	ConditionOperationGreaterThanOrEqual,
	ConditionOperationIsNotNull,
	ConditionOperationIsNull,
	ConditionOperationLessThan,
	ConditionOperationLessThanOrEqual,
	ConditionOperationNotEquals,
}

func (e ConditionOperation) IsValid() bool {
	switch e {
	case ConditionOperationEquals, ConditionOperationGreaterThan, ConditionOperationGreaterThanOrEqual, ConditionOperationIsNotNull, ConditionOperationIsNull, ConditionOperationLessThan, ConditionOperationLessThanOrEqual, ConditionOperationNotEquals:
		return true
	}
	return false
}

func (e ConditionOperation) String() string {
	return string(e)
}

func (e *ConditionOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperation", str)
	}
	return nil
}

func (e ConditionOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CouponSortFields string

const (
	CouponSortFieldsBillingID     CouponSortFields = "billingId"
	CouponSortFieldsCreatedAt     CouponSortFields = "createdAt"
	CouponSortFieldsDescription   CouponSortFields = "description"
	CouponSortFieldsEnvironmentID CouponSortFields = "environmentId"
	CouponSortFieldsID            CouponSortFields = "id"
	CouponSortFieldsName          CouponSortFields = "name"
	CouponSortFieldsRefID         CouponSortFields = "refId"
	CouponSortFieldsSource        CouponSortFields = "source"
	CouponSortFieldsStatus        CouponSortFields = "status"
	CouponSortFieldsType          CouponSortFields = "type"
	CouponSortFieldsUpdatedAt     CouponSortFields = "updatedAt"
)

var AllCouponSortFields = []CouponSortFields{
	CouponSortFieldsBillingID,
	CouponSortFieldsCreatedAt,
	CouponSortFieldsDescription,
	CouponSortFieldsEnvironmentID,
	CouponSortFieldsID,
	CouponSortFieldsName,
	CouponSortFieldsRefID,
	CouponSortFieldsSource,
	CouponSortFieldsStatus,
	CouponSortFieldsType,
	CouponSortFieldsUpdatedAt,
}

func (e CouponSortFields) IsValid() bool {
	switch e {
	case CouponSortFieldsBillingID, CouponSortFieldsCreatedAt, CouponSortFieldsDescription, CouponSortFieldsEnvironmentID, CouponSortFieldsID, CouponSortFieldsName, CouponSortFieldsRefID, CouponSortFieldsSource, CouponSortFieldsStatus, CouponSortFieldsType, CouponSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e CouponSortFields) String() string {
	return string(e)
}

func (e *CouponSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponSortFields", str)
	}
	return nil
}

func (e CouponSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The source of the coupon
type CouponSource string

const (
	// Stigg
	CouponSourceStigg CouponSource = "STIGG"
	// Stigg adhoc
	CouponSourceStiggAdhoc CouponSource = "STIGG_ADHOC"
	// Stripe
	CouponSourceStripe CouponSource = "STRIPE"
)

var AllCouponSource = []CouponSource{
	CouponSourceStigg,
	CouponSourceStiggAdhoc,
	CouponSourceStripe,
}

func (e CouponSource) IsValid() bool {
	switch e {
	case CouponSourceStigg, CouponSourceStiggAdhoc, CouponSourceStripe:
		return true
	}
	return false
}

func (e CouponSource) String() string {
	return string(e)
}

func (e *CouponSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponSource", str)
	}
	return nil
}

func (e CouponSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the coupon
type CouponStatus string

const (
	// Active
	CouponStatusActive CouponStatus = "ACTIVE"
	// Archived
	CouponStatusArchived CouponStatus = "ARCHIVED"
)

var AllCouponStatus = []CouponStatus{
	CouponStatusActive,
	CouponStatusArchived,
}

func (e CouponStatus) IsValid() bool {
	switch e {
	case CouponStatusActive, CouponStatusArchived:
		return true
	}
	return false
}

func (e CouponStatus) String() string {
	return string(e)
}

func (e *CouponStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponStatus", str)
	}
	return nil
}

func (e CouponStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the coupon
type CouponType string

const (
	// Fixed
	CouponTypeFixed CouponType = "FIXED"
	// Percentage
	CouponTypePercentage CouponType = "PERCENTAGE"
)

var AllCouponType = []CouponType{
	CouponTypeFixed,
	CouponTypePercentage,
}

func (e CouponType) IsValid() bool {
	switch e {
	case CouponTypeFixed, CouponTypePercentage:
		return true
	}
	return false
}

func (e CouponType) String() string {
	return string(e)
}

func (e *CouponType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponType", str)
	}
	return nil
}

func (e CouponType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Currency
type Currency string

const (
	// UAE Dirham
	CurrencyAed Currency = "AED"
	// Lek
	CurrencyAll Currency = "ALL"
	// Armenian Dram
	CurrencyAmd Currency = "AMD"
	// Netherlands Antillean Guilder
	CurrencyAng Currency = "ANG"
	// Australian Dollar
	CurrencyAud Currency = "AUD"
	// Aruban Florin
	CurrencyAwg Currency = "AWG"
	// Azerbaijanian Manat
	CurrencyAzn Currency = "AZN"
	// Convertible Mark
	CurrencyBam Currency = "BAM"
	// Barbados Dollar
	CurrencyBbd Currency = "BBD"
	// Taka
	CurrencyBdt Currency = "BDT"
	// Bulgarian Lev
	CurrencyBgn Currency = "BGN"
	// Burundi Franc
	CurrencyBif Currency = "BIF"
	// Bermudian Dollar
	CurrencyBmd Currency = "BMD"
	// Brunei Dollar
	CurrencyBnd Currency = "BND"
	// Brazilian Real
	CurrencyBrl Currency = "BRL"
	// Bahamian Dollar
	CurrencyBsd Currency = "BSD"
	// Pula
	CurrencyBwp Currency = "BWP"
	// Belarusian Ruble
	CurrencyByn Currency = "BYN"
	// Belize Dollar
	CurrencyBzd Currency = "BZD"
	// Canadian Dollar
	CurrencyCad Currency = "CAD"
	// Congolese Franc
	CurrencyCdf Currency = "CDF"
	// Swiss Franc
	CurrencyChf Currency = "CHF"
	// Chilean Peso
	CurrencyClp Currency = "CLP"
	// Yuan Renminbi
	CurrencyCny Currency = "CNY"
	// Czech Koruna
	CurrencyCzk Currency = "CZK"
	// Djibouti Franc
	CurrencyDjf Currency = "DJF"
	// Danish Krone
	CurrencyDkk Currency = "DKK"
	// Dominican Peso
	CurrencyDop Currency = "DOP"
	// Algerian Dinar
	CurrencyDzd Currency = "DZD"
	// Egyptian Pound
	CurrencyEgp Currency = "EGP"
	// Ethiopian Birr
	CurrencyEtb Currency = "ETB"
	// Euro
	CurrencyEur Currency = "EUR"
	// Fiji Dollar
	CurrencyFjd Currency = "FJD"
	// Pound Sterling
	CurrencyGbp Currency = "GBP"
	// Lari
	CurrencyGel Currency = "GEL"
	// Gibraltar Pound
	CurrencyGip Currency = "GIP"
	// Dalasi
	CurrencyGmd Currency = "GMD"
	// Guinea Franc
	CurrencyGnf Currency = "GNF"
	// Guyana Dollar
	CurrencyGyd Currency = "GYD"
	// Hong Kong Dollar
	CurrencyHkd Currency = "HKD"
	// Kuna
	CurrencyHrk Currency = "HRK"
	// Gourde
	CurrencyHtg Currency = "HTG"
	// Rupiah
	CurrencyIDR Currency = "IDR"
	// New Israeli Sheqel
	CurrencyIls Currency = "ILS"
	// Indian Rupee
	CurrencyInr Currency = "INR"
	// Iceland Krona
	CurrencyIsk Currency = "ISK"
	// Jamaican Dollar
	CurrencyJmd Currency = "JMD"
	// Yen
	CurrencyJpy Currency = "JPY"
	// Kenyan Shilling
	CurrencyKes Currency = "KES"
	// Som
	CurrencyKgs Currency = "KGS"
	// Riel
	CurrencyKhr Currency = "KHR"
	// Comoro Franc
	CurrencyKmf Currency = "KMF"
	// Won
	CurrencyKrw Currency = "KRW"
	// Cayman Islands Dollar
	CurrencyKyd Currency = "KYD"
	// Tenge
	CurrencyKzt Currency = "KZT"
	// Lebanese Pound
	CurrencyLbp Currency = "LBP"
	// Sri Lanka Rupee
	CurrencyLkr Currency = "LKR"
	// Liberian Dollar
	CurrencyLrd Currency = "LRD"
	// Loti
	CurrencyLsl Currency = "LSL"
	// Moroccan Dirham
	CurrencyMad Currency = "MAD"
	// Moldovan Leu
	CurrencyMdl Currency = "MDL"
	// Malagasy Ariary
	CurrencyMga Currency = "MGA"
	// Denar
	CurrencyMkd Currency = "MKD"
	// Kyat
	CurrencyMmk Currency = "MMK"
	// Tugrik
	CurrencyMnt Currency = "MNT"
	// Pataca
	CurrencyMop Currency = "MOP"
	// Ouguiya
	CurrencyMro Currency = "MRO"
	// Rufiyaa
	CurrencyMvr Currency = "MVR"
	// Malawi Kwacha
	CurrencyMwk Currency = "MWK"
	// Mexican Peso
	CurrencyMxn Currency = "MXN"
	// Malaysian Ringgit
	CurrencyMyr Currency = "MYR"
	// Mozambique Metical
	CurrencyMzn Currency = "MZN"
	// Namibia Dollar
	CurrencyNad Currency = "NAD"
	// Naira
	CurrencyNgn Currency = "NGN"
	// Norwegian Krone
	CurrencyNok Currency = "NOK"
	// Nepalese Rupee
	CurrencyNpr Currency = "NPR"
	// New Zealand Dollar
	CurrencyNzd Currency = "NZD"
	// Kina
	CurrencyPgk Currency = "PGK"
	// Philippine Peso
	CurrencyPhp Currency = "PHP"
	// Pakistan Rupee
	CurrencyPkr Currency = "PKR"
	// Zloty
	CurrencyPln Currency = "PLN"
	// Guarani
	CurrencyPyg Currency = "PYG"
	// Qatari Rial
	CurrencyQar Currency = "QAR"
	// Romanian Leu
	CurrencyRon Currency = "RON"
	// Serbian Dinar
	CurrencyRsd Currency = "RSD"
	// Russian Ruble
	CurrencyRub Currency = "RUB"
	// Rwanda Franc
	CurrencyRwf Currency = "RWF"
	// Saudi Riyal
	CurrencySar Currency = "SAR"
	// Solomon Islands Dollar
	CurrencySbd Currency = "SBD"
	// Seychelles Rupee
	CurrencyScr Currency = "SCR"
	// Swedish Krona
	CurrencySek Currency = "SEK"
	// Singapore Dollar
	CurrencySgd Currency = "SGD"
	// Unknown or special currency code
	CurrencySle Currency = "SLE"
	// Leone
	CurrencySll Currency = "SLL"
	// Somali Shilling
	CurrencySos Currency = "SOS"
	// Lilangeni
	CurrencySzl Currency = "SZL"
	// Baht
	CurrencyThb Currency = "THB"
	// Somoni
	CurrencyTjs Currency = "TJS"
	// Paanga
	CurrencyTop Currency = "TOP"
	// Turkish Lira
	CurrencyTry Currency = "TRY"
	// Trinidad and Tobago Dollar
	CurrencyTtd Currency = "TTD"
	// Tanzanian Shilling
	CurrencyTzs Currency = "TZS"
	// Hryvnia
	CurrencyUah Currency = "UAH"
	// Uganda Shilling
	CurrencyUgx Currency = "UGX"
	// US Dollar
	CurrencyUsd Currency = "USD"
	// Uzbekistan Sum
	CurrencyUzs Currency = "UZS"
	// Dong
	CurrencyVnd Currency = "VND"
	// Vatu
	CurrencyVuv Currency = "VUV"
	// Tala
	CurrencyWst Currency = "WST"
	// CFA Franc BEAC
	CurrencyXaf Currency = "XAF"
	// East Caribbean Dollar
	CurrencyXcd Currency = "XCD"
	// CFA Franc BCEAO
	CurrencyXof Currency = "XOF"
	// CFP Franc
	CurrencyXpf Currency = "XPF"
	// Yemeni Rial
	CurrencyYer Currency = "YER"
	// Rand
	CurrencyZar Currency = "ZAR"
	// Zambian Kwacha
	CurrencyZmw Currency = "ZMW"
)

var AllCurrency = []Currency{
	CurrencyAed,
	CurrencyAll,
	CurrencyAmd,
	CurrencyAng,
	CurrencyAud,
	CurrencyAwg,
	CurrencyAzn,
	CurrencyBam,
	CurrencyBbd,
	CurrencyBdt,
	CurrencyBgn,
	CurrencyBif,
	CurrencyBmd,
	CurrencyBnd,
	CurrencyBrl,
	CurrencyBsd,
	CurrencyBwp,
	CurrencyByn,
	CurrencyBzd,
	CurrencyCad,
	CurrencyCdf,
	CurrencyChf,
	CurrencyClp,
	CurrencyCny,
	CurrencyCzk,
	CurrencyDjf,
	CurrencyDkk,
	CurrencyDop,
	CurrencyDzd,
	CurrencyEgp,
	CurrencyEtb,
	CurrencyEur,
	CurrencyFjd,
	CurrencyGbp,
	CurrencyGel,
	CurrencyGip,
	CurrencyGmd,
	CurrencyGnf,
	CurrencyGyd,
	CurrencyHkd,
	CurrencyHrk,
	CurrencyHtg,
	CurrencyIDR,
	CurrencyIls,
	CurrencyInr,
	CurrencyIsk,
	CurrencyJmd,
	CurrencyJpy,
	CurrencyKes,
	CurrencyKgs,
	CurrencyKhr,
	CurrencyKmf,
	CurrencyKrw,
	CurrencyKyd,
	CurrencyKzt,
	CurrencyLbp,
	CurrencyLkr,
	CurrencyLrd,
	CurrencyLsl,
	CurrencyMad,
	CurrencyMdl,
	CurrencyMga,
	CurrencyMkd,
	CurrencyMmk,
	CurrencyMnt,
	CurrencyMop,
	CurrencyMro,
	CurrencyMvr,
	CurrencyMwk,
	CurrencyMxn,
	CurrencyMyr,
	CurrencyMzn,
	CurrencyNad,
	CurrencyNgn,
	CurrencyNok,
	CurrencyNpr,
	CurrencyNzd,
	CurrencyPgk,
	CurrencyPhp,
	CurrencyPkr,
	CurrencyPln,
	CurrencyPyg,
	CurrencyQar,
	CurrencyRon,
	CurrencyRsd,
	CurrencyRub,
	CurrencyRwf,
	CurrencySar,
	CurrencySbd,
	CurrencyScr,
	CurrencySek,
	CurrencySgd,
	CurrencySle,
	CurrencySll,
	CurrencySos,
	CurrencySzl,
	CurrencyThb,
	CurrencyTjs,
	CurrencyTop,
	CurrencyTry,
	CurrencyTtd,
	CurrencyTzs,
	CurrencyUah,
	CurrencyUgx,
	CurrencyUsd,
	CurrencyUzs,
	CurrencyVnd,
	CurrencyVuv,
	CurrencyWst,
	CurrencyXaf,
	CurrencyXcd,
	CurrencyXof,
	CurrencyXpf,
	CurrencyYer,
	CurrencyZar,
	CurrencyZmw,
}

func (e Currency) IsValid() bool {
	switch e {
	case CurrencyAed, CurrencyAll, CurrencyAmd, CurrencyAng, CurrencyAud, CurrencyAwg, CurrencyAzn, CurrencyBam, CurrencyBbd, CurrencyBdt, CurrencyBgn, CurrencyBif, CurrencyBmd, CurrencyBnd, CurrencyBrl, CurrencyBsd, CurrencyBwp, CurrencyByn, CurrencyBzd, CurrencyCad, CurrencyCdf, CurrencyChf, CurrencyClp, CurrencyCny, CurrencyCzk, CurrencyDjf, CurrencyDkk, CurrencyDop, CurrencyDzd, CurrencyEgp, CurrencyEtb, CurrencyEur, CurrencyFjd, CurrencyGbp, CurrencyGel, CurrencyGip, CurrencyGmd, CurrencyGnf, CurrencyGyd, CurrencyHkd, CurrencyHrk, CurrencyHtg, CurrencyIDR, CurrencyIls, CurrencyInr, CurrencyIsk, CurrencyJmd, CurrencyJpy, CurrencyKes, CurrencyKgs, CurrencyKhr, CurrencyKmf, CurrencyKrw, CurrencyKyd, CurrencyKzt, CurrencyLbp, CurrencyLkr, CurrencyLrd, CurrencyLsl, CurrencyMad, CurrencyMdl, CurrencyMga, CurrencyMkd, CurrencyMmk, CurrencyMnt, CurrencyMop, CurrencyMro, CurrencyMvr, CurrencyMwk, CurrencyMxn, CurrencyMyr, CurrencyMzn, CurrencyNad, CurrencyNgn, CurrencyNok, CurrencyNpr, CurrencyNzd, CurrencyPgk, CurrencyPhp, CurrencyPkr, CurrencyPln, CurrencyPyg, CurrencyQar, CurrencyRon, CurrencyRsd, CurrencyRub, CurrencyRwf, CurrencySar, CurrencySbd, CurrencyScr, CurrencySek, CurrencySgd, CurrencySle, CurrencySll, CurrencySos, CurrencySzl, CurrencyThb, CurrencyTjs, CurrencyTop, CurrencyTry, CurrencyTtd, CurrencyTzs, CurrencyUah, CurrencyUgx, CurrencyUsd, CurrencyUzs, CurrencyVnd, CurrencyVuv, CurrencyWst, CurrencyXaf, CurrencyXcd, CurrencyXof, CurrencyXpf, CurrencyYer, CurrencyZar, CurrencyZmw:
		return true
	}
	return false
}

func (e Currency) String() string {
	return string(e)
}

func (e *Currency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Currency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Currency", str)
	}
	return nil
}

func (e Currency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerResourceSortFields string

const (
	CustomerResourceSortFieldsCreatedAt     CustomerResourceSortFields = "createdAt"
	CustomerResourceSortFieldsEnvironmentID CustomerResourceSortFields = "environmentId"
	CustomerResourceSortFieldsResourceID    CustomerResourceSortFields = "resourceId"
)

var AllCustomerResourceSortFields = []CustomerResourceSortFields{
	CustomerResourceSortFieldsCreatedAt,
	CustomerResourceSortFieldsEnvironmentID,
	CustomerResourceSortFieldsResourceID,
}

func (e CustomerResourceSortFields) IsValid() bool {
	switch e {
	case CustomerResourceSortFieldsCreatedAt, CustomerResourceSortFieldsEnvironmentID, CustomerResourceSortFieldsResourceID:
		return true
	}
	return false
}

func (e CustomerResourceSortFields) String() string {
	return string(e)
}

func (e *CustomerResourceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerResourceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerResourceSortFields", str)
	}
	return nil
}

func (e CustomerResourceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerSortFields string

const (
	CustomerSortFieldsBillingID            CustomerSortFields = "billingId"
	CustomerSortFieldsCreatedAt            CustomerSortFields = "createdAt"
	CustomerSortFieldsCrmHubspotCompanyID  CustomerSortFields = "crmHubspotCompanyId"
	CustomerSortFieldsCrmHubspotCompanyURL CustomerSortFields = "crmHubspotCompanyUrl"
	CustomerSortFieldsCrmID                CustomerSortFields = "crmId"
	CustomerSortFieldsCustomerID           CustomerSortFields = "customerId"
	CustomerSortFieldsDeletedAt            CustomerSortFields = "deletedAt"
	CustomerSortFieldsEmail                CustomerSortFields = "email"
	CustomerSortFieldsEnvironmentID        CustomerSortFields = "environmentId"
	CustomerSortFieldsID                   CustomerSortFields = "id"
	CustomerSortFieldsName                 CustomerSortFields = "name"
	CustomerSortFieldsRefID                CustomerSortFields = "refId"
	CustomerSortFieldsSalesforceID         CustomerSortFields = "salesforceId"
	CustomerSortFieldsSearchQuery          CustomerSortFields = "searchQuery"
	CustomerSortFieldsUpdatedAt            CustomerSortFields = "updatedAt"
)

var AllCustomerSortFields = []CustomerSortFields{
	CustomerSortFieldsBillingID,
	CustomerSortFieldsCreatedAt,
	CustomerSortFieldsCrmHubspotCompanyID,
	CustomerSortFieldsCrmHubspotCompanyURL,
	CustomerSortFieldsCrmID,
	CustomerSortFieldsCustomerID,
	CustomerSortFieldsDeletedAt,
	CustomerSortFieldsEmail,
	CustomerSortFieldsEnvironmentID,
	CustomerSortFieldsID,
	CustomerSortFieldsName,
	CustomerSortFieldsRefID,
	CustomerSortFieldsSalesforceID,
	CustomerSortFieldsSearchQuery,
	CustomerSortFieldsUpdatedAt,
}

func (e CustomerSortFields) IsValid() bool {
	switch e {
	case CustomerSortFieldsBillingID, CustomerSortFieldsCreatedAt, CustomerSortFieldsCrmHubspotCompanyID, CustomerSortFieldsCrmHubspotCompanyURL, CustomerSortFieldsCrmID, CustomerSortFieldsCustomerID, CustomerSortFieldsDeletedAt, CustomerSortFieldsEmail, CustomerSortFieldsEnvironmentID, CustomerSortFieldsID, CustomerSortFieldsName, CustomerSortFieldsRefID, CustomerSortFieldsSalesforceID, CustomerSortFieldsSearchQuery, CustomerSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e CustomerSortFields) String() string {
	return string(e)
}

func (e *CustomerSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSortFields", str)
	}
	return nil
}

func (e CustomerSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerSubscriptionSortFields string

const (
	CustomerSubscriptionSortFieldsBillingCycleAnchor        CustomerSubscriptionSortFields = "billingCycleAnchor"
	CustomerSubscriptionSortFieldsBillingID                 CustomerSubscriptionSortFields = "billingId"
	CustomerSubscriptionSortFieldsCancelReason              CustomerSubscriptionSortFields = "cancelReason"
	CustomerSubscriptionSortFieldsCancellationDate          CustomerSubscriptionSortFields = "cancellationDate"
	CustomerSubscriptionSortFieldsCreatedAt                 CustomerSubscriptionSortFields = "createdAt"
	CustomerSubscriptionSortFieldsCrmID                     CustomerSubscriptionSortFields = "crmId"
	CustomerSubscriptionSortFieldsCrmLinkURL                CustomerSubscriptionSortFields = "crmLinkUrl"
	CustomerSubscriptionSortFieldsCurrentBillingPeriodEnd   CustomerSubscriptionSortFields = "currentBillingPeriodEnd"
	CustomerSubscriptionSortFieldsCurrentBillingPeriodStart CustomerSubscriptionSortFields = "currentBillingPeriodStart"
	CustomerSubscriptionSortFieldsCustomerID                CustomerSubscriptionSortFields = "customerId"
	CustomerSubscriptionSortFieldsEffectiveEndDate          CustomerSubscriptionSortFields = "effectiveEndDate"
	CustomerSubscriptionSortFieldsEndDate                   CustomerSubscriptionSortFields = "endDate"
	CustomerSubscriptionSortFieldsEnvironmentID             CustomerSubscriptionSortFields = "environmentId"
	CustomerSubscriptionSortFieldsID                        CustomerSubscriptionSortFields = "id"
	CustomerSubscriptionSortFieldsOldBillingID              CustomerSubscriptionSortFields = "oldBillingId"
	CustomerSubscriptionSortFieldsPayingCustomerID          CustomerSubscriptionSortFields = "payingCustomerId"
	CustomerSubscriptionSortFieldsPaymentCollection         CustomerSubscriptionSortFields = "paymentCollection"
	CustomerSubscriptionSortFieldsPricingType               CustomerSubscriptionSortFields = "pricingType"
	CustomerSubscriptionSortFieldsRefID                     CustomerSubscriptionSortFields = "refId"
	CustomerSubscriptionSortFieldsResourceID                CustomerSubscriptionSortFields = "resourceId"
	CustomerSubscriptionSortFieldsSalesforceID              CustomerSubscriptionSortFields = "salesforceId"
	CustomerSubscriptionSortFieldsStartDate                 CustomerSubscriptionSortFields = "startDate"
	CustomerSubscriptionSortFieldsStatus                    CustomerSubscriptionSortFields = "status"
	CustomerSubscriptionSortFieldsSubscriptionID            CustomerSubscriptionSortFields = "subscriptionId"
	CustomerSubscriptionSortFieldsTrialEndDate              CustomerSubscriptionSortFields = "trialEndDate"
)

var AllCustomerSubscriptionSortFields = []CustomerSubscriptionSortFields{
	CustomerSubscriptionSortFieldsBillingCycleAnchor,
	CustomerSubscriptionSortFieldsBillingID,
	CustomerSubscriptionSortFieldsCancelReason,
	CustomerSubscriptionSortFieldsCancellationDate,
	CustomerSubscriptionSortFieldsCreatedAt,
	CustomerSubscriptionSortFieldsCrmID,
	CustomerSubscriptionSortFieldsCrmLinkURL,
	CustomerSubscriptionSortFieldsCurrentBillingPeriodEnd,
	CustomerSubscriptionSortFieldsCurrentBillingPeriodStart,
	CustomerSubscriptionSortFieldsCustomerID,
	CustomerSubscriptionSortFieldsEffectiveEndDate,
	CustomerSubscriptionSortFieldsEndDate,
	CustomerSubscriptionSortFieldsEnvironmentID,
	CustomerSubscriptionSortFieldsID,
	CustomerSubscriptionSortFieldsOldBillingID,
	CustomerSubscriptionSortFieldsPayingCustomerID,
	CustomerSubscriptionSortFieldsPaymentCollection,
	CustomerSubscriptionSortFieldsPricingType,
	CustomerSubscriptionSortFieldsRefID,
	CustomerSubscriptionSortFieldsResourceID,
	CustomerSubscriptionSortFieldsSalesforceID,
	CustomerSubscriptionSortFieldsStartDate,
	CustomerSubscriptionSortFieldsStatus,
	CustomerSubscriptionSortFieldsSubscriptionID,
	CustomerSubscriptionSortFieldsTrialEndDate,
}

func (e CustomerSubscriptionSortFields) IsValid() bool {
	switch e {
	case CustomerSubscriptionSortFieldsBillingCycleAnchor, CustomerSubscriptionSortFieldsBillingID, CustomerSubscriptionSortFieldsCancelReason, CustomerSubscriptionSortFieldsCancellationDate, CustomerSubscriptionSortFieldsCreatedAt, CustomerSubscriptionSortFieldsCrmID, CustomerSubscriptionSortFieldsCrmLinkURL, CustomerSubscriptionSortFieldsCurrentBillingPeriodEnd, CustomerSubscriptionSortFieldsCurrentBillingPeriodStart, CustomerSubscriptionSortFieldsCustomerID, CustomerSubscriptionSortFieldsEffectiveEndDate, CustomerSubscriptionSortFieldsEndDate, CustomerSubscriptionSortFieldsEnvironmentID, CustomerSubscriptionSortFieldsID, CustomerSubscriptionSortFieldsOldBillingID, CustomerSubscriptionSortFieldsPayingCustomerID, CustomerSubscriptionSortFieldsPaymentCollection, CustomerSubscriptionSortFieldsPricingType, CustomerSubscriptionSortFieldsRefID, CustomerSubscriptionSortFieldsResourceID, CustomerSubscriptionSortFieldsSalesforceID, CustomerSubscriptionSortFieldsStartDate, CustomerSubscriptionSortFieldsStatus, CustomerSubscriptionSortFieldsSubscriptionID, CustomerSubscriptionSortFieldsTrialEndDate:
		return true
	}
	return false
}

func (e CustomerSubscriptionSortFields) String() string {
	return string(e)
}

func (e *CustomerSubscriptionSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSubscriptionSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSubscriptionSortFields", str)
	}
	return nil
}

func (e CustomerSubscriptionSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The department the user belongs to
type Department string

const (
	// CEO or Founder
	DepartmentCeoOrFounder Department = "CEO_OR_FOUNDER"
	// Engineering
	DepartmentEngineering Department = "ENGINEERING"
	// Growth
	DepartmentGrowth Department = "GROWTH"
	// Marketing
	DepartmentMarketing Department = "MARKETING"
	// Monetization
	DepartmentMonetization Department = "MONETIZATION"
	// Other
	DepartmentOther Department = "OTHER"
	// Product
	DepartmentProduct Department = "PRODUCT"
)

var AllDepartment = []Department{
	DepartmentCeoOrFounder,
	DepartmentEngineering,
	DepartmentGrowth,
	DepartmentMarketing,
	DepartmentMonetization,
	DepartmentOther,
	DepartmentProduct,
}

func (e Department) IsValid() bool {
	switch e {
	case DepartmentCeoOrFounder, DepartmentEngineering, DepartmentGrowth, DepartmentMarketing, DepartmentMonetization, DepartmentOther, DepartmentProduct:
		return true
	}
	return false
}

func (e Department) String() string {
	return string(e)
}

func (e *Department) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Department(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Department", str)
	}
	return nil
}

func (e Department) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the discount duration
type DiscountDurationType string

const (
	DiscountDurationTypeForever   DiscountDurationType = "FOREVER"
	DiscountDurationTypeOnce      DiscountDurationType = "ONCE"
	DiscountDurationTypeRepeating DiscountDurationType = "REPEATING"
)

var AllDiscountDurationType = []DiscountDurationType{
	DiscountDurationTypeForever,
	DiscountDurationTypeOnce,
	DiscountDurationTypeRepeating,
}

func (e DiscountDurationType) IsValid() bool {
	switch e {
	case DiscountDurationTypeForever, DiscountDurationTypeOnce, DiscountDurationTypeRepeating:
		return true
	}
	return false
}

func (e DiscountDurationType) String() string {
	return string(e)
}

func (e *DiscountDurationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountDurationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountDurationType", str)
	}
	return nil
}

func (e DiscountDurationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the discount
type DiscountType string

const (
	DiscountTypeFixed      DiscountType = "FIXED"
	DiscountTypePercentage DiscountType = "PERCENTAGE"
)

var AllDiscountType = []DiscountType{
	DiscountTypeFixed,
	DiscountTypePercentage,
}

func (e DiscountType) IsValid() bool {
	switch e {
	case DiscountTypeFixed, DiscountTypePercentage:
		return true
	}
	return false
}

func (e DiscountType) String() string {
	return string(e)
}

func (e *DiscountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountType", str)
	}
	return nil
}

func (e DiscountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The behavior of the entitlement
type EntitlementBehavior string

const (
	// Increment the value of the entitlement
	EntitlementBehaviorIncrement EntitlementBehavior = "Increment"
	// Override the value of the entitlement
	EntitlementBehaviorOverride EntitlementBehavior = "Override"
)

var AllEntitlementBehavior = []EntitlementBehavior{
	EntitlementBehaviorIncrement,
	EntitlementBehaviorOverride,
}

func (e EntitlementBehavior) IsValid() bool {
	switch e {
	case EntitlementBehaviorIncrement, EntitlementBehaviorOverride:
		return true
	}
	return false
}

func (e EntitlementBehavior) String() string {
	return string(e)
}

func (e *EntitlementBehavior) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitlementBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitlementBehavior", str)
	}
	return nil
}

func (e EntitlementBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Entitlement reset period
type EntitlementResetPeriod string

const (
	// Day
	EntitlementResetPeriodDay EntitlementResetPeriod = "DAY"
	// Hour
	EntitlementResetPeriodHour EntitlementResetPeriod = "HOUR"
	// Month
	EntitlementResetPeriodMonth EntitlementResetPeriod = "MONTH"
	// Week
	EntitlementResetPeriodWeek EntitlementResetPeriod = "WEEK"
	// Year
	EntitlementResetPeriodYear EntitlementResetPeriod = "YEAR"
)

var AllEntitlementResetPeriod = []EntitlementResetPeriod{
	EntitlementResetPeriodDay,
	EntitlementResetPeriodHour,
	EntitlementResetPeriodMonth,
	EntitlementResetPeriodWeek,
	EntitlementResetPeriodYear,
}

func (e EntitlementResetPeriod) IsValid() bool {
	switch e {
	case EntitlementResetPeriodDay, EntitlementResetPeriodHour, EntitlementResetPeriodMonth, EntitlementResetPeriodWeek, EntitlementResetPeriodYear:
		return true
	}
	return false
}

func (e EntitlementResetPeriod) String() string {
	return string(e)
}

func (e *EntitlementResetPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitlementResetPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitlementResetPeriod", str)
	}
	return nil
}

func (e EntitlementResetPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Mode for selecting which entities to import
type EntitySelectionMode string

const (
	// Exclude specified entities from import
	EntitySelectionModeBlackList EntitySelectionMode = "BLACK_LIST"
	// Only import specified entities
	EntitySelectionModeWhiteList EntitySelectionMode = "WHITE_LIST"
)

var AllEntitySelectionMode = []EntitySelectionMode{
	EntitySelectionModeBlackList,
	EntitySelectionModeWhiteList,
}

func (e EntitySelectionMode) IsValid() bool {
	switch e {
	case EntitySelectionModeBlackList, EntitySelectionModeWhiteList:
		return true
	}
	return false
}

func (e EntitySelectionMode) String() string {
	return string(e)
}

func (e *EntitySelectionMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitySelectionMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitySelectionMode", str)
	}
	return nil
}

func (e EntitySelectionMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Environment access role of the user
type EnvironmentAccessRole string

const (
	// User has administrative access to the environment
	EnvironmentAccessRoleAdmin EnvironmentAccessRole = "ADMIN"
	// User has no access to the environment
	EnvironmentAccessRoleNone EnvironmentAccessRole = "NONE"
	// User has support-level access to the environment to manage customers and subscriptions
	EnvironmentAccessRoleSupport EnvironmentAccessRole = "SUPPORT"
	// User has read-only access to the environment
	EnvironmentAccessRoleViewer EnvironmentAccessRole = "VIEWER"
)

var AllEnvironmentAccessRole = []EnvironmentAccessRole{
	EnvironmentAccessRoleAdmin,
	EnvironmentAccessRoleNone,
	EnvironmentAccessRoleSupport,
	EnvironmentAccessRoleViewer,
}

func (e EnvironmentAccessRole) IsValid() bool {
	switch e {
	case EnvironmentAccessRoleAdmin, EnvironmentAccessRoleNone, EnvironmentAccessRoleSupport, EnvironmentAccessRoleViewer:
		return true
	}
	return false
}

func (e EnvironmentAccessRole) String() string {
	return string(e)
}

func (e *EnvironmentAccessRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentAccessRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentAccessRole", str)
	}
	return nil
}

func (e EnvironmentAccessRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the provisioning status of an environment
type EnvironmentProvisionStatus string

const (
	// The environment has been successfully provisioned
	EnvironmentProvisionStatusDone EnvironmentProvisionStatus = "DONE"
	// The environment provisioning process has failed
	EnvironmentProvisionStatusFailed EnvironmentProvisionStatus = "FAILED"
	// The environment provisioning process is currently in progress
	EnvironmentProvisionStatusInProgress EnvironmentProvisionStatus = "IN_PROGRESS"
	// The environment has not yet started the provisioning process
	EnvironmentProvisionStatusNotProvisioned EnvironmentProvisionStatus = "NOT_PROVISIONED"
)

var AllEnvironmentProvisionStatus = []EnvironmentProvisionStatus{
	EnvironmentProvisionStatusDone,
	EnvironmentProvisionStatusFailed,
	EnvironmentProvisionStatusInProgress,
	EnvironmentProvisionStatusNotProvisioned,
}

func (e EnvironmentProvisionStatus) IsValid() bool {
	switch e {
	case EnvironmentProvisionStatusDone, EnvironmentProvisionStatusFailed, EnvironmentProvisionStatusInProgress, EnvironmentProvisionStatusNotProvisioned:
		return true
	}
	return false
}

func (e EnvironmentProvisionStatus) String() string {
	return string(e)
}

func (e *EnvironmentProvisionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentProvisionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentProvisionStatus", str)
	}
	return nil
}

func (e EnvironmentProvisionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EnvironmentSortFields string

const (
	EnvironmentSortFieldsCreatedAt             EnvironmentSortFields = "createdAt"
	EnvironmentSortFieldsDisplayName           EnvironmentSortFields = "displayName"
	EnvironmentSortFieldsID                    EnvironmentSortFields = "id"
	EnvironmentSortFieldsPermanentDeletionDate EnvironmentSortFields = "permanentDeletionDate"
	EnvironmentSortFieldsSlug                  EnvironmentSortFields = "slug"
)

var AllEnvironmentSortFields = []EnvironmentSortFields{
	EnvironmentSortFieldsCreatedAt,
	EnvironmentSortFieldsDisplayName,
	EnvironmentSortFieldsID,
	EnvironmentSortFieldsPermanentDeletionDate,
	EnvironmentSortFieldsSlug,
}

func (e EnvironmentSortFields) IsValid() bool {
	switch e {
	case EnvironmentSortFieldsCreatedAt, EnvironmentSortFieldsDisplayName, EnvironmentSortFieldsID, EnvironmentSortFieldsPermanentDeletionDate, EnvironmentSortFieldsSlug:
		return true
	}
	return false
}

func (e EnvironmentSortFields) String() string {
	return string(e)
}

func (e *EnvironmentSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentSortFields", str)
	}
	return nil
}

func (e EnvironmentSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// EnvironmentType
type EnvironmentType string

const (
	// Development environment, used for testing and development purposes
	EnvironmentTypeDevelopment EnvironmentType = "DEVELOPMENT"
	// Production environment, used for live applications and services
	EnvironmentTypeProduction EnvironmentType = "PRODUCTION"
	// Sandbox environment, used for isolated testing and experimentation
	EnvironmentTypeSandbox EnvironmentType = "SANDBOX"
)

var AllEnvironmentType = []EnvironmentType{
	EnvironmentTypeDevelopment,
	EnvironmentTypeProduction,
	EnvironmentTypeSandbox,
}

func (e EnvironmentType) IsValid() bool {
	switch e {
	case EnvironmentTypeDevelopment, EnvironmentTypeProduction, EnvironmentTypeSandbox:
		return true
	}
	return false
}

func (e EnvironmentType) String() string {
	return string(e)
}

func (e *EnvironmentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentType", str)
	}
	return nil
}

func (e EnvironmentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// error codes
type ErrorCode string

const (
	ErrorCodeAccessDeniedError    ErrorCode = "AccessDeniedError"
	ErrorCodeAccountNotFoundError ErrorCode = "AccountNotFoundError"
	// Addon dependency missing error
	ErrorCodeAddonDependencyMissingError ErrorCode = "AddonDependencyMissingError"
	ErrorCodeAddonHasToHavePriceError    ErrorCode = "AddonHasToHavePriceError"
	// Cannot delete an addon that is compatible with an addon group
	ErrorCodeAddonIsCompatibleWithGroup ErrorCode = "AddonIsCompatibleWithGroup"
	// Cannot delete an addon that is compatible with a plan
	ErrorCodeAddonIsCompatibleWithPlan ErrorCode = "AddonIsCompatibleWithPlan"
	ErrorCodeAddonNotFound             ErrorCode = "AddonNotFound"
	// Addon quantity exceeds limit error
	ErrorCodeAddonQuantityExceedsLimitError     ErrorCode = "AddonQuantityExceedsLimitError"
	ErrorCodeAddonWithDraftCannotBeDeletedError ErrorCode = "AddonWithDraftCannotBeDeletedError"
	// Multiple addons not found
	ErrorCodeAddonsNotFound              ErrorCode = "AddonsNotFound"
	ErrorCodeAmountTooLarge              ErrorCode = "AmountTooLarge"
	ErrorCodeArchivedCouponCantBeApplied ErrorCode = "ArchivedCouponCantBeApplied"
	// The authenticated customer does not match the customer in the request
	ErrorCodeAuthCustomerMismatch ErrorCode = "AuthCustomerMismatch"
	// The authenticated customer has read-only permissions and cannot perform this operation
	ErrorCodeAuthCustomerReadonly                     ErrorCode = "AuthCustomerReadonly"
	ErrorCodeAwsMarketplaceIntegrationError           ErrorCode = "AwsMarketplaceIntegrationError"
	ErrorCodeAwsMarketplaceIntegrationValidationError ErrorCode = "AwsMarketplaceIntegrationValidationError"
	ErrorCodeBadUserInput                             ErrorCode = "BadUserInput"
	ErrorCodeBillingIntegrationAlreadyExistsError     ErrorCode = "BillingIntegrationAlreadyExistsError"
	ErrorCodeBillingIntegrationMissing                ErrorCode = "BillingIntegrationMissing"
	ErrorCodeBillingPeriodMissingError                ErrorCode = "BillingPeriodMissingError"
	// Cannot update entitlement feature group
	ErrorCodeCanNotUpdateEntitlementsFeatureGroup ErrorCode = "CanNotUpdateEntitlementsFeatureGroup"
	// Cannot add override entitlement to a plan
	ErrorCodeCannotAddOverrideEntitlementToPlan ErrorCode = "CannotAddOverrideEntitlementToPlan"
	ErrorCodeCannotArchiveFeatureError          ErrorCode = "CannotArchiveFeatureError"
	ErrorCodeCannotArchiveFeatureGroupError     ErrorCode = "CannotArchiveFeatureGroupError"
	// Cannot change billing integration at current customer state
	ErrorCodeCannotChangeBillingIntegration ErrorCode = "CannotChangeBillingIntegration"
	ErrorCodeCannotDeleteCustomerError      ErrorCode = "CannotDeleteCustomerError"
	// Deleting the default integration is not allowed
	ErrorCodeCannotDeleteDefaultIntegration                ErrorCode = "CannotDeleteDefaultIntegration"
	ErrorCodeCannotDeleteFeatureError                      ErrorCode = "CannotDeleteFeatureError"
	ErrorCodeCannotDeleteProductError                      ErrorCode = "CannotDeleteProductError"
	ErrorCodeCannotEditPackageInNonDraftMode               ErrorCode = "CannotEditPackageInNonDraftMode"
	ErrorCodeCannotRemovePaymentMethodFromCustomerError    ErrorCode = "CannotRemovePaymentMethodFromCustomerError"
	ErrorCodeCannotReportUsageForEntitlementWithMeterError ErrorCode = "CannotReportUsageForEntitlementWithMeterError"
	// Can not update unit transformation since this feature has connected active subscriptions
	ErrorCodeCannotUpdateUnitTransformationError ErrorCode = "CannotUpdateUnitTransformationError"
	ErrorCodeCannotUpsertToPackageThatHasDraft   ErrorCode = "CannotUpsertToPackageThatHasDraft"
	// Changing paying customer is not supported
	ErrorCodeChangingPayingCustomerIsNotSupportedError ErrorCode = "ChangingPayingCustomerIsNotSupportedError"
	ErrorCodeCheckoutIsNotSupported                    ErrorCode = "CheckoutIsNotSupported"
	ErrorCodeCouponNotFound                            ErrorCode = "CouponNotFound"
	ErrorCodeCustomerAlreadyHaveCustomerCoupon         ErrorCode = "CustomerAlreadyHaveCustomerCoupon"
	ErrorCodeCustomerAlreadyUsesCoupon                 ErrorCode = "CustomerAlreadyUsesCoupon"
	ErrorCodeCustomerHasNoEmailAddress                 ErrorCode = "CustomerHasNoEmailAddress"
	ErrorCodeCustomerNoBillingID                       ErrorCode = "CustomerNoBillingId"
	ErrorCodeCustomerNotFound                          ErrorCode = "CustomerNotFound"
	ErrorCodeCustomerResourceNotFound                  ErrorCode = "CustomerResourceNotFound"
	// Deprecated estimate subscription error
	ErrorCodeDeprecatedEstimateSubscriptionError     ErrorCode = "DeprecatedEstimateSubscriptionError"
	ErrorCodeDowngradeBillingPeriodNotSupportedError ErrorCode = "DowngradeBillingPeriodNotSupportedError"
	// Draft addon cannot be archived
	ErrorCodeDraftAddonCantBeArchived ErrorCode = "DraftAddonCantBeArchived"
	ErrorCodeDraftPlanCantBeArchived  ErrorCode = "DraftPlanCantBeArchived"
	// Duplicate addons provisioned error
	ErrorCodeDuplicateAddonProvisionedError ErrorCode = "DuplicateAddonProvisionedError"
	// Duplicate integration for same non billing vendor identifier not allowed
	ErrorCodeDuplicateIntegrationNotAllowed      ErrorCode = "DuplicateIntegrationNotAllowed"
	ErrorCodeDuplicateProductValidationError     ErrorCode = "DuplicateProductValidationError"
	ErrorCodeDuplicatedEntityNotAllowed          ErrorCode = "DuplicatedEntityNotAllowed"
	ErrorCodeEditAllowedOnDraftPackageOnlyError  ErrorCode = "EditAllowedOnDraftPackageOnlyError"
	ErrorCodeEntitlementLimitExceededError       ErrorCode = "EntitlementLimitExceededError"
	ErrorCodeEntitlementUsageOutOfRangeError     ErrorCode = "EntitlementUsageOutOfRangeError"
	ErrorCodeEntitlementsMustBelongToSamePackage ErrorCode = "EntitlementsMustBelongToSamePackage"
	ErrorCodeEntityIDDifferentFromRefIDError     ErrorCode = "EntityIdDifferentFromRefIdError"
	ErrorCodeEntityIsArchivedError               ErrorCode = "EntityIsArchivedError"
	ErrorCodeEnvironmentMissing                  ErrorCode = "EnvironmentMissing"
	ErrorCodeExperimentAlreadyRunning            ErrorCode = "ExperimentAlreadyRunning"
	ErrorCodeExperimentNotFoundError             ErrorCode = "ExperimentNotFoundError"
	ErrorCodeExperimentStatusError               ErrorCode = "ExperimentStatusError"
	ErrorCodeFailedToCreateCheckoutSessionError  ErrorCode = "FailedToCreateCheckoutSessionError"
	ErrorCodeFailedToImportCustomer              ErrorCode = "FailedToImportCustomer"
	// Failed to import subscriptions
	ErrorCodeFailedToImportSubscriptions ErrorCode = "FailedToImportSubscriptions"
	// Failed to resolve billing integration
	ErrorCodeFailedToResolveBillingIntegration      ErrorCode = "FailedToResolveBillingIntegration"
	ErrorCodeFeatureConfigurationExceededLimitError ErrorCode = "FeatureConfigurationExceededLimitError"
	// Feature group is missing required features
	ErrorCodeFeatureGroupMissingFeaturesError ErrorCode = "FeatureGroupMissingFeaturesError"
	ErrorCodeFeatureGroupNotFoundError        ErrorCode = "FeatureGroupNotFoundError"
	// Feature does not belong to the specified feature group
	ErrorCodeFeatureNotBelongToFeatureGroupError ErrorCode = "FeatureNotBelongToFeatureGroupError"
	ErrorCodeFeatureNotFound                     ErrorCode = "FeatureNotFound"
	ErrorCodeFetchAllCountriesPricesNotAllowed   ErrorCode = "FetchAllCountriesPricesNotAllowed"
	// Free plan can't have compatible package groups error
	ErrorCodeFreePlanCantHaveCompatiblePackageGroupError ErrorCode = "FreePlanCantHaveCompatiblePackageGroupError"
	// Too many graphql aliases were used in a single request
	ErrorCodeGraphQLAliasesLimitExceeded ErrorCode = "GraphQLAliasesLimitExceeded"
	// Too many batched operations were used in a single request
	ErrorCodeGraphQLBatchedOperationsLimitExceeded ErrorCode = "GraphQLBatchedOperationsLimitExceeded"
	// Unsupported directive
	ErrorCodeGraphQLUnsupportedDirective           ErrorCode = "GraphQLUnsupportedDirective"
	ErrorCodeHubspotIntegrationError               ErrorCode = "HubspotIntegrationError"
	ErrorCodeIdentityForbidden                     ErrorCode = "IdentityForbidden"
	ErrorCodeImportAlreadyInProgress               ErrorCode = "ImportAlreadyInProgress"
	ErrorCodeImportSubscriptionsBulkError          ErrorCode = "ImportSubscriptionsBulkError"
	ErrorCodeIncompatibleSubscriptionAddon         ErrorCode = "IncompatibleSubscriptionAddon"
	ErrorCodeInitStripePaymentMethodError          ErrorCode = "InitStripePaymentMethodError"
	ErrorCodeIntegrationNotFound                   ErrorCode = "IntegrationNotFound"
	ErrorCodeIntegrationValidationError            ErrorCode = "IntegrationValidationError"
	ErrorCodeIntegrityViolation                    ErrorCode = "IntegrityViolation"
	ErrorCodeInvalidAddressError                   ErrorCode = "InvalidAddressError"
	ErrorCodeInvalidArgumentError                  ErrorCode = "InvalidArgumentError"
	ErrorCodeInvalidCancellationDate               ErrorCode = "InvalidCancellationDate"
	ErrorCodeInvalidDoggoSignatureError            ErrorCode = "InvalidDoggoSignatureError"
	ErrorCodeInvalidEntitlementResetPeriod         ErrorCode = "InvalidEntitlementResetPeriod"
	ErrorCodeInvalidMemberDelete                   ErrorCode = "InvalidMemberDelete"
	ErrorCodeInvalidMetadataError                  ErrorCode = "InvalidMetadataError"
	ErrorCodeInvalidQuantity                       ErrorCode = "InvalidQuantity"
	ErrorCodeInvalidSubscriptionStatus             ErrorCode = "InvalidSubscriptionStatus"
	ErrorCodeInvalidUpdatePriceUnitAmountError     ErrorCode = "InvalidUpdatePriceUnitAmountError"
	ErrorCodeMemberInvitationError                 ErrorCode = "MemberInvitationError"
	ErrorCodeMemberNotFound                        ErrorCode = "MemberNotFound"
	ErrorCodeMergeEnvironmentValidationError       ErrorCode = "MergeEnvironmentValidationError"
	ErrorCodeMeterMustBeAssociatedToMeteredFeature ErrorCode = "MeterMustBeAssociatedToMeteredFeature"
	ErrorCodeMeteringNotAvailableForFeatureType    ErrorCode = "MeteringNotAvailableForFeatureType"
	ErrorCodeMissingEntityIDError                  ErrorCode = "MissingEntityIdError"
	ErrorCodeMissingSubscriptionInvoiceError       ErrorCode = "MissingSubscriptionInvoiceError"
	// Multi subscription product cannot be a source of auto-cancellation rules
	ErrorCodeMultiSubscriptionCantBeAutoCancellationSourceError ErrorCode = "MultiSubscriptionCantBeAutoCancellationSourceError"
	// This account has no access to the requested feature
	ErrorCodeNoFeatureEntitlementError                     ErrorCode = "NoFeatureEntitlementError"
	ErrorCodeNoFeatureEntitlementInSubscription            ErrorCode = "NoFeatureEntitlementInSubscription"
	ErrorCodeNoProductsAvailable                           ErrorCode = "NoProductsAvailable"
	ErrorCodeOperationNotAllowedDuringInProgressExperiment ErrorCode = "OperationNotAllowedDuringInProgressExperiment"
	ErrorCodePackageAlreadyPublished                       ErrorCode = "PackageAlreadyPublished"
	// Package group min items error
	ErrorCodePackageGroupMinItemsError                        ErrorCode = "PackageGroupMinItemsError"
	ErrorCodePackageGroupNotFound                             ErrorCode = "PackageGroupNotFound"
	ErrorCodePackagePricingTypeNotSet                         ErrorCode = "PackagePricingTypeNotSet"
	ErrorCodePaymentMethodNotFoundError                       ErrorCode = "PaymentMethodNotFoundError"
	ErrorCodePlanCannotBePublishWhenBasePlanIsDraft           ErrorCode = "PlanCannotBePublishWhenBasePlanIsDraft"
	ErrorCodePlanCannotBePublishWhenCompatibleAddonIsDraft    ErrorCode = "PlanCannotBePublishWhenCompatibleAddonIsDraft"
	ErrorCodePlanIsUsedAsDefaultStartPlan                     ErrorCode = "PlanIsUsedAsDefaultStartPlan"
	ErrorCodePlanIsUsedAsDowngradePlan                        ErrorCode = "PlanIsUsedAsDowngradePlan"
	ErrorCodePlanNotFound                                     ErrorCode = "PlanNotFound"
	ErrorCodePlanWithChildCantBeDeleted                       ErrorCode = "PlanWithChildCantBeDeleted"
	ErrorCodePlansCircularDependencyError                     ErrorCode = "PlansCircularDependencyError"
	ErrorCodePreparePaymentMethodFormError                    ErrorCode = "PreparePaymentMethodFormError"
	ErrorCodePriceNotFound                                    ErrorCode = "PriceNotFound"
	ErrorCodeProductNotFoundError                             ErrorCode = "ProductNotFoundError"
	ErrorCodePromotionCodeCustomerNotFirstPurchase            ErrorCode = "PromotionCodeCustomerNotFirstPurchase"
	ErrorCodePromotionCodeMaxRedemptionsReached               ErrorCode = "PromotionCodeMaxRedemptionsReached"
	ErrorCodePromotionCodeMinimumAmountNotReached             ErrorCode = "PromotionCodeMinimumAmountNotReached"
	ErrorCodePromotionCodeNotActive                           ErrorCode = "PromotionCodeNotActive"
	ErrorCodePromotionCodeNotForCustomer                      ErrorCode = "PromotionCodeNotForCustomer"
	ErrorCodePromotionCodeNotFound                            ErrorCode = "PromotionCodeNotFound"
	ErrorCodePromotionalEntitlementNotFoundError              ErrorCode = "PromotionalEntitlementNotFoundError"
	ErrorCodeRateLimitExceeded                                ErrorCode = "RateLimitExceeded"
	ErrorCodeRecalculateEntitlementsError                     ErrorCode = "RecalculateEntitlementsError"
	ErrorCodeRequiredSsoAuthenticationError                   ErrorCode = "RequiredSsoAuthenticationError"
	ErrorCodeResyncAlreadyInProgress                          ErrorCode = "ResyncAlreadyInProgress"
	ErrorCodeScheduledMigrationAlreadyExistsError             ErrorCode = "ScheduledMigrationAlreadyExistsError"
	ErrorCodeSelectedBillingModelDoesntMatchImportedItemError ErrorCode = "SelectedBillingModelDoesntMatchImportedItemError"
	// Single subscription product cannot be a target of auto-cancellation rules
	ErrorCodeSingleSubscriptionCantBeAutoCancellationTargetError ErrorCode = "SingleSubscriptionCantBeAutoCancellationTargetError"
	ErrorCodeStripeCustomerIsDeleted                             ErrorCode = "StripeCustomerIsDeleted"
	ErrorCodeStripeError                                         ErrorCode = "StripeError"
	ErrorCodeSubscriptionAlreadyCanceledOrExpired                ErrorCode = "SubscriptionAlreadyCanceledOrExpired"
	ErrorCodeSubscriptionAlreadyOnLatestPlanError                ErrorCode = "SubscriptionAlreadyOnLatestPlanError"
	ErrorCodeSubscriptionDoesNotHaveBillingPeriod                ErrorCode = "SubscriptionDoesNotHaveBillingPeriod"
	ErrorCodeSubscriptionInvoiceStatusError                      ErrorCode = "SubscriptionInvoiceStatusError"
	ErrorCodeSubscriptionMustHaveSinglePlanError                 ErrorCode = "SubscriptionMustHaveSinglePlanError"
	ErrorCodeSubscriptionNoBillingID                             ErrorCode = "SubscriptionNoBillingId"
	ErrorCodeSubscriptionNotFound                                ErrorCode = "SubscriptionNotFound"
	ErrorCodeTooManySubscriptionsPerCustomer                     ErrorCode = "TooManySubscriptionsPerCustomer"
	ErrorCodeTrialMustBeCancelledImmediately                     ErrorCode = "TrialMustBeCancelledImmediately"
	ErrorCodeUnPublishedPackage                                  ErrorCode = "UnPublishedPackage"
	ErrorCodeUnauthenticated                                     ErrorCode = "Unauthenticated"
	ErrorCodeUnexpectedError                                     ErrorCode = "UnexpectedError"
	ErrorCodeUnsupportedFeatureType                              ErrorCode = "UnsupportedFeatureType"
	// Unsupported parameter
	ErrorCodeUnsupportedParameter                ErrorCode = "UnsupportedParameter"
	ErrorCodeUnsupportedSubscriptionScheduleType ErrorCode = "UnsupportedSubscriptionScheduleType"
	ErrorCodeUnsupportedVendorIdentifier         ErrorCode = "UnsupportedVendorIdentifier"
	ErrorCodeUsageMeasurementDiffOutOfRangeError ErrorCode = "UsageMeasurementDiffOutOfRangeError"
	ErrorCodeVersionExceedsMaxValueError         ErrorCode = "VersionExceedsMaxValueError"
	// Workflow trigger not found
	ErrorCodeWorkflowTriggerNotFound ErrorCode = "WorkflowTriggerNotFound"
)

var AllErrorCode = []ErrorCode{
	ErrorCodeAccessDeniedError,
	ErrorCodeAccountNotFoundError,
	ErrorCodeAddonDependencyMissingError,
	ErrorCodeAddonHasToHavePriceError,
	ErrorCodeAddonIsCompatibleWithGroup,
	ErrorCodeAddonIsCompatibleWithPlan,
	ErrorCodeAddonNotFound,
	ErrorCodeAddonQuantityExceedsLimitError,
	ErrorCodeAddonWithDraftCannotBeDeletedError,
	ErrorCodeAddonsNotFound,
	ErrorCodeAmountTooLarge,
	ErrorCodeArchivedCouponCantBeApplied,
	ErrorCodeAuthCustomerMismatch,
	ErrorCodeAuthCustomerReadonly,
	ErrorCodeAwsMarketplaceIntegrationError,
	ErrorCodeAwsMarketplaceIntegrationValidationError,
	ErrorCodeBadUserInput,
	ErrorCodeBillingIntegrationAlreadyExistsError,
	ErrorCodeBillingIntegrationMissing,
	ErrorCodeBillingPeriodMissingError,
	ErrorCodeCanNotUpdateEntitlementsFeatureGroup,
	ErrorCodeCannotAddOverrideEntitlementToPlan,
	ErrorCodeCannotArchiveFeatureError,
	ErrorCodeCannotArchiveFeatureGroupError,
	ErrorCodeCannotChangeBillingIntegration,
	ErrorCodeCannotDeleteCustomerError,
	ErrorCodeCannotDeleteDefaultIntegration,
	ErrorCodeCannotDeleteFeatureError,
	ErrorCodeCannotDeleteProductError,
	ErrorCodeCannotEditPackageInNonDraftMode,
	ErrorCodeCannotRemovePaymentMethodFromCustomerError,
	ErrorCodeCannotReportUsageForEntitlementWithMeterError,
	ErrorCodeCannotUpdateUnitTransformationError,
	ErrorCodeCannotUpsertToPackageThatHasDraft,
	ErrorCodeChangingPayingCustomerIsNotSupportedError,
	ErrorCodeCheckoutIsNotSupported,
	ErrorCodeCouponNotFound,
	ErrorCodeCustomerAlreadyHaveCustomerCoupon,
	ErrorCodeCustomerAlreadyUsesCoupon,
	ErrorCodeCustomerHasNoEmailAddress,
	ErrorCodeCustomerNoBillingID,
	ErrorCodeCustomerNotFound,
	ErrorCodeCustomerResourceNotFound,
	ErrorCodeDeprecatedEstimateSubscriptionError,
	ErrorCodeDowngradeBillingPeriodNotSupportedError,
	ErrorCodeDraftAddonCantBeArchived,
	ErrorCodeDraftPlanCantBeArchived,
	ErrorCodeDuplicateAddonProvisionedError,
	ErrorCodeDuplicateIntegrationNotAllowed,
	ErrorCodeDuplicateProductValidationError,
	ErrorCodeDuplicatedEntityNotAllowed,
	ErrorCodeEditAllowedOnDraftPackageOnlyError,
	ErrorCodeEntitlementLimitExceededError,
	ErrorCodeEntitlementUsageOutOfRangeError,
	ErrorCodeEntitlementsMustBelongToSamePackage,
	ErrorCodeEntityIDDifferentFromRefIDError,
	ErrorCodeEntityIsArchivedError,
	ErrorCodeEnvironmentMissing,
	ErrorCodeExperimentAlreadyRunning,
	ErrorCodeExperimentNotFoundError,
	ErrorCodeExperimentStatusError,
	ErrorCodeFailedToCreateCheckoutSessionError,
	ErrorCodeFailedToImportCustomer,
	ErrorCodeFailedToImportSubscriptions,
	ErrorCodeFailedToResolveBillingIntegration,
	ErrorCodeFeatureConfigurationExceededLimitError,
	ErrorCodeFeatureGroupMissingFeaturesError,
	ErrorCodeFeatureGroupNotFoundError,
	ErrorCodeFeatureNotBelongToFeatureGroupError,
	ErrorCodeFeatureNotFound,
	ErrorCodeFetchAllCountriesPricesNotAllowed,
	ErrorCodeFreePlanCantHaveCompatiblePackageGroupError,
	ErrorCodeGraphQLAliasesLimitExceeded,
	ErrorCodeGraphQLBatchedOperationsLimitExceeded,
	ErrorCodeGraphQLUnsupportedDirective,
	ErrorCodeHubspotIntegrationError,
	ErrorCodeIdentityForbidden,
	ErrorCodeImportAlreadyInProgress,
	ErrorCodeImportSubscriptionsBulkError,
	ErrorCodeIncompatibleSubscriptionAddon,
	ErrorCodeInitStripePaymentMethodError,
	ErrorCodeIntegrationNotFound,
	ErrorCodeIntegrationValidationError,
	ErrorCodeIntegrityViolation,
	ErrorCodeInvalidAddressError,
	ErrorCodeInvalidArgumentError,
	ErrorCodeInvalidCancellationDate,
	ErrorCodeInvalidDoggoSignatureError,
	ErrorCodeInvalidEntitlementResetPeriod,
	ErrorCodeInvalidMemberDelete,
	ErrorCodeInvalidMetadataError,
	ErrorCodeInvalidQuantity,
	ErrorCodeInvalidSubscriptionStatus,
	ErrorCodeInvalidUpdatePriceUnitAmountError,
	ErrorCodeMemberInvitationError,
	ErrorCodeMemberNotFound,
	ErrorCodeMergeEnvironmentValidationError,
	ErrorCodeMeterMustBeAssociatedToMeteredFeature,
	ErrorCodeMeteringNotAvailableForFeatureType,
	ErrorCodeMissingEntityIDError,
	ErrorCodeMissingSubscriptionInvoiceError,
	ErrorCodeMultiSubscriptionCantBeAutoCancellationSourceError,
	ErrorCodeNoFeatureEntitlementError,
	ErrorCodeNoFeatureEntitlementInSubscription,
	ErrorCodeNoProductsAvailable,
	ErrorCodeOperationNotAllowedDuringInProgressExperiment,
	ErrorCodePackageAlreadyPublished,
	ErrorCodePackageGroupMinItemsError,
	ErrorCodePackageGroupNotFound,
	ErrorCodePackagePricingTypeNotSet,
	ErrorCodePaymentMethodNotFoundError,
	ErrorCodePlanCannotBePublishWhenBasePlanIsDraft,
	ErrorCodePlanCannotBePublishWhenCompatibleAddonIsDraft,
	ErrorCodePlanIsUsedAsDefaultStartPlan,
	ErrorCodePlanIsUsedAsDowngradePlan,
	ErrorCodePlanNotFound,
	ErrorCodePlanWithChildCantBeDeleted,
	ErrorCodePlansCircularDependencyError,
	ErrorCodePreparePaymentMethodFormError,
	ErrorCodePriceNotFound,
	ErrorCodeProductNotFoundError,
	ErrorCodePromotionCodeCustomerNotFirstPurchase,
	ErrorCodePromotionCodeMaxRedemptionsReached,
	ErrorCodePromotionCodeMinimumAmountNotReached,
	ErrorCodePromotionCodeNotActive,
	ErrorCodePromotionCodeNotForCustomer,
	ErrorCodePromotionCodeNotFound,
	ErrorCodePromotionalEntitlementNotFoundError,
	ErrorCodeRateLimitExceeded,
	ErrorCodeRecalculateEntitlementsError,
	ErrorCodeRequiredSsoAuthenticationError,
	ErrorCodeResyncAlreadyInProgress,
	ErrorCodeScheduledMigrationAlreadyExistsError,
	ErrorCodeSelectedBillingModelDoesntMatchImportedItemError,
	ErrorCodeSingleSubscriptionCantBeAutoCancellationTargetError,
	ErrorCodeStripeCustomerIsDeleted,
	ErrorCodeStripeError,
	ErrorCodeSubscriptionAlreadyCanceledOrExpired,
	ErrorCodeSubscriptionAlreadyOnLatestPlanError,
	ErrorCodeSubscriptionDoesNotHaveBillingPeriod,
	ErrorCodeSubscriptionInvoiceStatusError,
	ErrorCodeSubscriptionMustHaveSinglePlanError,
	ErrorCodeSubscriptionNoBillingID,
	ErrorCodeSubscriptionNotFound,
	ErrorCodeTooManySubscriptionsPerCustomer,
	ErrorCodeTrialMustBeCancelledImmediately,
	ErrorCodeUnPublishedPackage,
	ErrorCodeUnauthenticated,
	ErrorCodeUnexpectedError,
	ErrorCodeUnsupportedFeatureType,
	ErrorCodeUnsupportedParameter,
	ErrorCodeUnsupportedSubscriptionScheduleType,
	ErrorCodeUnsupportedVendorIdentifier,
	ErrorCodeUsageMeasurementDiffOutOfRangeError,
	ErrorCodeVersionExceedsMaxValueError,
	ErrorCodeWorkflowTriggerNotFound,
}

func (e ErrorCode) IsValid() bool {
	switch e {
	case ErrorCodeAccessDeniedError, ErrorCodeAccountNotFoundError, ErrorCodeAddonDependencyMissingError, ErrorCodeAddonHasToHavePriceError, ErrorCodeAddonIsCompatibleWithGroup, ErrorCodeAddonIsCompatibleWithPlan, ErrorCodeAddonNotFound, ErrorCodeAddonQuantityExceedsLimitError, ErrorCodeAddonWithDraftCannotBeDeletedError, ErrorCodeAddonsNotFound, ErrorCodeAmountTooLarge, ErrorCodeArchivedCouponCantBeApplied, ErrorCodeAuthCustomerMismatch, ErrorCodeAuthCustomerReadonly, ErrorCodeAwsMarketplaceIntegrationError, ErrorCodeAwsMarketplaceIntegrationValidationError, ErrorCodeBadUserInput, ErrorCodeBillingIntegrationAlreadyExistsError, ErrorCodeBillingIntegrationMissing, ErrorCodeBillingPeriodMissingError, ErrorCodeCanNotUpdateEntitlementsFeatureGroup, ErrorCodeCannotAddOverrideEntitlementToPlan, ErrorCodeCannotArchiveFeatureError, ErrorCodeCannotArchiveFeatureGroupError, ErrorCodeCannotChangeBillingIntegration, ErrorCodeCannotDeleteCustomerError, ErrorCodeCannotDeleteDefaultIntegration, ErrorCodeCannotDeleteFeatureError, ErrorCodeCannotDeleteProductError, ErrorCodeCannotEditPackageInNonDraftMode, ErrorCodeCannotRemovePaymentMethodFromCustomerError, ErrorCodeCannotReportUsageForEntitlementWithMeterError, ErrorCodeCannotUpdateUnitTransformationError, ErrorCodeCannotUpsertToPackageThatHasDraft, ErrorCodeChangingPayingCustomerIsNotSupportedError, ErrorCodeCheckoutIsNotSupported, ErrorCodeCouponNotFound, ErrorCodeCustomerAlreadyHaveCustomerCoupon, ErrorCodeCustomerAlreadyUsesCoupon, ErrorCodeCustomerHasNoEmailAddress, ErrorCodeCustomerNoBillingID, ErrorCodeCustomerNotFound, ErrorCodeCustomerResourceNotFound, ErrorCodeDeprecatedEstimateSubscriptionError, ErrorCodeDowngradeBillingPeriodNotSupportedError, ErrorCodeDraftAddonCantBeArchived, ErrorCodeDraftPlanCantBeArchived, ErrorCodeDuplicateAddonProvisionedError, ErrorCodeDuplicateIntegrationNotAllowed, ErrorCodeDuplicateProductValidationError, ErrorCodeDuplicatedEntityNotAllowed, ErrorCodeEditAllowedOnDraftPackageOnlyError, ErrorCodeEntitlementLimitExceededError, ErrorCodeEntitlementUsageOutOfRangeError, ErrorCodeEntitlementsMustBelongToSamePackage, ErrorCodeEntityIDDifferentFromRefIDError, ErrorCodeEntityIsArchivedError, ErrorCodeEnvironmentMissing, ErrorCodeExperimentAlreadyRunning, ErrorCodeExperimentNotFoundError, ErrorCodeExperimentStatusError, ErrorCodeFailedToCreateCheckoutSessionError, ErrorCodeFailedToImportCustomer, ErrorCodeFailedToImportSubscriptions, ErrorCodeFailedToResolveBillingIntegration, ErrorCodeFeatureConfigurationExceededLimitError, ErrorCodeFeatureGroupMissingFeaturesError, ErrorCodeFeatureGroupNotFoundError, ErrorCodeFeatureNotBelongToFeatureGroupError, ErrorCodeFeatureNotFound, ErrorCodeFetchAllCountriesPricesNotAllowed, ErrorCodeFreePlanCantHaveCompatiblePackageGroupError, ErrorCodeGraphQLAliasesLimitExceeded, ErrorCodeGraphQLBatchedOperationsLimitExceeded, ErrorCodeGraphQLUnsupportedDirective, ErrorCodeHubspotIntegrationError, ErrorCodeIdentityForbidden, ErrorCodeImportAlreadyInProgress, ErrorCodeImportSubscriptionsBulkError, ErrorCodeIncompatibleSubscriptionAddon, ErrorCodeInitStripePaymentMethodError, ErrorCodeIntegrationNotFound, ErrorCodeIntegrationValidationError, ErrorCodeIntegrityViolation, ErrorCodeInvalidAddressError, ErrorCodeInvalidArgumentError, ErrorCodeInvalidCancellationDate, ErrorCodeInvalidDoggoSignatureError, ErrorCodeInvalidEntitlementResetPeriod, ErrorCodeInvalidMemberDelete, ErrorCodeInvalidMetadataError, ErrorCodeInvalidQuantity, ErrorCodeInvalidSubscriptionStatus, ErrorCodeInvalidUpdatePriceUnitAmountError, ErrorCodeMemberInvitationError, ErrorCodeMemberNotFound, ErrorCodeMergeEnvironmentValidationError, ErrorCodeMeterMustBeAssociatedToMeteredFeature, ErrorCodeMeteringNotAvailableForFeatureType, ErrorCodeMissingEntityIDError, ErrorCodeMissingSubscriptionInvoiceError, ErrorCodeMultiSubscriptionCantBeAutoCancellationSourceError, ErrorCodeNoFeatureEntitlementError, ErrorCodeNoFeatureEntitlementInSubscription, ErrorCodeNoProductsAvailable, ErrorCodeOperationNotAllowedDuringInProgressExperiment, ErrorCodePackageAlreadyPublished, ErrorCodePackageGroupMinItemsError, ErrorCodePackageGroupNotFound, ErrorCodePackagePricingTypeNotSet, ErrorCodePaymentMethodNotFoundError, ErrorCodePlanCannotBePublishWhenBasePlanIsDraft, ErrorCodePlanCannotBePublishWhenCompatibleAddonIsDraft, ErrorCodePlanIsUsedAsDefaultStartPlan, ErrorCodePlanIsUsedAsDowngradePlan, ErrorCodePlanNotFound, ErrorCodePlanWithChildCantBeDeleted, ErrorCodePlansCircularDependencyError, ErrorCodePreparePaymentMethodFormError, ErrorCodePriceNotFound, ErrorCodeProductNotFoundError, ErrorCodePromotionCodeCustomerNotFirstPurchase, ErrorCodePromotionCodeMaxRedemptionsReached, ErrorCodePromotionCodeMinimumAmountNotReached, ErrorCodePromotionCodeNotActive, ErrorCodePromotionCodeNotForCustomer, ErrorCodePromotionCodeNotFound, ErrorCodePromotionalEntitlementNotFoundError, ErrorCodeRateLimitExceeded, ErrorCodeRecalculateEntitlementsError, ErrorCodeRequiredSsoAuthenticationError, ErrorCodeResyncAlreadyInProgress, ErrorCodeScheduledMigrationAlreadyExistsError, ErrorCodeSelectedBillingModelDoesntMatchImportedItemError, ErrorCodeSingleSubscriptionCantBeAutoCancellationTargetError, ErrorCodeStripeCustomerIsDeleted, ErrorCodeStripeError, ErrorCodeSubscriptionAlreadyCanceledOrExpired, ErrorCodeSubscriptionAlreadyOnLatestPlanError, ErrorCodeSubscriptionDoesNotHaveBillingPeriod, ErrorCodeSubscriptionInvoiceStatusError, ErrorCodeSubscriptionMustHaveSinglePlanError, ErrorCodeSubscriptionNoBillingID, ErrorCodeSubscriptionNotFound, ErrorCodeTooManySubscriptionsPerCustomer, ErrorCodeTrialMustBeCancelledImmediately, ErrorCodeUnPublishedPackage, ErrorCodeUnauthenticated, ErrorCodeUnexpectedError, ErrorCodeUnsupportedFeatureType, ErrorCodeUnsupportedParameter, ErrorCodeUnsupportedSubscriptionScheduleType, ErrorCodeUnsupportedVendorIdentifier, ErrorCodeUsageMeasurementDiffOutOfRangeError, ErrorCodeVersionExceedsMaxValueError, ErrorCodeWorkflowTriggerNotFound:
		return true
	}
	return false
}

func (e ErrorCode) String() string {
	return string(e)
}

func (e *ErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCode", str)
	}
	return nil
}

func (e ErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Event actor type
type EventActor string

const (
	// Client SDK with hardened authentication
	EventActorAppCustomer EventActor = "APP_CUSTOMER"
	// Client SDK
	EventActorAppPublic EventActor = "APP_PUBLIC"
	// Backend SDK
	EventActorAppServer EventActor = "APP_SERVER"
	// AWS triggered event
	EventActorAws EventActor = "AWS"
	// Import triggered event
	EventActorImport EventActor = "IMPORT"
	// Migration triggered event
	EventActorMigration EventActor = "MIGRATION"
	// Salesforce API key
	EventActorSalesforce EventActor = "SALESFORCE"
	// Stigg scheduler
	EventActorScheduler EventActor = "SCHEDULER"
	// Stigg user service key
	EventActorService EventActor = "SERVICE"
	// Stripe triggered event
	EventActorStripe EventActor = "STRIPE"
	// Stigg customer support
	EventActorSupport EventActor = "SUPPORT"
	// Stigg internal system
	EventActorSystem EventActor = "SYSTEM"
	// Web application user
	EventActorUser EventActor = "USER"
	// Workflow triggered event
	EventActorWorkflow EventActor = "WORKFLOW"
)

var AllEventActor = []EventActor{
	EventActorAppCustomer,
	EventActorAppPublic,
	EventActorAppServer,
	EventActorAws,
	EventActorImport,
	EventActorMigration,
	EventActorSalesforce,
	EventActorScheduler,
	EventActorService,
	EventActorStripe,
	EventActorSupport,
	EventActorSystem,
	EventActorUser,
	EventActorWorkflow,
}

func (e EventActor) IsValid() bool {
	switch e {
	case EventActorAppCustomer, EventActorAppPublic, EventActorAppServer, EventActorAws, EventActorImport, EventActorMigration, EventActorSalesforce, EventActorScheduler, EventActorService, EventActorStripe, EventActorSupport, EventActorSystem, EventActorUser, EventActorWorkflow:
		return true
	}
	return false
}

func (e EventActor) String() string {
	return string(e)
}

func (e *EventActor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventActor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventActor", str)
	}
	return nil
}

func (e EventActor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Event entity type
type EventEntityType string

const (
	// Add-on entity
	EventEntityTypeAddon EventEntityType = "ADDON"
	// Coupon entity
	EventEntityTypeCoupon EventEntityType = "COUPON"
	// Customer entity
	EventEntityTypeCustomer EventEntityType = "CUSTOMER"
	// Entitlement entity
	EventEntityTypeEntitlement EventEntityType = "ENTITLEMENT"
	// Feature entity
	EventEntityTypeFeature EventEntityType = "FEATURE"
	// Import entity
	EventEntityTypeImport EventEntityType = "IMPORT"
	// Measurement entity
	EventEntityTypeMeasurement EventEntityType = "MEASUREMENT"
	// Package entity
	EventEntityTypePackage EventEntityType = "PACKAGE"
	// Package group entity
	EventEntityTypePackageGroup EventEntityType = "PACKAGE_GROUP"
	// Plan entity
	EventEntityTypePlan EventEntityType = "PLAN"
	// Product entity
	EventEntityTypeProduct EventEntityType = "PRODUCT"
	// Promotional entitlement entity
	EventEntityTypePromotionalEntitlement EventEntityType = "PROMOTIONAL_ENTITLEMENT"
	// Subscription entity
	EventEntityTypeSubscription EventEntityType = "SUBSCRIPTION"
)

var AllEventEntityType = []EventEntityType{
	EventEntityTypeAddon,
	EventEntityTypeCoupon,
	EventEntityTypeCustomer,
	EventEntityTypeEntitlement,
	EventEntityTypeFeature,
	EventEntityTypeImport,
	EventEntityTypeMeasurement,
	EventEntityTypePackage,
	EventEntityTypePackageGroup,
	EventEntityTypePlan,
	EventEntityTypeProduct,
	EventEntityTypePromotionalEntitlement,
	EventEntityTypeSubscription,
}

func (e EventEntityType) IsValid() bool {
	switch e {
	case EventEntityTypeAddon, EventEntityTypeCoupon, EventEntityTypeCustomer, EventEntityTypeEntitlement, EventEntityTypeFeature, EventEntityTypeImport, EventEntityTypeMeasurement, EventEntityTypePackage, EventEntityTypePackageGroup, EventEntityTypePlan, EventEntityTypeProduct, EventEntityTypePromotionalEntitlement, EventEntityTypeSubscription:
		return true
	}
	return false
}

func (e EventEntityType) String() string {
	return string(e)
}

func (e *EventEntityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventEntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventEntityType", str)
	}
	return nil
}

func (e EventEntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventLogSortFields string

const (
	EventLogSortFieldsCreatedAt      EventLogSortFields = "createdAt"
	EventLogSortFieldsEntityID       EventLogSortFields = "entityId"
	EventLogSortFieldsEnvironmentID  EventLogSortFields = "environmentId"
	EventLogSortFieldsEventLogType   EventLogSortFields = "eventLogType"
	EventLogSortFieldsID             EventLogSortFields = "id"
	EventLogSortFieldsParentEntityID EventLogSortFields = "parentEntityId"
)

var AllEventLogSortFields = []EventLogSortFields{
	EventLogSortFieldsCreatedAt,
	EventLogSortFieldsEntityID,
	EventLogSortFieldsEnvironmentID,
	EventLogSortFieldsEventLogType,
	EventLogSortFieldsID,
	EventLogSortFieldsParentEntityID,
}

func (e EventLogSortFields) IsValid() bool {
	switch e {
	case EventLogSortFieldsCreatedAt, EventLogSortFieldsEntityID, EventLogSortFieldsEnvironmentID, EventLogSortFieldsEventLogType, EventLogSortFieldsID, EventLogSortFieldsParentEntityID:
		return true
	}
	return false
}

func (e EventLogSortFields) String() string {
	return string(e)
}

func (e *EventLogSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventLogSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventLogSortFields", str)
	}
	return nil
}

func (e EventLogSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Event log type
type EventLogType string

const (
	// Addon created
	EventLogTypeAddonCreated EventLogType = "ADDON_CREATED"
	// Addon deleted
	EventLogTypeAddonDeleted EventLogType = "ADDON_DELETED"
	// Addon updated
	EventLogTypeAddonUpdated EventLogType = "ADDON_UPDATED"
	// Coupon archived
	EventLogTypeCouponArchived EventLogType = "COUPON_ARCHIVED"
	// Coupon created
	EventLogTypeCouponCreated EventLogType = "COUPON_CREATED"
	// Coupon updated
	EventLogTypeCouponUpdated EventLogType = "COUPON_UPDATED"
	// Create subscription failed
	EventLogTypeCreateSubscriptionFailed EventLogType = "CREATE_SUBSCRIPTION_FAILED"
	// Customer created
	EventLogTypeCustomerCreated EventLogType = "CUSTOMER_CREATED"
	// Customer deleted
	EventLogTypeCustomerDeleted EventLogType = "CUSTOMER_DELETED"
	// Customer entitlement calculation triggered
	EventLogTypeCustomerEntitlementCalculationTriggered EventLogType = "CUSTOMER_ENTITLEMENT_CALCULATION_TRIGGERED"
	// Customer payment failed
	EventLogTypeCustomerPaymentFailed EventLogType = "CUSTOMER_PAYMENT_FAILED"
	// Customer resource entitlement calculation triggered
	EventLogTypeCustomerResourceEntitlementCalculationTriggered EventLogType = "CUSTOMER_RESOURCE_ENTITLEMENT_CALCULATION_TRIGGERED"
	// Customer updated
	EventLogTypeCustomerUpdated EventLogType = "CUSTOMER_UPDATED"
	// Edge API customer data resync
	EventLogTypeEdgeAPICustomerDataResync EventLogType = "EDGE_API_CUSTOMER_DATA_RESYNC"
	// Edge API data resync
	EventLogTypeEdgeAPIDataResync EventLogType = "EDGE_API_DATA_RESYNC"
	// Edge API Doggo resync
	EventLogTypeEdgeAPIDoggoResync EventLogType = "EDGE_API_DOGGO_RESYNC"
	// Edge API package entitlements data resync
	EventLogTypeEdgeAPIPackageEntitlementsDataResync EventLogType = "EDGE_API_PACKAGE_ENTITLEMENTS_DATA_RESYNC"
	// Edge API subscriptions data resync
	EventLogTypeEdgeAPISubscriptionsDataResync EventLogType = "EDGE_API_SUBSCRIPTIONS_DATA_RESYNC"
	// Entitlements updated
	EventLogTypeEntitlementsUpdated EventLogType = "ENTITLEMENTS_UPDATED"
	// Entitlement denied
	EventLogTypeEntitlementDenied EventLogType = "ENTITLEMENT_DENIED"
	// Entitlement granted
	EventLogTypeEntitlementGranted EventLogType = "ENTITLEMENT_GRANTED"
	// Entitlement requested
	EventLogTypeEntitlementRequested EventLogType = "ENTITLEMENT_REQUESTED"
	// Entitlement usage exceeded
	EventLogTypeEntitlementUsageExceeded EventLogType = "ENTITLEMENT_USAGE_EXCEEDED"
	// Environment deleted
	EventLogTypeEnvironmentDeleted EventLogType = "ENVIRONMENT_DELETED"
	// Feature archived
	EventLogTypeFeatureArchived EventLogType = "FEATURE_ARCHIVED"
	// Feature created
	EventLogTypeFeatureCreated EventLogType = "FEATURE_CREATED"
	// Feature deleted
	EventLogTypeFeatureDeleted EventLogType = "FEATURE_DELETED"
	// Feature updated
	EventLogTypeFeatureUpdated EventLogType = "FEATURE_UPDATED"
	// Import integration catalog triggered
	EventLogTypeImportIntegrationCatalogTriggered EventLogType = "IMPORT_INTEGRATION_CATALOG_TRIGGERED"
	// Import integration customers triggered
	EventLogTypeImportIntegrationCustomersTriggered EventLogType = "IMPORT_INTEGRATION_CUSTOMERS_TRIGGERED"
	// Import subscriptions bulk triggered
	EventLogTypeImportSubscriptionsBulkTriggered EventLogType = "IMPORT_SUBSCRIPTIONS_BULK_TRIGGERED"
	// Measurement reported
	EventLogTypeMeasurementReported EventLogType = "MEASUREMENT_REPORTED"
	// Package group created
	EventLogTypePackageGroupCreated EventLogType = "PACKAGE_GROUP_CREATED"
	// Package group updated
	EventLogTypePackageGroupUpdated EventLogType = "PACKAGE_GROUP_UPDATED"
	// Package published
	EventLogTypePackagePublished EventLogType = "PACKAGE_PUBLISHED"
	// Plan created
	EventLogTypePlanCreated EventLogType = "PLAN_CREATED"
	// Plan deleted
	EventLogTypePlanDeleted EventLogType = "PLAN_DELETED"
	// Plan updated
	EventLogTypePlanUpdated EventLogType = "PLAN_UPDATED"
	// Product created
	EventLogTypeProductCreated EventLogType = "PRODUCT_CREATED"
	// Product deleted
	EventLogTypeProductDeleted EventLogType = "PRODUCT_DELETED"
	// Product updated
	EventLogTypeProductUpdated EventLogType = "PRODUCT_UPDATED"
	// Promotional entitlement expired
	EventLogTypePromotionalEntitlementExpired EventLogType = "PROMOTIONAL_ENTITLEMENT_EXPIRED"
	// Promotional entitlement granted
	EventLogTypePromotionalEntitlementGranted EventLogType = "PROMOTIONAL_ENTITLEMENT_GRANTED"
	// Promotional entitlement revoked
	EventLogTypePromotionalEntitlementRevoked EventLogType = "PROMOTIONAL_ENTITLEMENT_REVOKED"
	// Promotional entitlement updated
	EventLogTypePromotionalEntitlementUpdated EventLogType = "PROMOTIONAL_ENTITLEMENT_UPDATED"
	// Recalculate entitlements triggered
	EventLogTypeRecalculateEntitlementsTriggered EventLogType = "RECALCULATE_ENTITLEMENTS_TRIGGERED"
	// Resync integration triggered
	EventLogTypeResyncIntegrationTriggered EventLogType = "RESYNC_INTEGRATION_TRIGGERED"
	// Subscriptions migrated
	EventLogTypeSubscriptionsMigrated EventLogType = "SUBSCRIPTIONS_MIGRATED"
	// Subscriptions migration triggered
	EventLogTypeSubscriptionsMigrationTriggered EventLogType = "SUBSCRIPTIONS_MIGRATION_TRIGGERED"
	// Subscription billing month ends soon
	EventLogTypeSubscriptionBillingMonthEndsSoon EventLogType = "SUBSCRIPTION_BILLING_MONTH_ENDS_SOON"
	// Subscription canceled
	EventLogTypeSubscriptionCanceled EventLogType = "SUBSCRIPTION_CANCELED"
	// Subscription created
	EventLogTypeSubscriptionCreated EventLogType = "SUBSCRIPTION_CREATED"
	// Subscription expired
	EventLogTypeSubscriptionExpired EventLogType = "SUBSCRIPTION_EXPIRED"
	// Subscription spent limit exceeded
	EventLogTypeSubscriptionSpentLimitExceeded EventLogType = "SUBSCRIPTION_SPENT_LIMIT_EXCEEDED"
	// Subscription trial converted
	EventLogTypeSubscriptionTrialConverted EventLogType = "SUBSCRIPTION_TRIAL_CONVERTED"
	// Subscription trial ends soon
	EventLogTypeSubscriptionTrialEndsSoon EventLogType = "SUBSCRIPTION_TRIAL_ENDS_SOON"
	// Subscription trial expired
	EventLogTypeSubscriptionTrialExpired EventLogType = "SUBSCRIPTION_TRIAL_EXPIRED"
	// Subscription trial started
	EventLogTypeSubscriptionTrialStarted EventLogType = "SUBSCRIPTION_TRIAL_STARTED"
	// Subscription updated
	EventLogTypeSubscriptionUpdated EventLogType = "SUBSCRIPTION_UPDATED"
	// Subscription usage charge triggered
	EventLogTypeSubscriptionUsageChargeTriggered EventLogType = "SUBSCRIPTION_USAGE_CHARGE_TRIGGERED"
	// Subscription usage updated
	EventLogTypeSubscriptionUsageUpdated EventLogType = "SUBSCRIPTION_USAGE_UPDATED"
	// Sync failed
	EventLogTypeSyncFailed EventLogType = "SYNC_FAILED"
	// Widget configuration updated
	EventLogTypeWidgetConfigurationUpdated EventLogType = "WIDGET_CONFIGURATION_UPDATED"
)

var AllEventLogType = []EventLogType{
	EventLogTypeAddonCreated,
	EventLogTypeAddonDeleted,
	EventLogTypeAddonUpdated,
	EventLogTypeCouponArchived,
	EventLogTypeCouponCreated,
	EventLogTypeCouponUpdated,
	EventLogTypeCreateSubscriptionFailed,
	EventLogTypeCustomerCreated,
	EventLogTypeCustomerDeleted,
	EventLogTypeCustomerEntitlementCalculationTriggered,
	EventLogTypeCustomerPaymentFailed,
	EventLogTypeCustomerResourceEntitlementCalculationTriggered,
	EventLogTypeCustomerUpdated,
	EventLogTypeEdgeAPICustomerDataResync,
	EventLogTypeEdgeAPIDataResync,
	EventLogTypeEdgeAPIDoggoResync,
	EventLogTypeEdgeAPIPackageEntitlementsDataResync,
	EventLogTypeEdgeAPISubscriptionsDataResync,
	EventLogTypeEntitlementsUpdated,
	EventLogTypeEntitlementDenied,
	EventLogTypeEntitlementGranted,
	EventLogTypeEntitlementRequested,
	EventLogTypeEntitlementUsageExceeded,
	EventLogTypeEnvironmentDeleted,
	EventLogTypeFeatureArchived,
	EventLogTypeFeatureCreated,
	EventLogTypeFeatureDeleted,
	EventLogTypeFeatureUpdated,
	EventLogTypeImportIntegrationCatalogTriggered,
	EventLogTypeImportIntegrationCustomersTriggered,
	EventLogTypeImportSubscriptionsBulkTriggered,
	EventLogTypeMeasurementReported,
	EventLogTypePackageGroupCreated,
	EventLogTypePackageGroupUpdated,
	EventLogTypePackagePublished,
	EventLogTypePlanCreated,
	EventLogTypePlanDeleted,
	EventLogTypePlanUpdated,
	EventLogTypeProductCreated,
	EventLogTypeProductDeleted,
	EventLogTypeProductUpdated,
	EventLogTypePromotionalEntitlementExpired,
	EventLogTypePromotionalEntitlementGranted,
	EventLogTypePromotionalEntitlementRevoked,
	EventLogTypePromotionalEntitlementUpdated,
	EventLogTypeRecalculateEntitlementsTriggered,
	EventLogTypeResyncIntegrationTriggered,
	EventLogTypeSubscriptionsMigrated,
	EventLogTypeSubscriptionsMigrationTriggered,
	EventLogTypeSubscriptionBillingMonthEndsSoon,
	EventLogTypeSubscriptionCanceled,
	EventLogTypeSubscriptionCreated,
	EventLogTypeSubscriptionExpired,
	EventLogTypeSubscriptionSpentLimitExceeded,
	EventLogTypeSubscriptionTrialConverted,
	EventLogTypeSubscriptionTrialEndsSoon,
	EventLogTypeSubscriptionTrialExpired,
	EventLogTypeSubscriptionTrialStarted,
	EventLogTypeSubscriptionUpdated,
	EventLogTypeSubscriptionUsageChargeTriggered,
	EventLogTypeSubscriptionUsageUpdated,
	EventLogTypeSyncFailed,
	EventLogTypeWidgetConfigurationUpdated,
}

func (e EventLogType) IsValid() bool {
	switch e {
	case EventLogTypeAddonCreated, EventLogTypeAddonDeleted, EventLogTypeAddonUpdated, EventLogTypeCouponArchived, EventLogTypeCouponCreated, EventLogTypeCouponUpdated, EventLogTypeCreateSubscriptionFailed, EventLogTypeCustomerCreated, EventLogTypeCustomerDeleted, EventLogTypeCustomerEntitlementCalculationTriggered, EventLogTypeCustomerPaymentFailed, EventLogTypeCustomerResourceEntitlementCalculationTriggered, EventLogTypeCustomerUpdated, EventLogTypeEdgeAPICustomerDataResync, EventLogTypeEdgeAPIDataResync, EventLogTypeEdgeAPIDoggoResync, EventLogTypeEdgeAPIPackageEntitlementsDataResync, EventLogTypeEdgeAPISubscriptionsDataResync, EventLogTypeEntitlementsUpdated, EventLogTypeEntitlementDenied, EventLogTypeEntitlementGranted, EventLogTypeEntitlementRequested, EventLogTypeEntitlementUsageExceeded, EventLogTypeEnvironmentDeleted, EventLogTypeFeatureArchived, EventLogTypeFeatureCreated, EventLogTypeFeatureDeleted, EventLogTypeFeatureUpdated, EventLogTypeImportIntegrationCatalogTriggered, EventLogTypeImportIntegrationCustomersTriggered, EventLogTypeImportSubscriptionsBulkTriggered, EventLogTypeMeasurementReported, EventLogTypePackageGroupCreated, EventLogTypePackageGroupUpdated, EventLogTypePackagePublished, EventLogTypePlanCreated, EventLogTypePlanDeleted, EventLogTypePlanUpdated, EventLogTypeProductCreated, EventLogTypeProductDeleted, EventLogTypeProductUpdated, EventLogTypePromotionalEntitlementExpired, EventLogTypePromotionalEntitlementGranted, EventLogTypePromotionalEntitlementRevoked, EventLogTypePromotionalEntitlementUpdated, EventLogTypeRecalculateEntitlementsTriggered, EventLogTypeResyncIntegrationTriggered, EventLogTypeSubscriptionsMigrated, EventLogTypeSubscriptionsMigrationTriggered, EventLogTypeSubscriptionBillingMonthEndsSoon, EventLogTypeSubscriptionCanceled, EventLogTypeSubscriptionCreated, EventLogTypeSubscriptionExpired, EventLogTypeSubscriptionSpentLimitExceeded, EventLogTypeSubscriptionTrialConverted, EventLogTypeSubscriptionTrialEndsSoon, EventLogTypeSubscriptionTrialExpired, EventLogTypeSubscriptionTrialStarted, EventLogTypeSubscriptionUpdated, EventLogTypeSubscriptionUsageChargeTriggered, EventLogTypeSubscriptionUsageUpdated, EventLogTypeSyncFailed, EventLogTypeWidgetConfigurationUpdated:
		return true
	}
	return false
}

func (e EventLogType) String() string {
	return string(e)
}

func (e *EventLogType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventLogType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventLogType", str)
	}
	return nil
}

func (e EventLogType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ExperimentSortFields string

const (
	ExperimentSortFieldsCreatedAt     ExperimentSortFields = "createdAt"
	ExperimentSortFieldsEnvironmentID ExperimentSortFields = "environmentId"
	ExperimentSortFieldsID            ExperimentSortFields = "id"
	ExperimentSortFieldsName          ExperimentSortFields = "name"
	ExperimentSortFieldsProductID     ExperimentSortFields = "productId"
	ExperimentSortFieldsRefID         ExperimentSortFields = "refId"
	ExperimentSortFieldsStatus        ExperimentSortFields = "status"
)

var AllExperimentSortFields = []ExperimentSortFields{
	ExperimentSortFieldsCreatedAt,
	ExperimentSortFieldsEnvironmentID,
	ExperimentSortFieldsID,
	ExperimentSortFieldsName,
	ExperimentSortFieldsProductID,
	ExperimentSortFieldsRefID,
	ExperimentSortFieldsStatus,
}

func (e ExperimentSortFields) IsValid() bool {
	switch e {
	case ExperimentSortFieldsCreatedAt, ExperimentSortFieldsEnvironmentID, ExperimentSortFieldsID, ExperimentSortFieldsName, ExperimentSortFieldsProductID, ExperimentSortFieldsRefID, ExperimentSortFieldsStatus:
		return true
	}
	return false
}

func (e ExperimentSortFields) String() string {
	return string(e)
}

func (e *ExperimentSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentSortFields", str)
	}
	return nil
}

func (e ExperimentSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the experiment
type ExperimentStatus string

const (
	// Experiment has been completed
	ExperimentStatusCompleted ExperimentStatus = "COMPLETED"
	// Experiment is in draft state
	ExperimentStatusDraft ExperimentStatus = "DRAFT"
	// Experiment is currently running
	ExperimentStatusInProgress ExperimentStatus = "IN_PROGRESS"
)

var AllExperimentStatus = []ExperimentStatus{
	ExperimentStatusCompleted,
	ExperimentStatusDraft,
	ExperimentStatusInProgress,
}

func (e ExperimentStatus) IsValid() bool {
	switch e {
	case ExperimentStatusCompleted, ExperimentStatusDraft, ExperimentStatusInProgress:
		return true
	}
	return false
}

func (e ExperimentStatus) String() string {
	return string(e)
}

func (e *ExperimentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentStatus", str)
	}
	return nil
}

func (e ExperimentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FeatureGroupSortFields string

const (
	FeatureGroupSortFieldsCreatedAt      FeatureGroupSortFields = "createdAt"
	FeatureGroupSortFieldsDisplayName    FeatureGroupSortFields = "displayName"
	FeatureGroupSortFieldsEnvironmentID  FeatureGroupSortFields = "environmentId"
	FeatureGroupSortFieldsFeatureGroupID FeatureGroupSortFields = "featureGroupId"
	FeatureGroupSortFieldsID             FeatureGroupSortFields = "id"
	FeatureGroupSortFieldsIsLatest       FeatureGroupSortFields = "isLatest"
	FeatureGroupSortFieldsStatus         FeatureGroupSortFields = "status"
	FeatureGroupSortFieldsUpdatedAt      FeatureGroupSortFields = "updatedAt"
	FeatureGroupSortFieldsVersionNumber  FeatureGroupSortFields = "versionNumber"
)

var AllFeatureGroupSortFields = []FeatureGroupSortFields{
	FeatureGroupSortFieldsCreatedAt,
	FeatureGroupSortFieldsDisplayName,
	FeatureGroupSortFieldsEnvironmentID,
	FeatureGroupSortFieldsFeatureGroupID,
	FeatureGroupSortFieldsID,
	FeatureGroupSortFieldsIsLatest,
	FeatureGroupSortFieldsStatus,
	FeatureGroupSortFieldsUpdatedAt,
	FeatureGroupSortFieldsVersionNumber,
}

func (e FeatureGroupSortFields) IsValid() bool {
	switch e {
	case FeatureGroupSortFieldsCreatedAt, FeatureGroupSortFieldsDisplayName, FeatureGroupSortFieldsEnvironmentID, FeatureGroupSortFieldsFeatureGroupID, FeatureGroupSortFieldsID, FeatureGroupSortFieldsIsLatest, FeatureGroupSortFieldsStatus, FeatureGroupSortFieldsUpdatedAt, FeatureGroupSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e FeatureGroupSortFields) String() string {
	return string(e)
}

func (e *FeatureGroupSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureGroupSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureGroupSortFields", str)
	}
	return nil
}

func (e FeatureGroupSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feature group status
type FeatureGroupStatus string

const (
	// The feature group is archived
	FeatureGroupStatusArchived FeatureGroupStatus = "ARCHIVED"
	// The feature group is published
	FeatureGroupStatusPublished FeatureGroupStatus = "PUBLISHED"
)

var AllFeatureGroupStatus = []FeatureGroupStatus{
	FeatureGroupStatusArchived,
	FeatureGroupStatusPublished,
}

func (e FeatureGroupStatus) IsValid() bool {
	switch e {
	case FeatureGroupStatusArchived, FeatureGroupStatusPublished:
		return true
	}
	return false
}

func (e FeatureGroupStatus) String() string {
	return string(e)
}

func (e *FeatureGroupStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureGroupStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureGroupStatus", str)
	}
	return nil
}

func (e FeatureGroupStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FeatureSortFields string

const (
	FeatureSortFieldsCreatedAt     FeatureSortFields = "createdAt"
	FeatureSortFieldsDescription   FeatureSortFields = "description"
	FeatureSortFieldsDisplayName   FeatureSortFields = "displayName"
	FeatureSortFieldsEnvironmentID FeatureSortFields = "environmentId"
	FeatureSortFieldsFeatureStatus FeatureSortFields = "featureStatus"
	FeatureSortFieldsFeatureType   FeatureSortFields = "featureType"
	FeatureSortFieldsID            FeatureSortFields = "id"
	FeatureSortFieldsMeterType     FeatureSortFields = "meterType"
	FeatureSortFieldsRefID         FeatureSortFields = "refId"
	FeatureSortFieldsUpdatedAt     FeatureSortFields = "updatedAt"
)

var AllFeatureSortFields = []FeatureSortFields{
	FeatureSortFieldsCreatedAt,
	FeatureSortFieldsDescription,
	FeatureSortFieldsDisplayName,
	FeatureSortFieldsEnvironmentID,
	FeatureSortFieldsFeatureStatus,
	FeatureSortFieldsFeatureType,
	FeatureSortFieldsID,
	FeatureSortFieldsMeterType,
	FeatureSortFieldsRefID,
	FeatureSortFieldsUpdatedAt,
}

func (e FeatureSortFields) IsValid() bool {
	switch e {
	case FeatureSortFieldsCreatedAt, FeatureSortFieldsDescription, FeatureSortFieldsDisplayName, FeatureSortFieldsEnvironmentID, FeatureSortFieldsFeatureStatus, FeatureSortFieldsFeatureType, FeatureSortFieldsID, FeatureSortFieldsMeterType, FeatureSortFieldsRefID, FeatureSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e FeatureSortFields) String() string {
	return string(e)
}

func (e *FeatureSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureSortFields", str)
	}
	return nil
}

func (e FeatureSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feature status
type FeatureStatus string

const (
	// Active feature
	FeatureStatusActive FeatureStatus = "ACTIVE"
	// New feature
	FeatureStatusNew FeatureStatus = "NEW"
	// Suspended feature
	FeatureStatusSuspended FeatureStatus = "SUSPENDED"
)

var AllFeatureStatus = []FeatureStatus{
	FeatureStatusActive,
	FeatureStatusNew,
	FeatureStatusSuspended,
}

func (e FeatureStatus) IsValid() bool {
	switch e {
	case FeatureStatusActive, FeatureStatusNew, FeatureStatusSuspended:
		return true
	}
	return false
}

func (e FeatureStatus) String() string {
	return string(e)
}

func (e *FeatureStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureStatus", str)
	}
	return nil
}

func (e FeatureStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the feature
type FeatureType string

const (
	// Boolean feature type
	FeatureTypeBoolean FeatureType = "BOOLEAN"
	// Enum feature type
	FeatureTypeEnum FeatureType = "ENUM"
	// Numeric feature type
	FeatureTypeNumber FeatureType = "NUMBER"
)

var AllFeatureType = []FeatureType{
	FeatureTypeBoolean,
	FeatureTypeEnum,
	FeatureTypeNumber,
}

func (e FeatureType) IsValid() bool {
	switch e {
	case FeatureTypeBoolean, FeatureTypeEnum, FeatureTypeNumber:
		return true
	}
	return false
}

func (e FeatureType) String() string {
	return string(e)
}

func (e *FeatureType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureType", str)
	}
	return nil
}

func (e FeatureType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Font weight
type FontWeight string

const (
	// Bold font weight.
	FontWeightBold FontWeight = "BOLD"
	// Standard font weight.
	FontWeightNormal FontWeight = "NORMAL"
)

var AllFontWeight = []FontWeight{
	FontWeightBold,
	FontWeightNormal,
}

func (e FontWeight) IsValid() bool {
	switch e {
	case FontWeightBold, FontWeightNormal:
		return true
	}
	return false
}

func (e FontWeight) String() string {
	return string(e)
}

func (e *FontWeight) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FontWeight(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FontWeight", str)
	}
	return nil
}

func (e FontWeight) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HookSortFields string

const (
	HookSortFieldsCreatedAt     HookSortFields = "createdAt"
	HookSortFieldsEndpoint      HookSortFields = "endpoint"
	HookSortFieldsEnvironmentID HookSortFields = "environmentId"
	HookSortFieldsID            HookSortFields = "id"
	HookSortFieldsStatus        HookSortFields = "status"
)

var AllHookSortFields = []HookSortFields{
	HookSortFieldsCreatedAt,
	HookSortFieldsEndpoint,
	HookSortFieldsEnvironmentID,
	HookSortFieldsID,
	HookSortFieldsStatus,
}

func (e HookSortFields) IsValid() bool {
	switch e {
	case HookSortFieldsCreatedAt, HookSortFieldsEndpoint, HookSortFieldsEnvironmentID, HookSortFieldsID, HookSortFieldsStatus:
		return true
	}
	return false
}

func (e HookSortFields) String() string {
	return string(e)
}

func (e *HookSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HookSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HookSortFields", str)
	}
	return nil
}

func (e HookSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Hook status
type HookStatus string

const (
	// Active
	HookStatusActive HookStatus = "ACTIVE"
	// Inactive
	HookStatusInactive HookStatus = "INACTIVE"
)

var AllHookStatus = []HookStatus{
	HookStatusActive,
	HookStatusInactive,
}

func (e HookStatus) IsValid() bool {
	switch e {
	case HookStatusActive, HookStatusInactive:
		return true
	}
	return false
}

func (e HookStatus) String() string {
	return string(e)
}

func (e *HookStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HookStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HookStatus", str)
	}
	return nil
}

func (e HookStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImportIntegrationTaskSortFields string

const (
	ImportIntegrationTaskSortFieldsCreatedAt     ImportIntegrationTaskSortFields = "createdAt"
	ImportIntegrationTaskSortFieldsEnvironmentID ImportIntegrationTaskSortFields = "environmentId"
	ImportIntegrationTaskSortFieldsID            ImportIntegrationTaskSortFields = "id"
	ImportIntegrationTaskSortFieldsStatus        ImportIntegrationTaskSortFields = "status"
	ImportIntegrationTaskSortFieldsTaskType      ImportIntegrationTaskSortFields = "taskType"
)

var AllImportIntegrationTaskSortFields = []ImportIntegrationTaskSortFields{
	ImportIntegrationTaskSortFieldsCreatedAt,
	ImportIntegrationTaskSortFieldsEnvironmentID,
	ImportIntegrationTaskSortFieldsID,
	ImportIntegrationTaskSortFieldsStatus,
	ImportIntegrationTaskSortFieldsTaskType,
}

func (e ImportIntegrationTaskSortFields) IsValid() bool {
	switch e {
	case ImportIntegrationTaskSortFieldsCreatedAt, ImportIntegrationTaskSortFieldsEnvironmentID, ImportIntegrationTaskSortFieldsID, ImportIntegrationTaskSortFieldsStatus, ImportIntegrationTaskSortFieldsTaskType:
		return true
	}
	return false
}

func (e ImportIntegrationTaskSortFields) String() string {
	return string(e)
}

func (e *ImportIntegrationTaskSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportIntegrationTaskSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportIntegrationTaskSortFields", str)
	}
	return nil
}

func (e ImportIntegrationTaskSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IntegrationSortFields string

const (
	IntegrationSortFieldsCreatedAt        IntegrationSortFields = "createdAt"
	IntegrationSortFieldsEnvironmentID    IntegrationSortFields = "environmentId"
	IntegrationSortFieldsID               IntegrationSortFields = "id"
	IntegrationSortFieldsVendorIdentifier IntegrationSortFields = "vendorIdentifier"
	IntegrationSortFieldsVendorType       IntegrationSortFields = "vendorType"
)

var AllIntegrationSortFields = []IntegrationSortFields{
	IntegrationSortFieldsCreatedAt,
	IntegrationSortFieldsEnvironmentID,
	IntegrationSortFieldsID,
	IntegrationSortFieldsVendorIdentifier,
	IntegrationSortFieldsVendorType,
}

func (e IntegrationSortFields) IsValid() bool {
	switch e {
	case IntegrationSortFieldsCreatedAt, IntegrationSortFieldsEnvironmentID, IntegrationSortFieldsID, IntegrationSortFieldsVendorIdentifier, IntegrationSortFieldsVendorType:
		return true
	}
	return false
}

func (e IntegrationSortFields) String() string {
	return string(e)
}

func (e *IntegrationSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationSortFields", str)
	}
	return nil
}

func (e IntegrationSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the invoice line item
type InvoiceLineItemType string

const (
	InvoiceLineItemTypeAddonCharge                  InvoiceLineItemType = "AddonCharge"
	InvoiceLineItemTypeBaseCharge                   InvoiceLineItemType = "BaseCharge"
	InvoiceLineItemTypeInAdvanceCommitmentCharge    InvoiceLineItemType = "InAdvanceCommitmentCharge"
	InvoiceLineItemTypeMinimumSpendAdjustmentCharge InvoiceLineItemType = "MinimumSpendAdjustmentCharge"
	InvoiceLineItemTypeMinimumSpendCharge           InvoiceLineItemType = "MinimumSpendCharge"
	InvoiceLineItemTypeOther                        InvoiceLineItemType = "Other"
	InvoiceLineItemTypeOverageCharge                InvoiceLineItemType = "OverageCharge"
	InvoiceLineItemTypePayAsYouGoCharge             InvoiceLineItemType = "PayAsYouGoCharge"
	InvoiceLineItemTypeTierCharge                   InvoiceLineItemType = "TierCharge"
	InvoiceLineItemTypeZeroAmountBaseCharge         InvoiceLineItemType = "ZeroAmountBaseCharge"
)

var AllInvoiceLineItemType = []InvoiceLineItemType{
	InvoiceLineItemTypeAddonCharge,
	InvoiceLineItemTypeBaseCharge,
	InvoiceLineItemTypeInAdvanceCommitmentCharge,
	InvoiceLineItemTypeMinimumSpendAdjustmentCharge,
	InvoiceLineItemTypeMinimumSpendCharge,
	InvoiceLineItemTypeOther,
	InvoiceLineItemTypeOverageCharge,
	InvoiceLineItemTypePayAsYouGoCharge,
	InvoiceLineItemTypeTierCharge,
	InvoiceLineItemTypeZeroAmountBaseCharge,
}

func (e InvoiceLineItemType) IsValid() bool {
	switch e {
	case InvoiceLineItemTypeAddonCharge, InvoiceLineItemTypeBaseCharge, InvoiceLineItemTypeInAdvanceCommitmentCharge, InvoiceLineItemTypeMinimumSpendAdjustmentCharge, InvoiceLineItemTypeMinimumSpendCharge, InvoiceLineItemTypeOther, InvoiceLineItemTypeOverageCharge, InvoiceLineItemTypePayAsYouGoCharge, InvoiceLineItemTypeTierCharge, InvoiceLineItemTypeZeroAmountBaseCharge:
		return true
	}
	return false
}

func (e InvoiceLineItemType) String() string {
	return string(e)
}

func (e *InvoiceLineItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InvoiceLineItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InvoiceLineItemType", str)
	}
	return nil
}

func (e InvoiceLineItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MemberSortFields string

const (
	MemberSortFieldsCreatedAt MemberSortFields = "createdAt"
	MemberSortFieldsEmail     MemberSortFields = "email"
	MemberSortFieldsID        MemberSortFields = "id"
)

var AllMemberSortFields = []MemberSortFields{
	MemberSortFieldsCreatedAt,
	MemberSortFieldsEmail,
	MemberSortFieldsID,
}

func (e MemberSortFields) IsValid() bool {
	switch e {
	case MemberSortFieldsCreatedAt, MemberSortFieldsEmail, MemberSortFieldsID:
		return true
	}
	return false
}

func (e MemberSortFields) String() string {
	return string(e)
}

func (e *MemberSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberSortFields", str)
	}
	return nil
}

func (e MemberSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Member Status
type MemberStatus string

const (
	// User has been invited to the environment
	MemberStatusInvited MemberStatus = "INVITED"
	// User is a member of this environment
	MemberStatusRegistered MemberStatus = "REGISTERED"
)

var AllMemberStatus = []MemberStatus{
	MemberStatusInvited,
	MemberStatusRegistered,
}

func (e MemberStatus) IsValid() bool {
	switch e {
	case MemberStatusInvited, MemberStatusRegistered:
		return true
	}
	return false
}

func (e MemberStatus) String() string {
	return string(e)
}

func (e *MemberStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberStatus", str)
	}
	return nil
}

func (e MemberStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The meter type of the feature
type MeterType string

const (
	// Fluctuating
	MeterTypeFluctuating MeterType = "Fluctuating"
	// Incremental
	MeterTypeIncremental MeterType = "Incremental"
	// None
	MeterTypeNone MeterType = "None"
)

var AllMeterType = []MeterType{
	MeterTypeFluctuating,
	MeterTypeIncremental,
	MeterTypeNone,
}

func (e MeterType) IsValid() bool {
	switch e {
	case MeterTypeFluctuating, MeterTypeIncremental, MeterTypeNone:
		return true
	}
	return false
}

func (e MeterType) String() string {
	return string(e)
}

func (e *MeterType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MeterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MeterType", str)
	}
	return nil
}

func (e MeterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Monthly reset period according to configuration
type MonthlyAccordingTo string

const (
	// Start of the month
	MonthlyAccordingToStartOfTheMonth MonthlyAccordingTo = "StartOfTheMonth"
	// Subscription start
	MonthlyAccordingToSubscriptionStart MonthlyAccordingTo = "SubscriptionStart"
)

var AllMonthlyAccordingTo = []MonthlyAccordingTo{
	MonthlyAccordingToStartOfTheMonth,
	MonthlyAccordingToSubscriptionStart,
}

func (e MonthlyAccordingTo) IsValid() bool {
	switch e {
	case MonthlyAccordingToStartOfTheMonth, MonthlyAccordingToSubscriptionStart:
		return true
	}
	return false
}

func (e MonthlyAccordingTo) String() string {
	return string(e)
}

func (e *MonthlyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MonthlyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MonthlyAccordingTo", str)
	}
	return nil
}

func (e MonthlyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Configures when the overage charge is billed.
type OverageBillingPeriod string

const (
	OverageBillingPeriodMonthly               OverageBillingPeriod = "MONTHLY"
	OverageBillingPeriodOnSubscriptionRenewal OverageBillingPeriod = "ON_SUBSCRIPTION_RENEWAL"
)

var AllOverageBillingPeriod = []OverageBillingPeriod{
	OverageBillingPeriodMonthly,
	OverageBillingPeriodOnSubscriptionRenewal,
}

func (e OverageBillingPeriod) IsValid() bool {
	switch e {
	case OverageBillingPeriodMonthly, OverageBillingPeriodOnSubscriptionRenewal:
		return true
	}
	return false
}

func (e OverageBillingPeriod) String() string {
	return string(e)
}

func (e *OverageBillingPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OverageBillingPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OverageBillingPeriod", str)
	}
	return nil
}

func (e OverageBillingPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PackageDTOSortFields string

const (
	PackageDTOSortFieldsBillingID     PackageDTOSortFields = "billingId"
	PackageDTOSortFieldsCreatedAt     PackageDTOSortFields = "createdAt"
	PackageDTOSortFieldsDescription   PackageDTOSortFields = "description"
	PackageDTOSortFieldsDisplayName   PackageDTOSortFields = "displayName"
	PackageDTOSortFieldsEnvironmentID PackageDTOSortFields = "environmentId"
	PackageDTOSortFieldsID            PackageDTOSortFields = "id"
	PackageDTOSortFieldsIsLatest      PackageDTOSortFields = "isLatest"
	PackageDTOSortFieldsPricingType   PackageDTOSortFields = "pricingType"
	PackageDTOSortFieldsProductID     PackageDTOSortFields = "productId"
	PackageDTOSortFieldsRefID         PackageDTOSortFields = "refId"
	PackageDTOSortFieldsStatus        PackageDTOSortFields = "status"
	PackageDTOSortFieldsUpdatedAt     PackageDTOSortFields = "updatedAt"
	PackageDTOSortFieldsVersionNumber PackageDTOSortFields = "versionNumber"
)

var AllPackageDTOSortFields = []PackageDTOSortFields{
	PackageDTOSortFieldsBillingID,
	PackageDTOSortFieldsCreatedAt,
	PackageDTOSortFieldsDescription,
	PackageDTOSortFieldsDisplayName,
	PackageDTOSortFieldsEnvironmentID,
	PackageDTOSortFieldsID,
	PackageDTOSortFieldsIsLatest,
	PackageDTOSortFieldsPricingType,
	PackageDTOSortFieldsProductID,
	PackageDTOSortFieldsRefID,
	PackageDTOSortFieldsStatus,
	PackageDTOSortFieldsUpdatedAt,
	PackageDTOSortFieldsVersionNumber,
}

func (e PackageDTOSortFields) IsValid() bool {
	switch e {
	case PackageDTOSortFieldsBillingID, PackageDTOSortFieldsCreatedAt, PackageDTOSortFieldsDescription, PackageDTOSortFieldsDisplayName, PackageDTOSortFieldsEnvironmentID, PackageDTOSortFieldsID, PackageDTOSortFieldsIsLatest, PackageDTOSortFieldsPricingType, PackageDTOSortFieldsProductID, PackageDTOSortFieldsRefID, PackageDTOSortFieldsStatus, PackageDTOSortFieldsUpdatedAt, PackageDTOSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e PackageDTOSortFields) String() string {
	return string(e)
}

func (e *PackageDTOSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageDTOSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageDTOSortFields", str)
	}
	return nil
}

func (e PackageDTOSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PackageEntitlementSortFields string

const (
	PackageEntitlementSortFieldsCreatedAt     PackageEntitlementSortFields = "createdAt"
	PackageEntitlementSortFieldsEnvironmentID PackageEntitlementSortFields = "environmentId"
	PackageEntitlementSortFieldsID            PackageEntitlementSortFields = "id"
	PackageEntitlementSortFieldsPackageID     PackageEntitlementSortFields = "packageId"
	PackageEntitlementSortFieldsUpdatedAt     PackageEntitlementSortFields = "updatedAt"
)

var AllPackageEntitlementSortFields = []PackageEntitlementSortFields{
	PackageEntitlementSortFieldsCreatedAt,
	PackageEntitlementSortFieldsEnvironmentID,
	PackageEntitlementSortFieldsID,
	PackageEntitlementSortFieldsPackageID,
	PackageEntitlementSortFieldsUpdatedAt,
}

func (e PackageEntitlementSortFields) IsValid() bool {
	switch e {
	case PackageEntitlementSortFieldsCreatedAt, PackageEntitlementSortFieldsEnvironmentID, PackageEntitlementSortFieldsID, PackageEntitlementSortFieldsPackageID, PackageEntitlementSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e PackageEntitlementSortFields) String() string {
	return string(e)
}

func (e *PackageEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageEntitlementSortFields", str)
	}
	return nil
}

func (e PackageEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PackageGroupSortFields string

const (
	PackageGroupSortFieldsCreatedAt      PackageGroupSortFields = "createdAt"
	PackageGroupSortFieldsDisplayName    PackageGroupSortFields = "displayName"
	PackageGroupSortFieldsEnvironmentID  PackageGroupSortFields = "environmentId"
	PackageGroupSortFieldsIsLatest       PackageGroupSortFields = "isLatest"
	PackageGroupSortFieldsPackageGroupID PackageGroupSortFields = "packageGroupId"
	PackageGroupSortFieldsProductID      PackageGroupSortFields = "productId"
	PackageGroupSortFieldsStatus         PackageGroupSortFields = "status"
	PackageGroupSortFieldsUpdatedAt      PackageGroupSortFields = "updatedAt"
	PackageGroupSortFieldsVersionNumber  PackageGroupSortFields = "versionNumber"
)

var AllPackageGroupSortFields = []PackageGroupSortFields{
	PackageGroupSortFieldsCreatedAt,
	PackageGroupSortFieldsDisplayName,
	PackageGroupSortFieldsEnvironmentID,
	PackageGroupSortFieldsIsLatest,
	PackageGroupSortFieldsPackageGroupID,
	PackageGroupSortFieldsProductID,
	PackageGroupSortFieldsStatus,
	PackageGroupSortFieldsUpdatedAt,
	PackageGroupSortFieldsVersionNumber,
}

func (e PackageGroupSortFields) IsValid() bool {
	switch e {
	case PackageGroupSortFieldsCreatedAt, PackageGroupSortFieldsDisplayName, PackageGroupSortFieldsEnvironmentID, PackageGroupSortFieldsIsLatest, PackageGroupSortFieldsPackageGroupID, PackageGroupSortFieldsProductID, PackageGroupSortFieldsStatus, PackageGroupSortFieldsUpdatedAt, PackageGroupSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e PackageGroupSortFields) String() string {
	return string(e)
}

func (e *PackageGroupSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageGroupSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageGroupSortFields", str)
	}
	return nil
}

func (e PackageGroupSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Package group status
type PackageGroupStatus string

const (
	// The package group is archived
	PackageGroupStatusArchived PackageGroupStatus = "ARCHIVED"
	// The package group is a draft
	PackageGroupStatusDraft PackageGroupStatus = "DRAFT"
	// The package group is published
	PackageGroupStatusPublished PackageGroupStatus = "PUBLISHED"
)

var AllPackageGroupStatus = []PackageGroupStatus{
	PackageGroupStatusArchived,
	PackageGroupStatusDraft,
	PackageGroupStatusPublished,
}

func (e PackageGroupStatus) IsValid() bool {
	switch e {
	case PackageGroupStatusArchived, PackageGroupStatusDraft, PackageGroupStatusPublished:
		return true
	}
	return false
}

func (e PackageGroupStatus) String() string {
	return string(e)
}

func (e *PackageGroupStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageGroupStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageGroupStatus", str)
	}
	return nil
}

func (e PackageGroupStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Package status.
type PackageStatus string

const (
	PackageStatusArchived  PackageStatus = "ARCHIVED"
	PackageStatusDraft     PackageStatus = "DRAFT"
	PackageStatusPublished PackageStatus = "PUBLISHED"
)

var AllPackageStatus = []PackageStatus{
	PackageStatusArchived,
	PackageStatusDraft,
	PackageStatusPublished,
}

func (e PackageStatus) IsValid() bool {
	switch e {
	case PackageStatusArchived, PackageStatusDraft, PackageStatusPublished:
		return true
	}
	return false
}

func (e PackageStatus) String() string {
	return string(e)
}

func (e *PackageStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageStatus", str)
	}
	return nil
}

func (e PackageStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Payment collection
type PaymentCollection string

const (
	PaymentCollectionActionRequired PaymentCollection = "ACTION_REQUIRED"
	PaymentCollectionFailed         PaymentCollection = "FAILED"
	PaymentCollectionNotRequired    PaymentCollection = "NOT_REQUIRED"
	PaymentCollectionProcessing     PaymentCollection = "PROCESSING"
)

var AllPaymentCollection = []PaymentCollection{
	PaymentCollectionActionRequired,
	PaymentCollectionFailed,
	PaymentCollectionNotRequired,
	PaymentCollectionProcessing,
}

func (e PaymentCollection) IsValid() bool {
	switch e {
	case PaymentCollectionActionRequired, PaymentCollectionFailed, PaymentCollectionNotRequired, PaymentCollectionProcessing:
		return true
	}
	return false
}

func (e PaymentCollection) String() string {
	return string(e)
}

func (e *PaymentCollection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentCollection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentCollection", str)
	}
	return nil
}

func (e PaymentCollection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The method used to collect payments for a subscription
type PaymentCollectionMethod string

const (
	// Automatically charge the payment method on file
	PaymentCollectionMethodCharge PaymentCollectionMethod = "CHARGE"
	// Generate an invoice to the customer to pay manually
	PaymentCollectionMethodInvoice PaymentCollectionMethod = "INVOICE"
	// Do not leverage Stigg to manage payments for this subscription
	PaymentCollectionMethodNone PaymentCollectionMethod = "NONE"
)

var AllPaymentCollectionMethod = []PaymentCollectionMethod{
	PaymentCollectionMethodCharge,
	PaymentCollectionMethodInvoice,
	PaymentCollectionMethodNone,
}

func (e PaymentCollectionMethod) IsValid() bool {
	switch e {
	case PaymentCollectionMethodCharge, PaymentCollectionMethodInvoice, PaymentCollectionMethodNone:
		return true
	}
	return false
}

func (e PaymentCollectionMethod) String() string {
	return string(e)
}

func (e *PaymentCollectionMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentCollectionMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentCollectionMethod", str)
	}
	return nil
}

func (e PaymentCollectionMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of a payment method
type PaymentMethodType string

const (
	// Bank Transfer
	PaymentMethodTypeBank PaymentMethodType = "BANK"
	// Credit Card
	PaymentMethodTypeCard PaymentMethodType = "CARD"
	// Cash App
	PaymentMethodTypeCashApp PaymentMethodType = "CASH_APP"
)

var AllPaymentMethodType = []PaymentMethodType{
	PaymentMethodTypeBank,
	PaymentMethodTypeCard,
	PaymentMethodTypeCashApp,
}

func (e PaymentMethodType) IsValid() bool {
	switch e {
	case PaymentMethodTypeBank, PaymentMethodTypeCard, PaymentMethodTypeCashApp:
		return true
	}
	return false
}

func (e PaymentMethodType) String() string {
	return string(e)
}

func (e *PaymentMethodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethodType", str)
	}
	return nil
}

func (e PaymentMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of the change between two plans of the same subscription
type PlanChangeType string

const (
	// Subscription downgrade to lower plan
	PlanChangeTypeDowngrade PlanChangeType = "DOWNGRADE"
	// Subscription remains on the same plan
	PlanChangeTypeNone PlanChangeType = "NONE"
	// Subscription upgrade to higher plan
	PlanChangeTypeUpgrade PlanChangeType = "UPGRADE"
)

var AllPlanChangeType = []PlanChangeType{
	PlanChangeTypeDowngrade,
	PlanChangeTypeNone,
	PlanChangeTypeUpgrade,
}

func (e PlanChangeType) IsValid() bool {
	switch e {
	case PlanChangeTypeDowngrade, PlanChangeTypeNone, PlanChangeTypeUpgrade:
		return true
	}
	return false
}

func (e PlanChangeType) String() string {
	return string(e)
}

func (e *PlanChangeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlanChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlanChangeType", str)
	}
	return nil
}

func (e PlanChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlanSortFields string

const (
	PlanSortFieldsBillingID     PlanSortFields = "billingId"
	PlanSortFieldsCreatedAt     PlanSortFields = "createdAt"
	PlanSortFieldsDescription   PlanSortFields = "description"
	PlanSortFieldsDisplayName   PlanSortFields = "displayName"
	PlanSortFieldsEnvironmentID PlanSortFields = "environmentId"
	PlanSortFieldsID            PlanSortFields = "id"
	PlanSortFieldsIsLatest      PlanSortFields = "isLatest"
	PlanSortFieldsPricingType   PlanSortFields = "pricingType"
	PlanSortFieldsProductID     PlanSortFields = "productId"
	PlanSortFieldsRefID         PlanSortFields = "refId"
	PlanSortFieldsStatus        PlanSortFields = "status"
	PlanSortFieldsUpdatedAt     PlanSortFields = "updatedAt"
	PlanSortFieldsVersionNumber PlanSortFields = "versionNumber"
)

var AllPlanSortFields = []PlanSortFields{
	PlanSortFieldsBillingID,
	PlanSortFieldsCreatedAt,
	PlanSortFieldsDescription,
	PlanSortFieldsDisplayName,
	PlanSortFieldsEnvironmentID,
	PlanSortFieldsID,
	PlanSortFieldsIsLatest,
	PlanSortFieldsPricingType,
	PlanSortFieldsProductID,
	PlanSortFieldsRefID,
	PlanSortFieldsStatus,
	PlanSortFieldsUpdatedAt,
	PlanSortFieldsVersionNumber,
}

func (e PlanSortFields) IsValid() bool {
	switch e {
	case PlanSortFieldsBillingID, PlanSortFieldsCreatedAt, PlanSortFieldsDescription, PlanSortFieldsDisplayName, PlanSortFieldsEnvironmentID, PlanSortFieldsID, PlanSortFieldsIsLatest, PlanSortFieldsPricingType, PlanSortFieldsProductID, PlanSortFieldsRefID, PlanSortFieldsStatus, PlanSortFieldsUpdatedAt, PlanSortFieldsVersionNumber:
		return true
	}
	return false
}

func (e PlanSortFields) String() string {
	return string(e)
}

func (e *PlanSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlanSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlanSortFields", str)
	}
	return nil
}

func (e PlanSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PriceSortFields string

const (
	PriceSortFieldsBillingCadence PriceSortFields = "billingCadence"
	PriceSortFieldsBillingID      PriceSortFields = "billingId"
	PriceSortFieldsBillingModel   PriceSortFields = "billingModel"
	PriceSortFieldsBillingPeriod  PriceSortFields = "billingPeriod"
	PriceSortFieldsCreatedAt      PriceSortFields = "createdAt"
	PriceSortFieldsID             PriceSortFields = "id"
	PriceSortFieldsTiersMode      PriceSortFields = "tiersMode"
)

var AllPriceSortFields = []PriceSortFields{
	PriceSortFieldsBillingCadence,
	PriceSortFieldsBillingID,
	PriceSortFieldsBillingModel,
	PriceSortFieldsBillingPeriod,
	PriceSortFieldsCreatedAt,
	PriceSortFieldsID,
	PriceSortFieldsTiersMode,
}

func (e PriceSortFields) IsValid() bool {
	switch e {
	case PriceSortFieldsBillingCadence, PriceSortFieldsBillingID, PriceSortFieldsBillingModel, PriceSortFieldsBillingPeriod, PriceSortFieldsCreatedAt, PriceSortFieldsID, PriceSortFieldsTiersMode:
		return true
	}
	return false
}

func (e PriceSortFields) String() string {
	return string(e)
}

func (e *PriceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceSortFields", str)
	}
	return nil
}

func (e PriceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pricing Type.
type PricingType string

const (
	PricingTypeCustom PricingType = "CUSTOM"
	PricingTypeFree   PricingType = "FREE"
	PricingTypePaid   PricingType = "PAID"
)

var AllPricingType = []PricingType{
	PricingTypeCustom,
	PricingTypeFree,
	PricingTypePaid,
}

func (e PricingType) IsValid() bool {
	switch e {
	case PricingTypeCustom, PricingTypeFree, PricingTypePaid:
		return true
	}
	return false
}

func (e PricingType) String() string {
	return string(e)
}

func (e *PricingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PricingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PricingType", str)
	}
	return nil
}

func (e PricingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductSortFields string

const (
	ProductSortFieldsAwsMarketplaceProductCode ProductSortFields = "awsMarketplaceProductCode"
	ProductSortFieldsAwsMarketplaceProductID   ProductSortFields = "awsMarketplaceProductId"
	ProductSortFieldsCreatedAt                 ProductSortFields = "createdAt"
	ProductSortFieldsDescription               ProductSortFields = "description"
	ProductSortFieldsDisplayName               ProductSortFields = "displayName"
	ProductSortFieldsEnvironmentID             ProductSortFields = "environmentId"
	ProductSortFieldsID                        ProductSortFields = "id"
	ProductSortFieldsIsDefaultProduct          ProductSortFields = "isDefaultProduct"
	ProductSortFieldsMultipleSubscriptions     ProductSortFields = "multipleSubscriptions"
	ProductSortFieldsRefID                     ProductSortFields = "refId"
	ProductSortFieldsUpdatedAt                 ProductSortFields = "updatedAt"
)

var AllProductSortFields = []ProductSortFields{
	ProductSortFieldsAwsMarketplaceProductCode,
	ProductSortFieldsAwsMarketplaceProductID,
	ProductSortFieldsCreatedAt,
	ProductSortFieldsDescription,
	ProductSortFieldsDisplayName,
	ProductSortFieldsEnvironmentID,
	ProductSortFieldsID,
	ProductSortFieldsIsDefaultProduct,
	ProductSortFieldsMultipleSubscriptions,
	ProductSortFieldsRefID,
	ProductSortFieldsUpdatedAt,
}

func (e ProductSortFields) IsValid() bool {
	switch e {
	case ProductSortFieldsAwsMarketplaceProductCode, ProductSortFieldsAwsMarketplaceProductID, ProductSortFieldsCreatedAt, ProductSortFieldsDescription, ProductSortFieldsDisplayName, ProductSortFieldsEnvironmentID, ProductSortFieldsID, ProductSortFieldsIsDefaultProduct, ProductSortFieldsMultipleSubscriptions, ProductSortFieldsRefID, ProductSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e ProductSortFields) String() string {
	return string(e)
}

func (e *ProductSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortFields", str)
	}
	return nil
}

func (e ProductSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Promotional entitlement duration
type PromotionalEntitlementPeriod string

const (
	PromotionalEntitlementPeriodCustom PromotionalEntitlementPeriod = "CUSTOM"
	// Lifetime
	PromotionalEntitlementPeriodLifetime PromotionalEntitlementPeriod = "LIFETIME"
	// One month
	PromotionalEntitlementPeriodOneMonth PromotionalEntitlementPeriod = "ONE_MONTH"
	// One week
	PromotionalEntitlementPeriodOneWeek PromotionalEntitlementPeriod = "ONE_WEEK"
	// One year
	PromotionalEntitlementPeriodOneYear PromotionalEntitlementPeriod = "ONE_YEAR"
	// Six months
	PromotionalEntitlementPeriodSixMonth PromotionalEntitlementPeriod = "SIX_MONTH"
)

var AllPromotionalEntitlementPeriod = []PromotionalEntitlementPeriod{
	PromotionalEntitlementPeriodCustom,
	PromotionalEntitlementPeriodLifetime,
	PromotionalEntitlementPeriodOneMonth,
	PromotionalEntitlementPeriodOneWeek,
	PromotionalEntitlementPeriodOneYear,
	PromotionalEntitlementPeriodSixMonth,
}

func (e PromotionalEntitlementPeriod) IsValid() bool {
	switch e {
	case PromotionalEntitlementPeriodCustom, PromotionalEntitlementPeriodLifetime, PromotionalEntitlementPeriodOneMonth, PromotionalEntitlementPeriodOneWeek, PromotionalEntitlementPeriodOneYear, PromotionalEntitlementPeriodSixMonth:
		return true
	}
	return false
}

func (e PromotionalEntitlementPeriod) String() string {
	return string(e)
}

func (e *PromotionalEntitlementPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementPeriod", str)
	}
	return nil
}

func (e PromotionalEntitlementPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PromotionalEntitlementSortFields string

const (
	PromotionalEntitlementSortFieldsCreatedAt     PromotionalEntitlementSortFields = "createdAt"
	PromotionalEntitlementSortFieldsEnvironmentID PromotionalEntitlementSortFields = "environmentId"
	PromotionalEntitlementSortFieldsID            PromotionalEntitlementSortFields = "id"
	PromotionalEntitlementSortFieldsStatus        PromotionalEntitlementSortFields = "status"
	PromotionalEntitlementSortFieldsUpdatedAt     PromotionalEntitlementSortFields = "updatedAt"
)

var AllPromotionalEntitlementSortFields = []PromotionalEntitlementSortFields{
	PromotionalEntitlementSortFieldsCreatedAt,
	PromotionalEntitlementSortFieldsEnvironmentID,
	PromotionalEntitlementSortFieldsID,
	PromotionalEntitlementSortFieldsStatus,
	PromotionalEntitlementSortFieldsUpdatedAt,
}

func (e PromotionalEntitlementSortFields) IsValid() bool {
	switch e {
	case PromotionalEntitlementSortFieldsCreatedAt, PromotionalEntitlementSortFieldsEnvironmentID, PromotionalEntitlementSortFieldsID, PromotionalEntitlementSortFieldsStatus, PromotionalEntitlementSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e PromotionalEntitlementSortFields) String() string {
	return string(e)
}

func (e *PromotionalEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementSortFields", str)
	}
	return nil
}

func (e PromotionalEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Promotional entitlement status
type PromotionalEntitlementStatus string

const (
	// Active
	PromotionalEntitlementStatusActive PromotionalEntitlementStatus = "Active"
	// Expired
	PromotionalEntitlementStatusExpired PromotionalEntitlementStatus = "Expired"
	// Paused
	PromotionalEntitlementStatusPaused PromotionalEntitlementStatus = "Paused"
)

var AllPromotionalEntitlementStatus = []PromotionalEntitlementStatus{
	PromotionalEntitlementStatusActive,
	PromotionalEntitlementStatusExpired,
	PromotionalEntitlementStatusPaused,
}

func (e PromotionalEntitlementStatus) IsValid() bool {
	switch e {
	case PromotionalEntitlementStatusActive, PromotionalEntitlementStatusExpired, PromotionalEntitlementStatusPaused:
		return true
	}
	return false
}

func (e PromotionalEntitlementStatus) String() string {
	return string(e)
}

func (e *PromotionalEntitlementStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionalEntitlementStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionalEntitlementStatus", str)
	}
	return nil
}

func (e PromotionalEntitlementStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Proration behavior for subscription billing
type ProrationBehavior string

const (
	// Create proration invoice items for changes in the subscription
	ProrationBehaviorCreateProrations ProrationBehavior = "CREATE_PRORATIONS"
	// Invoice immediately for changes in the subscription without proration
	ProrationBehaviorInvoiceImmediately ProrationBehavior = "INVOICE_IMMEDIATELY"
)

var AllProrationBehavior = []ProrationBehavior{
	ProrationBehaviorCreateProrations,
	ProrationBehaviorInvoiceImmediately,
}

func (e ProrationBehavior) IsValid() bool {
	switch e {
	case ProrationBehaviorCreateProrations, ProrationBehaviorInvoiceImmediately:
		return true
	}
	return false
}

func (e ProrationBehavior) String() string {
	return string(e)
}

func (e *ProrationBehavior) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProrationBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProrationBehavior", str)
	}
	return nil
}

func (e ProrationBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Provision subscription status
type ProvisionSubscriptionStatus string

const (
	ProvisionSubscriptionStatusPaymentRequired ProvisionSubscriptionStatus = "PAYMENT_REQUIRED"
	ProvisionSubscriptionStatusSuccess         ProvisionSubscriptionStatus = "SUCCESS"
)

var AllProvisionSubscriptionStatus = []ProvisionSubscriptionStatus{
	ProvisionSubscriptionStatusPaymentRequired,
	ProvisionSubscriptionStatusSuccess,
}

func (e ProvisionSubscriptionStatus) IsValid() bool {
	switch e {
	case ProvisionSubscriptionStatusPaymentRequired, ProvisionSubscriptionStatusSuccess:
		return true
	}
	return false
}

func (e ProvisionSubscriptionStatus) String() string {
	return string(e)
}

func (e *ProvisionSubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisionSubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisionSubscriptionStatus", str)
	}
	return nil
}

func (e ProvisionSubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The migration type, either publish the new version to new customers or all customers
type PublishMigrationType string

const (
	// Publish to all customers
	PublishMigrationTypeAllCustomers PublishMigrationType = "ALL_CUSTOMERS"
	// Publish only to new customers
	PublishMigrationTypeNewCustomers PublishMigrationType = "NEW_CUSTOMERS"
)

var AllPublishMigrationType = []PublishMigrationType{
	PublishMigrationTypeAllCustomers,
	PublishMigrationTypeNewCustomers,
}

func (e PublishMigrationType) IsValid() bool {
	switch e {
	case PublishMigrationTypeAllCustomers, PublishMigrationTypeNewCustomers:
		return true
	}
	return false
}

func (e PublishMigrationType) String() string {
	return string(e)
}

func (e *PublishMigrationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishMigrationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishMigrationType", str)
	}
	return nil
}

func (e PublishMigrationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Options for when a change for a paid subscription should take effect
type ScheduleStrategy string

const (
	// Schedule the change to the end of the billing month (for subscriptions whose billing period is larger then month)
	ScheduleStrategyEndOfBillingMonth ScheduleStrategy = "END_OF_BILLING_MONTH"
	// Schedule the change to the end of the billing period
	ScheduleStrategyEndOfBillingPeriod ScheduleStrategy = "END_OF_BILLING_PERIOD"
	// Apply the change immediately
	ScheduleStrategyImmediate ScheduleStrategy = "IMMEDIATE"
)

var AllScheduleStrategy = []ScheduleStrategy{
	ScheduleStrategyEndOfBillingMonth,
	ScheduleStrategyEndOfBillingPeriod,
	ScheduleStrategyImmediate,
}

func (e ScheduleStrategy) IsValid() bool {
	switch e {
	case ScheduleStrategyEndOfBillingMonth, ScheduleStrategyEndOfBillingPeriod, ScheduleStrategyImmediate:
		return true
	}
	return false
}

func (e ScheduleStrategy) String() string {
	return string(e)
}

func (e *ScheduleStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduleStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduleStrategy", str)
	}
	return nil
}

func (e ScheduleStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort Directions
type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort Nulls Options
type SortNulls string

const (
	SortNullsNullsFirst SortNulls = "NULLS_FIRST"
	SortNullsNullsLast  SortNulls = "NULLS_LAST"
)

var AllSortNulls = []SortNulls{
	SortNullsNullsFirst,
	SortNullsNullsLast,
}

func (e SortNulls) IsValid() bool {
	switch e {
	case SortNullsNullsFirst, SortNullsNullsLast:
		return true
	}
	return false
}

func (e SortNulls) String() string {
	return string(e)
}

func (e *SortNulls) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortNulls(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortNulls", str)
	}
	return nil
}

func (e SortNulls) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SourceType string

const (
	SourceTypeJsClientSdk            SourceType = "JS_CLIENT_SDK"
	SourceTypeNodeServerSdk          SourceType = "NODE_SERVER_SDK"
	SourceTypePersistentCacheService SourceType = "PERSISTENT_CACHE_SERVICE"
)

var AllSourceType = []SourceType{
	SourceTypeJsClientSdk,
	SourceTypeNodeServerSdk,
	SourceTypePersistentCacheService,
}

func (e SourceType) IsValid() bool {
	switch e {
	case SourceTypeJsClientSdk, SourceTypeNodeServerSdk, SourceTypePersistentCacheService:
		return true
	}
	return false
}

func (e SourceType) String() string {
	return string(e)
}

func (e *SourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SourceType", str)
	}
	return nil
}

func (e SourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionAddonSortFields string

const (
	SubscriptionAddonSortFieldsCreatedAt SubscriptionAddonSortFields = "createdAt"
	SubscriptionAddonSortFieldsID        SubscriptionAddonSortFields = "id"
	SubscriptionAddonSortFieldsQuantity  SubscriptionAddonSortFields = "quantity"
	SubscriptionAddonSortFieldsUpdatedAt SubscriptionAddonSortFields = "updatedAt"
)

var AllSubscriptionAddonSortFields = []SubscriptionAddonSortFields{
	SubscriptionAddonSortFieldsCreatedAt,
	SubscriptionAddonSortFieldsID,
	SubscriptionAddonSortFieldsQuantity,
	SubscriptionAddonSortFieldsUpdatedAt,
}

func (e SubscriptionAddonSortFields) IsValid() bool {
	switch e {
	case SubscriptionAddonSortFieldsCreatedAt, SubscriptionAddonSortFieldsID, SubscriptionAddonSortFieldsQuantity, SubscriptionAddonSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionAddonSortFields) String() string {
	return string(e)
}

func (e *SubscriptionAddonSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionAddonSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionAddonSortFields", str)
	}
	return nil
}

func (e SubscriptionAddonSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription cancellation status
type SubscriptionCancelReason string

const (
	SubscriptionCancelReasonAutoCancellationRule  SubscriptionCancelReason = "AutoCancellationRule"
	SubscriptionCancelReasonCancelledByBilling    SubscriptionCancelReason = "CancelledByBilling"
	SubscriptionCancelReasonCustomerArchived      SubscriptionCancelReason = "CustomerArchived"
	SubscriptionCancelReasonDetachBilling         SubscriptionCancelReason = "DetachBilling"
	SubscriptionCancelReasonExpired               SubscriptionCancelReason = "Expired"
	SubscriptionCancelReasonImmediate             SubscriptionCancelReason = "Immediate"
	SubscriptionCancelReasonPendingPaymentExpired SubscriptionCancelReason = "PendingPaymentExpired"
	SubscriptionCancelReasonScheduledCancellation SubscriptionCancelReason = "ScheduledCancellation"
	SubscriptionCancelReasonTrialConverted        SubscriptionCancelReason = "TrialConverted"
	SubscriptionCancelReasonTrialEnded            SubscriptionCancelReason = "TrialEnded"
	SubscriptionCancelReasonUpgradeOrDowngrade    SubscriptionCancelReason = "UpgradeOrDowngrade"
)

var AllSubscriptionCancelReason = []SubscriptionCancelReason{
	SubscriptionCancelReasonAutoCancellationRule,
	SubscriptionCancelReasonCancelledByBilling,
	SubscriptionCancelReasonCustomerArchived,
	SubscriptionCancelReasonDetachBilling,
	SubscriptionCancelReasonExpired,
	SubscriptionCancelReasonImmediate,
	SubscriptionCancelReasonPendingPaymentExpired,
	SubscriptionCancelReasonScheduledCancellation,
	SubscriptionCancelReasonTrialConverted,
	SubscriptionCancelReasonTrialEnded,
	SubscriptionCancelReasonUpgradeOrDowngrade,
}

func (e SubscriptionCancelReason) IsValid() bool {
	switch e {
	case SubscriptionCancelReasonAutoCancellationRule, SubscriptionCancelReasonCancelledByBilling, SubscriptionCancelReasonCustomerArchived, SubscriptionCancelReasonDetachBilling, SubscriptionCancelReasonExpired, SubscriptionCancelReasonImmediate, SubscriptionCancelReasonPendingPaymentExpired, SubscriptionCancelReasonScheduledCancellation, SubscriptionCancelReasonTrialConverted, SubscriptionCancelReasonTrialEnded, SubscriptionCancelReasonUpgradeOrDowngrade:
		return true
	}
	return false
}

func (e SubscriptionCancelReason) String() string {
	return string(e)
}

func (e *SubscriptionCancelReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancelReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancelReason", str)
	}
	return nil
}

func (e SubscriptionCancelReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Action to take when a subscription is cancelled
type SubscriptionCancellationAction string

const (
	// Default action
	SubscriptionCancellationActionDefault SubscriptionCancellationAction = "DEFAULT"
	// Revoke entitlements action
	SubscriptionCancellationActionRevokeEntitlements SubscriptionCancellationAction = "REVOKE_ENTITLEMENTS"
)

var AllSubscriptionCancellationAction = []SubscriptionCancellationAction{
	SubscriptionCancellationActionDefault,
	SubscriptionCancellationActionRevokeEntitlements,
}

func (e SubscriptionCancellationAction) IsValid() bool {
	switch e {
	case SubscriptionCancellationActionDefault, SubscriptionCancellationActionRevokeEntitlements:
		return true
	}
	return false
}

func (e SubscriptionCancellationAction) String() string {
	return string(e)
}

func (e *SubscriptionCancellationAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancellationAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancellationAction", str)
	}
	return nil
}

func (e SubscriptionCancellationAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// When the subscription will be cancelled
type SubscriptionCancellationTime string

const (
	// At the end of the billing period
	SubscriptionCancellationTimeEndOfBillingPeriod SubscriptionCancellationTime = "END_OF_BILLING_PERIOD"
	// Immediately
	SubscriptionCancellationTimeImmediate SubscriptionCancellationTime = "IMMEDIATE"
	// On a specific date
	SubscriptionCancellationTimeSpecificDate SubscriptionCancellationTime = "SPECIFIC_DATE"
)

var AllSubscriptionCancellationTime = []SubscriptionCancellationTime{
	SubscriptionCancellationTimeEndOfBillingPeriod,
	SubscriptionCancellationTimeImmediate,
	SubscriptionCancellationTimeSpecificDate,
}

func (e SubscriptionCancellationTime) IsValid() bool {
	switch e {
	case SubscriptionCancellationTimeEndOfBillingPeriod, SubscriptionCancellationTimeImmediate, SubscriptionCancellationTimeSpecificDate:
		return true
	}
	return false
}

func (e SubscriptionCancellationTime) String() string {
	return string(e)
}

func (e *SubscriptionCancellationTime) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCancellationTime(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCancellationTime", str)
	}
	return nil
}

func (e SubscriptionCancellationTime) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the subscription coupon
type SubscriptionCouponStatus string

const (
	SubscriptionCouponStatusActive  SubscriptionCouponStatus = "ACTIVE"
	SubscriptionCouponStatusExpired SubscriptionCouponStatus = "EXPIRED"
	SubscriptionCouponStatusRemoved SubscriptionCouponStatus = "REMOVED"
)

var AllSubscriptionCouponStatus = []SubscriptionCouponStatus{
	SubscriptionCouponStatusActive,
	SubscriptionCouponStatusExpired,
	SubscriptionCouponStatusRemoved,
}

func (e SubscriptionCouponStatus) IsValid() bool {
	switch e {
	case SubscriptionCouponStatusActive, SubscriptionCouponStatusExpired, SubscriptionCouponStatusRemoved:
		return true
	}
	return false
}

func (e SubscriptionCouponStatus) String() string {
	return string(e)
}

func (e *SubscriptionCouponStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCouponStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCouponStatus", str)
	}
	return nil
}

func (e SubscriptionCouponStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription decision strategy
type SubscriptionDecisionStrategy string

const (
	SubscriptionDecisionStrategyPredefinedFreePlan          SubscriptionDecisionStrategy = "PREDEFINED_FREE_PLAN"
	SubscriptionDecisionStrategyPredefinedTrialPlan         SubscriptionDecisionStrategy = "PREDEFINED_TRIAL_PLAN"
	SubscriptionDecisionStrategyRequestedPlan               SubscriptionDecisionStrategy = "REQUESTED_PLAN"
	SubscriptionDecisionStrategySkippedSubscriptionCreation SubscriptionDecisionStrategy = "SKIPPED_SUBSCRIPTION_CREATION"
)

var AllSubscriptionDecisionStrategy = []SubscriptionDecisionStrategy{
	SubscriptionDecisionStrategyPredefinedFreePlan,
	SubscriptionDecisionStrategyPredefinedTrialPlan,
	SubscriptionDecisionStrategyRequestedPlan,
	SubscriptionDecisionStrategySkippedSubscriptionCreation,
}

func (e SubscriptionDecisionStrategy) IsValid() bool {
	switch e {
	case SubscriptionDecisionStrategyPredefinedFreePlan, SubscriptionDecisionStrategyPredefinedTrialPlan, SubscriptionDecisionStrategyRequestedPlan, SubscriptionDecisionStrategySkippedSubscriptionCreation:
		return true
	}
	return false
}

func (e SubscriptionDecisionStrategy) String() string {
	return string(e)
}

func (e *SubscriptionDecisionStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionDecisionStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionDecisionStrategy", str)
	}
	return nil
}

func (e SubscriptionDecisionStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Setup for the end of the subscription
type SubscriptionEndSetup string

const (
	// Cancel subscription
	SubscriptionEndSetupCancelSubscription SubscriptionEndSetup = "CANCEL_SUBSCRIPTION"
	// Downgrade to free plan
	SubscriptionEndSetupDowngradeToFree SubscriptionEndSetup = "DOWNGRADE_TO_FREE"
)

var AllSubscriptionEndSetup = []SubscriptionEndSetup{
	SubscriptionEndSetupCancelSubscription,
	SubscriptionEndSetupDowngradeToFree,
}

func (e SubscriptionEndSetup) IsValid() bool {
	switch e {
	case SubscriptionEndSetupCancelSubscription, SubscriptionEndSetupDowngradeToFree:
		return true
	}
	return false
}

func (e SubscriptionEndSetup) String() string {
	return string(e)
}

func (e *SubscriptionEndSetup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEndSetup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionEndSetup", str)
	}
	return nil
}

func (e SubscriptionEndSetup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionEntitlementSortFields string

const (
	SubscriptionEntitlementSortFieldsCreatedAt      SubscriptionEntitlementSortFields = "createdAt"
	SubscriptionEntitlementSortFieldsEnvironmentID  SubscriptionEntitlementSortFields = "environmentId"
	SubscriptionEntitlementSortFieldsID             SubscriptionEntitlementSortFields = "id"
	SubscriptionEntitlementSortFieldsSubscriptionID SubscriptionEntitlementSortFields = "subscriptionId"
	SubscriptionEntitlementSortFieldsUpdatedAt      SubscriptionEntitlementSortFields = "updatedAt"
)

var AllSubscriptionEntitlementSortFields = []SubscriptionEntitlementSortFields{
	SubscriptionEntitlementSortFieldsCreatedAt,
	SubscriptionEntitlementSortFieldsEnvironmentID,
	SubscriptionEntitlementSortFieldsID,
	SubscriptionEntitlementSortFieldsSubscriptionID,
	SubscriptionEntitlementSortFieldsUpdatedAt,
}

func (e SubscriptionEntitlementSortFields) IsValid() bool {
	switch e {
	case SubscriptionEntitlementSortFieldsCreatedAt, SubscriptionEntitlementSortFieldsEnvironmentID, SubscriptionEntitlementSortFieldsID, SubscriptionEntitlementSortFieldsSubscriptionID, SubscriptionEntitlementSortFieldsUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionEntitlementSortFields) String() string {
	return string(e)
}

func (e *SubscriptionEntitlementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEntitlementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionEntitlementSortFields", str)
	}
	return nil
}

func (e SubscriptionEntitlementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason the billing event was created.
type SubscriptionInvoiceBillingReason string

const (
	// A subscription advanced into a new billing cycle.
	SubscriptionInvoiceBillingReasonBillingCycle SubscriptionInvoiceBillingReason = "BILLING_CYCLE"
	// An invoice was created manually.
	SubscriptionInvoiceBillingReasonManual SubscriptionInvoiceBillingReason = "MANUAL"
	// A subscription passed the minimum invoice amount
	SubscriptionInvoiceBillingReasonMinimumInvoiceAmountExceeded SubscriptionInvoiceBillingReason = "MINIMUM_INVOICE_AMOUNT_EXCEEDED"
	// An invoice was created for another reason.
	SubscriptionInvoiceBillingReasonOther SubscriptionInvoiceBillingReason = "OTHER"
	// A subscription was created.
	SubscriptionInvoiceBillingReasonSubscriptionCreation SubscriptionInvoiceBillingReason = "SUBSCRIPTION_CREATION"
	// A subscription was updated.
	SubscriptionInvoiceBillingReasonSubscriptionUpdate SubscriptionInvoiceBillingReason = "SUBSCRIPTION_UPDATE"
)

var AllSubscriptionInvoiceBillingReason = []SubscriptionInvoiceBillingReason{
	SubscriptionInvoiceBillingReasonBillingCycle,
	SubscriptionInvoiceBillingReasonManual,
	SubscriptionInvoiceBillingReasonMinimumInvoiceAmountExceeded,
	SubscriptionInvoiceBillingReasonOther,
	SubscriptionInvoiceBillingReasonSubscriptionCreation,
	SubscriptionInvoiceBillingReasonSubscriptionUpdate,
}

func (e SubscriptionInvoiceBillingReason) IsValid() bool {
	switch e {
	case SubscriptionInvoiceBillingReasonBillingCycle, SubscriptionInvoiceBillingReasonManual, SubscriptionInvoiceBillingReasonMinimumInvoiceAmountExceeded, SubscriptionInvoiceBillingReasonOther, SubscriptionInvoiceBillingReasonSubscriptionCreation, SubscriptionInvoiceBillingReasonSubscriptionUpdate:
		return true
	}
	return false
}

func (e SubscriptionInvoiceBillingReason) String() string {
	return string(e)
}

func (e *SubscriptionInvoiceBillingReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionInvoiceBillingReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionInvoiceBillingReason", str)
	}
	return nil
}

func (e SubscriptionInvoiceBillingReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SubscriptionInvoice status
type SubscriptionInvoiceStatus string

const (
	SubscriptionInvoiceStatusCanceled SubscriptionInvoiceStatus = "CANCELED"
	SubscriptionInvoiceStatusOpen     SubscriptionInvoiceStatus = "OPEN"
	SubscriptionInvoiceStatusPaid     SubscriptionInvoiceStatus = "PAID"
)

var AllSubscriptionInvoiceStatus = []SubscriptionInvoiceStatus{
	SubscriptionInvoiceStatusCanceled,
	SubscriptionInvoiceStatusOpen,
	SubscriptionInvoiceStatusPaid,
}

func (e SubscriptionInvoiceStatus) IsValid() bool {
	switch e {
	case SubscriptionInvoiceStatusCanceled, SubscriptionInvoiceStatusOpen, SubscriptionInvoiceStatusPaid:
		return true
	}
	return false
}

func (e SubscriptionInvoiceStatus) String() string {
	return string(e)
}

func (e *SubscriptionInvoiceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionInvoiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionInvoiceStatus", str)
	}
	return nil
}

func (e SubscriptionInvoiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionMigrationTaskSortFields string

const (
	SubscriptionMigrationTaskSortFieldsCreatedAt     SubscriptionMigrationTaskSortFields = "createdAt"
	SubscriptionMigrationTaskSortFieldsEnvironmentID SubscriptionMigrationTaskSortFields = "environmentId"
	SubscriptionMigrationTaskSortFieldsID            SubscriptionMigrationTaskSortFields = "id"
	SubscriptionMigrationTaskSortFieldsStatus        SubscriptionMigrationTaskSortFields = "status"
	SubscriptionMigrationTaskSortFieldsTaskType      SubscriptionMigrationTaskSortFields = "taskType"
)

var AllSubscriptionMigrationTaskSortFields = []SubscriptionMigrationTaskSortFields{
	SubscriptionMigrationTaskSortFieldsCreatedAt,
	SubscriptionMigrationTaskSortFieldsEnvironmentID,
	SubscriptionMigrationTaskSortFieldsID,
	SubscriptionMigrationTaskSortFieldsStatus,
	SubscriptionMigrationTaskSortFieldsTaskType,
}

func (e SubscriptionMigrationTaskSortFields) IsValid() bool {
	switch e {
	case SubscriptionMigrationTaskSortFieldsCreatedAt, SubscriptionMigrationTaskSortFieldsEnvironmentID, SubscriptionMigrationTaskSortFieldsID, SubscriptionMigrationTaskSortFieldsStatus, SubscriptionMigrationTaskSortFieldsTaskType:
		return true
	}
	return false
}

func (e SubscriptionMigrationTaskSortFields) String() string {
	return string(e)
}

func (e *SubscriptionMigrationTaskSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionMigrationTaskSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionMigrationTaskSortFields", str)
	}
	return nil
}

func (e SubscriptionMigrationTaskSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Set non immediate cancellation time (atm supported only for stripe integration)
type SubscriptionMigrationTime string

const (
	SubscriptionMigrationTimeEndOfBillingPeriod SubscriptionMigrationTime = "END_OF_BILLING_PERIOD"
	SubscriptionMigrationTimeImmediate          SubscriptionMigrationTime = "IMMEDIATE"
)

var AllSubscriptionMigrationTime = []SubscriptionMigrationTime{
	SubscriptionMigrationTimeEndOfBillingPeriod,
	SubscriptionMigrationTimeImmediate,
}

func (e SubscriptionMigrationTime) IsValid() bool {
	switch e {
	case SubscriptionMigrationTimeEndOfBillingPeriod, SubscriptionMigrationTimeImmediate:
		return true
	}
	return false
}

func (e SubscriptionMigrationTime) String() string {
	return string(e)
}

func (e *SubscriptionMigrationTime) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionMigrationTime(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionMigrationTime", str)
	}
	return nil
}

func (e SubscriptionMigrationTime) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionPriceSortFields string

const (
	SubscriptionPriceSortFieldsBillingModel SubscriptionPriceSortFields = "billingModel"
	SubscriptionPriceSortFieldsCreatedAt    SubscriptionPriceSortFields = "createdAt"
	SubscriptionPriceSortFieldsFeatureID    SubscriptionPriceSortFields = "featureId"
	SubscriptionPriceSortFieldsHasSoftLimit SubscriptionPriceSortFields = "hasSoftLimit"
	SubscriptionPriceSortFieldsID           SubscriptionPriceSortFields = "id"
	SubscriptionPriceSortFieldsUpdatedAt    SubscriptionPriceSortFields = "updatedAt"
	SubscriptionPriceSortFieldsUsageLimit   SubscriptionPriceSortFields = "usageLimit"
)

var AllSubscriptionPriceSortFields = []SubscriptionPriceSortFields{
	SubscriptionPriceSortFieldsBillingModel,
	SubscriptionPriceSortFieldsCreatedAt,
	SubscriptionPriceSortFieldsFeatureID,
	SubscriptionPriceSortFieldsHasSoftLimit,
	SubscriptionPriceSortFieldsID,
	SubscriptionPriceSortFieldsUpdatedAt,
	SubscriptionPriceSortFieldsUsageLimit,
}

func (e SubscriptionPriceSortFields) IsValid() bool {
	switch e {
	case SubscriptionPriceSortFieldsBillingModel, SubscriptionPriceSortFieldsCreatedAt, SubscriptionPriceSortFieldsFeatureID, SubscriptionPriceSortFieldsHasSoftLimit, SubscriptionPriceSortFieldsID, SubscriptionPriceSortFieldsUpdatedAt, SubscriptionPriceSortFieldsUsageLimit:
		return true
	}
	return false
}

func (e SubscriptionPriceSortFields) String() string {
	return string(e)
}

func (e *SubscriptionPriceSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPriceSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionPriceSortFields", str)
	}
	return nil
}

func (e SubscriptionPriceSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionQuerySortFields string

const (
	SubscriptionQuerySortFieldsCreatedAt     SubscriptionQuerySortFields = "createdAt"
	SubscriptionQuerySortFieldsCustomerID    SubscriptionQuerySortFields = "customerId"
	SubscriptionQuerySortFieldsEnvironmentID SubscriptionQuerySortFields = "environmentId"
	SubscriptionQuerySortFieldsProductID     SubscriptionQuerySortFields = "productId"
	SubscriptionQuerySortFieldsResourceID    SubscriptionQuerySortFields = "resourceId"
	SubscriptionQuerySortFieldsStatus        SubscriptionQuerySortFields = "status"
)

var AllSubscriptionQuerySortFields = []SubscriptionQuerySortFields{
	SubscriptionQuerySortFieldsCreatedAt,
	SubscriptionQuerySortFieldsCustomerID,
	SubscriptionQuerySortFieldsEnvironmentID,
	SubscriptionQuerySortFieldsProductID,
	SubscriptionQuerySortFieldsResourceID,
	SubscriptionQuerySortFieldsStatus,
}

func (e SubscriptionQuerySortFields) IsValid() bool {
	switch e {
	case SubscriptionQuerySortFieldsCreatedAt, SubscriptionQuerySortFieldsCustomerID, SubscriptionQuerySortFieldsEnvironmentID, SubscriptionQuerySortFieldsProductID, SubscriptionQuerySortFieldsResourceID, SubscriptionQuerySortFieldsStatus:
		return true
	}
	return false
}

func (e SubscriptionQuerySortFields) String() string {
	return string(e)
}

func (e *SubscriptionQuerySortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionQuerySortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionQuerySortFields", str)
	}
	return nil
}

func (e SubscriptionQuerySortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription scheduled schedule status
type SubscriptionScheduleStatus string

const (
	SubscriptionScheduleStatusCanceled       SubscriptionScheduleStatus = "Canceled"
	SubscriptionScheduleStatusDone           SubscriptionScheduleStatus = "Done"
	SubscriptionScheduleStatusFailed         SubscriptionScheduleStatus = "Failed"
	SubscriptionScheduleStatusPendingPayment SubscriptionScheduleStatus = "PendingPayment"
	SubscriptionScheduleStatusScheduled      SubscriptionScheduleStatus = "Scheduled"
)

var AllSubscriptionScheduleStatus = []SubscriptionScheduleStatus{
	SubscriptionScheduleStatusCanceled,
	SubscriptionScheduleStatusDone,
	SubscriptionScheduleStatusFailed,
	SubscriptionScheduleStatusPendingPayment,
	SubscriptionScheduleStatusScheduled,
}

func (e SubscriptionScheduleStatus) IsValid() bool {
	switch e {
	case SubscriptionScheduleStatusCanceled, SubscriptionScheduleStatusDone, SubscriptionScheduleStatusFailed, SubscriptionScheduleStatusPendingPayment, SubscriptionScheduleStatusScheduled:
		return true
	}
	return false
}

func (e SubscriptionScheduleStatus) String() string {
	return string(e)
}

func (e *SubscriptionScheduleStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionScheduleStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionScheduleStatus", str)
	}
	return nil
}

func (e SubscriptionScheduleStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription scheduled schedule type
type SubscriptionScheduleType string

const (
	// Additional metadata change
	SubscriptionScheduleTypeAdditionalMetaData SubscriptionScheduleType = "AdditionalMetaData"
	// Addon change
	SubscriptionScheduleTypeAddon SubscriptionScheduleType = "Addon"
	// Billing info metadata change
	SubscriptionScheduleTypeBillingInfoMetadata SubscriptionScheduleType = "BillingInfoMetadata"
	// Billing period change
	SubscriptionScheduleTypeBillingPeriod SubscriptionScheduleType = "BillingPeriod"
	// Coupon change
	SubscriptionScheduleTypeCoupon SubscriptionScheduleType = "Coupon"
	// Downgrade change
	SubscriptionScheduleTypeDowngrade SubscriptionScheduleType = "Downgrade"
	// Migrate to latest
	SubscriptionScheduleTypeMigrateToLatest SubscriptionScheduleType = "MigrateToLatest"
	// Plan change
	SubscriptionScheduleTypePlan SubscriptionScheduleType = "Plan"
	// Custom price change
	SubscriptionScheduleTypePriceOverride SubscriptionScheduleType = "PriceOverride"
	// Unit amount change
	SubscriptionScheduleTypeUnitAmount SubscriptionScheduleType = "UnitAmount"
)

var AllSubscriptionScheduleType = []SubscriptionScheduleType{
	SubscriptionScheduleTypeAdditionalMetaData,
	SubscriptionScheduleTypeAddon,
	SubscriptionScheduleTypeBillingInfoMetadata,
	SubscriptionScheduleTypeBillingPeriod,
	SubscriptionScheduleTypeCoupon,
	SubscriptionScheduleTypeDowngrade,
	SubscriptionScheduleTypeMigrateToLatest,
	SubscriptionScheduleTypePlan,
	SubscriptionScheduleTypePriceOverride,
	SubscriptionScheduleTypeUnitAmount,
}

func (e SubscriptionScheduleType) IsValid() bool {
	switch e {
	case SubscriptionScheduleTypeAdditionalMetaData, SubscriptionScheduleTypeAddon, SubscriptionScheduleTypeBillingInfoMetadata, SubscriptionScheduleTypeBillingPeriod, SubscriptionScheduleTypeCoupon, SubscriptionScheduleTypeDowngrade, SubscriptionScheduleTypeMigrateToLatest, SubscriptionScheduleTypePlan, SubscriptionScheduleTypePriceOverride, SubscriptionScheduleTypeUnitAmount:
		return true
	}
	return false
}

func (e SubscriptionScheduleType) String() string {
	return string(e)
}

func (e *SubscriptionScheduleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionScheduleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionScheduleType", str)
	}
	return nil
}

func (e SubscriptionScheduleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Setup for the start of the subscription
type SubscriptionStartSetup string

const (
	// Start with a free plan
	SubscriptionStartSetupFreePlan SubscriptionStartSetup = "FREE_PLAN"
	// Select a plan
	SubscriptionStartSetupPlanSelection SubscriptionStartSetup = "PLAN_SELECTION"
	// Start with a trial period
	SubscriptionStartSetupTrialPeriod SubscriptionStartSetup = "TRIAL_PERIOD"
)

var AllSubscriptionStartSetup = []SubscriptionStartSetup{
	SubscriptionStartSetupFreePlan,
	SubscriptionStartSetupPlanSelection,
	SubscriptionStartSetupTrialPeriod,
}

func (e SubscriptionStartSetup) IsValid() bool {
	switch e {
	case SubscriptionStartSetupFreePlan, SubscriptionStartSetupPlanSelection, SubscriptionStartSetupTrialPeriod:
		return true
	}
	return false
}

func (e SubscriptionStartSetup) String() string {
	return string(e)
}

func (e *SubscriptionStartSetup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStartSetup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionStartSetup", str)
	}
	return nil
}

func (e SubscriptionStartSetup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscription status
type SubscriptionStatus string

const (
	SubscriptionStatusActive         SubscriptionStatus = "ACTIVE"
	SubscriptionStatusCanceled       SubscriptionStatus = "CANCELED"
	SubscriptionStatusExpired        SubscriptionStatus = "EXPIRED"
	SubscriptionStatusInTrial        SubscriptionStatus = "IN_TRIAL"
	SubscriptionStatusNotStarted     SubscriptionStatus = "NOT_STARTED"
	SubscriptionStatusPaymentPending SubscriptionStatus = "PAYMENT_PENDING"
)

var AllSubscriptionStatus = []SubscriptionStatus{
	SubscriptionStatusActive,
	SubscriptionStatusCanceled,
	SubscriptionStatusExpired,
	SubscriptionStatusInTrial,
	SubscriptionStatusNotStarted,
	SubscriptionStatusPaymentPending,
}

func (e SubscriptionStatus) IsValid() bool {
	switch e {
	case SubscriptionStatusActive, SubscriptionStatusCanceled, SubscriptionStatusExpired, SubscriptionStatusInTrial, SubscriptionStatusNotStarted, SubscriptionStatusPaymentPending:
		return true
	}
	return false
}

func (e SubscriptionStatus) String() string {
	return string(e)
}

func (e *SubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionStatus", str)
	}
	return nil
}

func (e SubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Decide whether feature usage will be reset upon creation on new subscription
type SubscriptionUpdateUsageCutoffBehavior string

const (
	// Always reset
	SubscriptionUpdateUsageCutoffBehaviorAlwaysReset SubscriptionUpdateUsageCutoffBehavior = "ALWAYS_RESET"
	// Billing period changed
	SubscriptionUpdateUsageCutoffBehaviorBillingPeriodChange SubscriptionUpdateUsageCutoffBehavior = "BILLING_PERIOD_CHANGE"
	// Never reset
	SubscriptionUpdateUsageCutoffBehaviorNeverReset SubscriptionUpdateUsageCutoffBehavior = "NEVER_RESET"
)

var AllSubscriptionUpdateUsageCutoffBehavior = []SubscriptionUpdateUsageCutoffBehavior{
	SubscriptionUpdateUsageCutoffBehaviorAlwaysReset,
	SubscriptionUpdateUsageCutoffBehaviorBillingPeriodChange,
	SubscriptionUpdateUsageCutoffBehaviorNeverReset,
}

func (e SubscriptionUpdateUsageCutoffBehavior) IsValid() bool {
	switch e {
	case SubscriptionUpdateUsageCutoffBehaviorAlwaysReset, SubscriptionUpdateUsageCutoffBehaviorBillingPeriodChange, SubscriptionUpdateUsageCutoffBehaviorNeverReset:
		return true
	}
	return false
}

func (e SubscriptionUpdateUsageCutoffBehavior) String() string {
	return string(e)
}

func (e *SubscriptionUpdateUsageCutoffBehavior) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionUpdateUsageCutoffBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionUpdateUsageCutoffBehavior", str)
	}
	return nil
}

func (e SubscriptionUpdateUsageCutoffBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of the integration sync
type SyncStatus string

const (
	// Error sync status
	SyncStatusError SyncStatus = "ERROR"
	// No sync required status
	SyncStatusNoSyncRequired SyncStatus = "NO_SYNC_REQUIRED"
	// Pending sync status
	SyncStatusPending SyncStatus = "PENDING"
	// Successful sync status
	SyncStatusSuccess SyncStatus = "SUCCESS"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusError,
	SyncStatusNoSyncRequired,
	SyncStatusPending,
	SyncStatusSuccess,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusError, SyncStatusNoSyncRequired, SyncStatusPending, SyncStatusSuccess:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the task
type TaskStatus string

const (
	// The task is canceled
	TaskStatusCanceled TaskStatus = "CANCELED"
	// The task is completed
	TaskStatusCompleted TaskStatus = "COMPLETED"
	// The task is failed
	TaskStatusFailed TaskStatus = "FAILED"
	// The task is in progress
	TaskStatusInProgress TaskStatus = "IN_PROGRESS"
	// The task is partially failed
	TaskStatusPartiallyFailed TaskStatus = "PARTIALLY_FAILED"
	// The task is pending
	TaskStatusPending TaskStatus = "PENDING"
)

var AllTaskStatus = []TaskStatus{
	TaskStatusCanceled,
	TaskStatusCompleted,
	TaskStatusFailed,
	TaskStatusInProgress,
	TaskStatusPartiallyFailed,
	TaskStatusPending,
}

func (e TaskStatus) IsValid() bool {
	switch e {
	case TaskStatusCanceled, TaskStatusCompleted, TaskStatusFailed, TaskStatusInProgress, TaskStatusPartiallyFailed, TaskStatusPending:
		return true
	}
	return false
}

func (e TaskStatus) String() string {
	return string(e)
}

func (e *TaskStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskStatus", str)
	}
	return nil
}

func (e TaskStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the task
type TaskType string

const (
	// The task is an import of product catalog from integration
	TaskTypeImportIntegrationCatalog TaskType = "IMPORT_INTEGRATION_CATALOG"
	// The task is an import of customers from integration
	TaskTypeImportIntegrationCustomers TaskType = "IMPORT_INTEGRATION_CUSTOMERS"
	// The task is an import of subscriptions in bulk
	TaskTypeImportSubscriptionsBulk TaskType = "IMPORT_SUBSCRIPTIONS_BULK"
	// The task is a batch recalculation of entitlements
	TaskTypeRecalculateBatchEntitlements TaskType = "RECALCULATE_BATCH_ENTITLEMENTS"
	// The task is a recalculation of entitlements
	TaskTypeRecalculateEntitlements TaskType = "RECALCULATE_ENTITLEMENTS"
	// The task is a resync integration
	TaskTypeResyncIntegration TaskType = "RESYNC_INTEGRATION"
	// The task is a subscription migration v1
	TaskTypeSubscriptionMigration TaskType = "SUBSCRIPTION_MIGRATION"
	// The task is a subscription migration v2
	TaskTypeSubscriptionMigrationV2 TaskType = "SUBSCRIPTION_MIGRATION_V2"
)

var AllTaskType = []TaskType{
	TaskTypeImportIntegrationCatalog,
	TaskTypeImportIntegrationCustomers,
	TaskTypeImportSubscriptionsBulk,
	TaskTypeRecalculateBatchEntitlements,
	TaskTypeRecalculateEntitlements,
	TaskTypeResyncIntegration,
	TaskTypeSubscriptionMigration,
	TaskTypeSubscriptionMigrationV2,
}

func (e TaskType) IsValid() bool {
	switch e {
	case TaskTypeImportIntegrationCatalog, TaskTypeImportIntegrationCustomers, TaskTypeImportSubscriptionsBulk, TaskTypeRecalculateBatchEntitlements, TaskTypeRecalculateEntitlements, TaskTypeResyncIntegration, TaskTypeSubscriptionMigration, TaskTypeSubscriptionMigrationV2:
		return true
	}
	return false
}

func (e TaskType) String() string {
	return string(e)
}

func (e *TaskType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskType", str)
	}
	return nil
}

func (e TaskType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Tiers mode
type TiersMode string

const (
	// Tiered
	TiersModeGraduated TiersMode = "GRADUATED"
	// Volume
	TiersModeVolume TiersMode = "VOLUME"
)

var AllTiersMode = []TiersMode{
	TiersModeGraduated,
	TiersModeVolume,
}

func (e TiersMode) IsValid() bool {
	switch e {
	case TiersModeGraduated, TiersModeVolume:
		return true
	}
	return false
}

func (e TiersMode) String() string {
	return string(e)
}

func (e *TiersMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TiersMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TiersMode", str)
	}
	return nil
}

func (e TiersMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates the behavior of the subscription when the trial is expired.
type TrialEndBehavior string

const (
	// cancel the subscription when the trial is expired
	TrialEndBehaviorCancelSubscription TrialEndBehavior = "CANCEL_SUBSCRIPTION"
	// convert the trial subscription to a paid subscription
	TrialEndBehaviorConvertToPaid TrialEndBehavior = "CONVERT_TO_PAID"
)

var AllTrialEndBehavior = []TrialEndBehavior{
	TrialEndBehaviorCancelSubscription,
	TrialEndBehaviorConvertToPaid,
}

func (e TrialEndBehavior) IsValid() bool {
	switch e {
	case TrialEndBehaviorCancelSubscription, TrialEndBehaviorConvertToPaid:
		return true
	}
	return false
}

func (e TrialEndBehavior) String() string {
	return string(e)
}

func (e *TrialEndBehavior) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrialEndBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrialEndBehavior", str)
	}
	return nil
}

func (e TrialEndBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// day or month.
type TrialPeriodUnits string

const (
	TrialPeriodUnitsDay   TrialPeriodUnits = "DAY"
	TrialPeriodUnitsMonth TrialPeriodUnits = "MONTH"
)

var AllTrialPeriodUnits = []TrialPeriodUnits{
	TrialPeriodUnitsDay,
	TrialPeriodUnitsMonth,
}

func (e TrialPeriodUnits) IsValid() bool {
	switch e {
	case TrialPeriodUnitsDay, TrialPeriodUnitsMonth:
		return true
	}
	return false
}

func (e TrialPeriodUnits) String() string {
	return string(e)
}

func (e *TrialPeriodUnits) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrialPeriodUnits(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrialPeriodUnits", str)
	}
	return nil
}

func (e TrialPeriodUnits) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Unit transformation round type
type UnitTransformationRound string

const (
	// Apply round down after transformation
	UnitTransformationRoundDown UnitTransformationRound = "DOWN"
	// Apply round up after transformation
	UnitTransformationRoundUp UnitTransformationRound = "UP"
)

var AllUnitTransformationRound = []UnitTransformationRound{
	UnitTransformationRoundDown,
	UnitTransformationRoundUp,
}

func (e UnitTransformationRound) IsValid() bool {
	switch e {
	case UnitTransformationRoundDown, UnitTransformationRoundUp:
		return true
	}
	return false
}

func (e UnitTransformationRound) String() string {
	return string(e)
}

func (e *UnitTransformationRound) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitTransformationRound(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitTransformationRound", str)
	}
	return nil
}

func (e UnitTransformationRound) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of marker for a usage history point
type UsageMarkerType string

const (
	// Usage was reset due to reaching the end of a usage period
	UsageMarkerTypePeriodicReset UsageMarkerType = "PERIODIC_RESET"
	// Usage was reset due to a subscription change
	UsageMarkerTypeSubscriptionChangeReset UsageMarkerType = "SUBSCRIPTION_CHANGE_RESET"
)

var AllUsageMarkerType = []UsageMarkerType{
	UsageMarkerTypePeriodicReset,
	UsageMarkerTypeSubscriptionChangeReset,
}

func (e UsageMarkerType) IsValid() bool {
	switch e {
	case UsageMarkerTypePeriodicReset, UsageMarkerTypeSubscriptionChangeReset:
		return true
	}
	return false
}

func (e UsageMarkerType) String() string {
	return string(e)
}

func (e *UsageMarkerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageMarkerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageMarkerType", str)
	}
	return nil
}

func (e UsageMarkerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsageMeasurementSortFields string

const (
	UsageMeasurementSortFieldsCreatedAt     UsageMeasurementSortFields = "createdAt"
	UsageMeasurementSortFieldsEnvironmentID UsageMeasurementSortFields = "environmentId"
	UsageMeasurementSortFieldsID            UsageMeasurementSortFields = "id"
)

var AllUsageMeasurementSortFields = []UsageMeasurementSortFields{
	UsageMeasurementSortFieldsCreatedAt,
	UsageMeasurementSortFieldsEnvironmentID,
	UsageMeasurementSortFieldsID,
}

func (e UsageMeasurementSortFields) IsValid() bool {
	switch e {
	case UsageMeasurementSortFieldsCreatedAt, UsageMeasurementSortFieldsEnvironmentID, UsageMeasurementSortFieldsID:
		return true
	}
	return false
}

func (e UsageMeasurementSortFields) String() string {
	return string(e)
}

func (e *UsageMeasurementSortFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageMeasurementSortFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageMeasurementSortFields", str)
	}
	return nil
}

func (e UsageMeasurementSortFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Update behavior
type UsageUpdateBehavior string

const (
	// Delta update
	UsageUpdateBehaviorDelta UsageUpdateBehavior = "DELTA"
	// Set update
	UsageUpdateBehaviorSet UsageUpdateBehavior = "SET"
)

var AllUsageUpdateBehavior = []UsageUpdateBehavior{
	UsageUpdateBehaviorDelta,
	UsageUpdateBehaviorSet,
}

func (e UsageUpdateBehavior) IsValid() bool {
	switch e {
	case UsageUpdateBehaviorDelta, UsageUpdateBehaviorSet:
		return true
	}
	return false
}

func (e UsageUpdateBehavior) String() string {
	return string(e)
}

func (e *UsageUpdateBehavior) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageUpdateBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageUpdateBehavior", str)
	}
	return nil
}

func (e UsageUpdateBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A vendor identifier object
type VendorIdentifier string

const (
	// Auth0 integration vendor identifier
	VendorIdentifierAuth0 VendorIdentifier = "AUTH0"
	// AWS Marketplace integration vendor identifier
	VendorIdentifierAwsMarketplace VendorIdentifier = "AWS_MARKETPLACE"
	// Google BigQuery integration vendor identifier
	VendorIdentifierBigQuery VendorIdentifier = "BIG_QUERY"
	// HubSpot integration vendor identifier
	VendorIdentifierHubspot VendorIdentifier = "HUBSPOT"
	// OpenFGA integration vendor identifier
	VendorIdentifierOpenFga VendorIdentifier = "OPEN_FGA"
	// Salesforce integration vendor identifier
	VendorIdentifierSalesforce VendorIdentifier = "SALESFORCE"
	// Snowflake integration vendor identifier
	VendorIdentifierSnowflake VendorIdentifier = "SNOWFLAKE"
	// Stripe integration vendor identifier
	VendorIdentifierStripe VendorIdentifier = "STRIPE"
	// Zuora integration vendor identifier
	VendorIdentifierZuora VendorIdentifier = "ZUORA"
)

var AllVendorIdentifier = []VendorIdentifier{
	VendorIdentifierAuth0,
	VendorIdentifierAwsMarketplace,
	VendorIdentifierBigQuery,
	VendorIdentifierHubspot,
	VendorIdentifierOpenFga,
	VendorIdentifierSalesforce,
	VendorIdentifierSnowflake,
	VendorIdentifierStripe,
	VendorIdentifierZuora,
}

func (e VendorIdentifier) IsValid() bool {
	switch e {
	case VendorIdentifierAuth0, VendorIdentifierAwsMarketplace, VendorIdentifierBigQuery, VendorIdentifierHubspot, VendorIdentifierOpenFga, VendorIdentifierSalesforce, VendorIdentifierSnowflake, VendorIdentifierStripe, VendorIdentifierZuora:
		return true
	}
	return false
}

func (e VendorIdentifier) String() string {
	return string(e)
}

func (e *VendorIdentifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorIdentifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorIdentifier", str)
	}
	return nil
}

func (e VendorIdentifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of integration
type VendorType string

const (
	// Authentication integration type
	VendorTypeAuth VendorType = "AUTH"
	// Billing integration type
	VendorTypeBilling VendorType = "BILLING"
	// CRM integration type
	VendorTypeCrm VendorType = "CRM"
	// Data export integration type
	VendorTypeDataExport VendorType = "DATA_EXPORT"
	// Marketplace integration type
	VendorTypeMarketplace VendorType = "MARKETPLACE"
)

var AllVendorType = []VendorType{
	VendorTypeAuth,
	VendorTypeBilling,
	VendorTypeCrm,
	VendorTypeDataExport,
	VendorTypeMarketplace,
}

func (e VendorType) IsValid() bool {
	switch e {
	case VendorTypeAuth, VendorTypeBilling, VendorTypeCrm, VendorTypeDataExport, VendorTypeMarketplace:
		return true
	}
	return false
}

func (e VendorType) String() string {
	return string(e)
}

func (e *VendorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorType", str)
	}
	return nil
}

func (e VendorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Weekly reset period according to configuration
type WeeklyAccordingTo string

const (
	WeeklyAccordingToEveryFriday WeeklyAccordingTo = "EveryFriday"
	// Every Monday
	WeeklyAccordingToEveryMonday   WeeklyAccordingTo = "EveryMonday"
	WeeklyAccordingToEverySaturday WeeklyAccordingTo = "EverySaturday"
	// Every Sunday
	WeeklyAccordingToEverySunday WeeklyAccordingTo = "EverySunday"
	// Every Thursday
	WeeklyAccordingToEveryThursday WeeklyAccordingTo = "EveryThursday"
	// Every Tuesday
	WeeklyAccordingToEveryTuesday WeeklyAccordingTo = "EveryTuesday"
	// Every Wednesday
	WeeklyAccordingToEveryWednesday WeeklyAccordingTo = "EveryWednesday"
	// Subscription start
	WeeklyAccordingToSubscriptionStart WeeklyAccordingTo = "SubscriptionStart"
)

var AllWeeklyAccordingTo = []WeeklyAccordingTo{
	WeeklyAccordingToEveryFriday,
	WeeklyAccordingToEveryMonday,
	WeeklyAccordingToEverySaturday,
	WeeklyAccordingToEverySunday,
	WeeklyAccordingToEveryThursday,
	WeeklyAccordingToEveryTuesday,
	WeeklyAccordingToEveryWednesday,
	WeeklyAccordingToSubscriptionStart,
}

func (e WeeklyAccordingTo) IsValid() bool {
	switch e {
	case WeeklyAccordingToEveryFriday, WeeklyAccordingToEveryMonday, WeeklyAccordingToEverySaturday, WeeklyAccordingToEverySunday, WeeklyAccordingToEveryThursday, WeeklyAccordingToEveryTuesday, WeeklyAccordingToEveryWednesday, WeeklyAccordingToSubscriptionStart:
		return true
	}
	return false
}

func (e WeeklyAccordingTo) String() string {
	return string(e)
}

func (e *WeeklyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WeeklyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WeeklyAccordingTo", str)
	}
	return nil
}

func (e WeeklyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The widget type
type WidgetType string

const (
	WidgetTypeCheckout       WidgetType = "CHECKOUT"
	WidgetTypeCustomerPortal WidgetType = "CUSTOMER_PORTAL"
	WidgetTypePaywall        WidgetType = "PAYWALL"
)

var AllWidgetType = []WidgetType{
	WidgetTypeCheckout,
	WidgetTypeCustomerPortal,
	WidgetTypePaywall,
}

func (e WidgetType) IsValid() bool {
	switch e {
	case WidgetTypeCheckout, WidgetTypeCustomerPortal, WidgetTypePaywall:
		return true
	}
	return false
}

func (e WidgetType) String() string {
	return string(e)
}

func (e *WidgetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetType", str)
	}
	return nil
}

func (e WidgetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Yearly reset period according to configuration
type YearlyAccordingTo string

const (
	// Subscription start
	YearlyAccordingToSubscriptionStart YearlyAccordingTo = "SubscriptionStart"
)

var AllYearlyAccordingTo = []YearlyAccordingTo{
	YearlyAccordingToSubscriptionStart,
}

func (e YearlyAccordingTo) IsValid() bool {
	switch e {
	case YearlyAccordingToSubscriptionStart:
		return true
	}
	return false
}

func (e YearlyAccordingTo) String() string {
	return string(e)
}

func (e *YearlyAccordingTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = YearlyAccordingTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid YearlyAccordingTo", str)
	}
	return nil
}

func (e YearlyAccordingTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The group type of the experiment
type ExperimentGroupType string

const (
	// Control group of the experiment
	ExperimentGroupTypeControl ExperimentGroupType = "CONTROL"
	// Variant group of the experiment
	ExperimentGroupTypeVariant ExperimentGroupType = "VARIANT"
)

var AllExperimentGroupType = []ExperimentGroupType{
	ExperimentGroupTypeControl,
	ExperimentGroupTypeVariant,
}

func (e ExperimentGroupType) IsValid() bool {
	switch e {
	case ExperimentGroupTypeControl, ExperimentGroupTypeVariant:
		return true
	}
	return false
}

func (e ExperimentGroupType) String() string {
	return string(e)
}

func (e *ExperimentGroupType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentGroupType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid experimentGroupType", str)
	}
	return nil
}

func (e ExperimentGroupType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
